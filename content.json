{"pages":[{"title":"about","text":"안녕하세요, 개발하는 PM Pineoc 입니다.업무는 PM(Project Manager)을 하고 있지만함께하는 사람들의 삶에 도움이되는 소프트웨어를 만들고 싶습니다. 우리나라 PM의 지식 공유가 많이 이뤄질 수 있도록 하고 싶습니다. Experience PUBG Corp, Dev/Live Project Manager (2018-01 ~ Present) Dev PM: Pass 3 Assist Live PM: Patch Spec, Patch Ops, Patch note 전반을 담당 Jira, Confluence, Fisheye 등 개발 업무 지원 슬랙 봇(Pubg-helper) 개발하여 업무 개선 스마트스터디, 개발자 (2017-05 ~ 2017-12) 모바일 앱 개발자로 앱 개발에 사용되는 라이브러리 업데이트, 앱 업데이트 담당. 앱 프로젝트 문서화, 프로젝트 최신화(OS 버전 대응, 라이브러리 업데이트 대응) 월천상회, 개발자 (2015-07 ~ 2017-05) 웹, 앱 서비스 개발 전반 담당 Cocos2d-x 게임 엔진을 이용하여 유아 컨텐츠 앱 개발 용감한상상, 개발자 (2014-07 ~ 2015-02) 기획자, 디자이너와 함께 개발자로 협업, 주식 교육 게임 앱 개발. 게임 클라이언트 &amp; 게임 서버 개발. 운영 경험.","link":"/blog/about/index.html"}],"posts":[{"title":"2020 회고 파티를 회고해보자","text":"2020 회고?대학교때부터 프로젝트도 하고 공부도 같이하는 친구들과 그룹 스터디를 하는 어느날에 주니어, 시니어란 무엇일까에 대한 이야기를 하게 되었습니다. 그러다가 여러가지 글들을 보게되었죠. 중간에 율무님(진유림님)의 글도 보면서 오.. 중니어란 이런 것인가 하기도 했죠.중니어의 고뇌: 1인분 개발자, 다음을 찾아서 연말이기에 많은 엔지니어들이 회고록을 쓰기도 했고“우리도 3-5년차의 고민을 같이 가져보는 시간 겸 회고를 하면 어떨까?!”해서 회고를 진행하게 되었습니다. 회고 준비특정 포맷을 두고 하는 것 보다는 자유롭게 연말 파티 겸 회고를 해보았습니다. “우리 올해 열심히 살았다” + “내년에도 잘 살아보자” + “우리 커리어 화이팅” 느낌으로요. 😉 다만 처음 회고를 하는 친구들이어서 몇가지 예시들을 공유해주고 회고를 위한 자료를 자유롭게 준비해보았습니다. 참고 자료회고 (Retrospective)에 대한 정리 및 설계 · Issue #8 · JaeYeopHan/tip-archive 2019년 상반기 회고 2019년, 상반기 회고. 내가 알고, 내가 모르는 것 https://github.com/oaksong/developers-retrospective 추가 참고: Pineoc의 2019 Retrospective(회고) 이렇게 회고 준비를 하면서 11월 말에 맛있는 것 먹으면서 재미있게 수다떨면 되겠다 싶었지만… 12월 초에 코로나 시국이 안좋아졌네요.오프라인으로 모이지는 못해도 온라인으로 회고를 할 수 있으니 각자 맛있는 것을 들고 이야기하는 것으로 정하고 Google Meets를 통해 모였습니다. 😇 회고 시작! 회고 시작 전, 회고를 같이 진행했던 사람들인 Pino(나), Shy, Ico, Oso를 짧게 소개해봅니다. Pino: 엔지니어→PM 전직한지 3년, 시니어 PM은 무엇일까, 커리어 어떻게 나아갈지 고민중 Shy: 모바일 개발→프론트엔드 개발 3년차, 시니어 프론트엔드 개발로 가는길은 뭘까 고민중 Ico: 모바일 개발(SDK 개발) 5년차, 중니어? 시니어? 나는 어디? Oso: 개발 &amp; 화이트박스 검증 5년차, 미래 커리어 고민중 (참고) 각각의 회고 내용은 민감함 개인 정보, 회사 정보를 생략하였습니다. 글 보시는데에 참고해주세요. 🙏 Pino - 2020년 업무를 돌아보며 내년에는 PM으로 뭘해야할까(+뭘하고 싶을까)회고를 해보자고한 주최자가 저라서 첫 시작을 끊었습니다. 😎다만 저는 업무 평가를 해버렸네요. (하라는 회고는 안하고) 사실 2020년에 정신없이 살아버리기도 했고 뭐하고 살았는지 살펴보다가 연말 평가를 안했다는 사실을 깨닫고 회고하는 겸 평가 정리를 해버렸습니다 😂 작년 쯤에 강미경님의 “영혼까지 끌어쓸는 자기평가” 문서를 보고 요렇게 한번 정리해봐야겠다 싶었는데 이번에 한번 해보게되었습니다. 99CON : 영혼까지 끌어쓰는 자기평가 - 강미경 정리해보면 저는 개발 PM(Project Manager)으로 아래와 같이 일을 하고 있습니다. 라이브 이슈 대응 및 대응 개선 팀 관리 서포트 (엔지니어 팀 관리) 관리 지원 조직을 위한 자동화 지원 및 업무 생산성 도구 가이드 지원 정리 점수표 만들고 마무리까지 해보았지만..중간에 회고의 목적이 이게 아니지! 하고 2020 업무 평가를 끝내고 회고를 했습니다. 😈자세한 저의 회고 내용은 짧게 공유드리고 연말 포스팅으로 공유드리겠습니다. 2021년에는 어떤 것들을 더 잘해야할까 고민해보자 3년차, 컴포트존을 벗어나려고 노력해보자 PM은 어떤 일들을 더 잘해야할까에 대해 고민하고 더 수련하자 2021년에는 개인 OKR을 세워서 살아보자 + 책도 더 읽고 블로그도 꾸준히 운영해보자 요렇게 정리한 내용을 바탕으로 이야기를 했고 OKR이 무엇인지도 조금 설명하고 블로그도 영업했네요. 흐흐컴포트존을 벗어나서 조금 더 불타는🔥 2021년을 살아보자고 마음도 먹어보았습니다. Oso - 2020년 업무를 돌아보기 &amp; 퇴사 후 뭐할까Oso도 제가 참고했던 강미경님의 자기 평가 자료를 보고 자신의 업무, 개인 공부 내용을 정리했네요.저와 동일하게 올해 했던일을 나열해보고, 각 항목 별로 회고를 했어요. 소프트웨어 평가 사양서 업데이트 프로젝트를 하면서 표준을 많이 보고 배움 &amp; 산출물 만들어내는 스킬 생김 단위 검증, 안정성 검증 프로젝트 정적 검증 직접 경험 👍 &amp; 검증 업무 잘해냈음 검증 도구(프로그램) 개선 버그 리포트(패치에 반영됨!) &amp; 보고서 생성 프로그램 개선 iOS 개발 공부 인터넷 강의로 기본은 익혔으나 실무가 부족. 현재는 개발을 취미 루트로 고민 Oso는 현재 자신의 업무와 미래의 커리어를 고민하고 있었어요.이직을 한다고 했을 때, QA? 개발자? 또 어떤 개발자를 할지 등등 고민이 많아보였습니다. 최근에는 AI에 관심이 생겨서 취미로 한번 공부해볼 예정이라고 하네요.Oso의 이런저런 고민을 같이 이야기하면서 회고는 마무리했습니다. Shy - 이직 후 적응 👩🏻‍💻Shy는 작년 말에 이직을 하고 2020년에 업무에 적응하는데에 온 힘을 다했던 이야기, 회고를 했습니다.업무 하나하나에 대한 회고를 했다기 보다 어떤 일에서 어려움을 겪었고 어떤 식으로 고민했었는지, 어떻게 풀어가고 있는지를 이야기했네요. 새로운 타입의 리더와 같이 일하기 나와 다른 스타일을 가진 사람과 나의 스타일을 지키면서 더 분명하게 분위기를 해치지 않으면서 의사를 전달하는 방법을 배움(with 상담선생님) 새로운 업무 방식(일정이 없어졌다 + 다른 팀과 직접 커뮤니케이션, 혼자 설계) 전에는 동료들과 같이 일했지만 혼자 해나가야 하는 것들이 많아짐. 하지만 모두 꼼꼼하게 하려고 더 노력했음 → 버그가 줄었고 오류 대처도 빠르게, 에러 핸들링 레벨업 하드 스킬 레벨업 리팩토링 요령을 배웠음 왜 그런지 모르겠지만 잘 돌아가요 하지 않기. 함수의 공식 문서를 살펴보고 몇가지 검증, 테스트를 하고 파악해서 왜 해결되었는지 반이상 파악한 내용을 사용함. 내가 만든 결과물에 대한 미심쩍음이 줄었음 2021년에는 Angular 공식 문서 공부 다시 시작 (올해 했었지만 까먹음) CSS 능력 다지기 반응형 UI, 원하는 레이아웃 자유자재로 표현하는 수준으로 레벨업하기 + SCSS 공부 에러 핸들링 &amp; 테스트 공부하고 싶다 Shy에게도 2020년에는 많은 고민들이 있었고 잘 극복해나갔습니다. 😎(바로 옆에서 쭉 지켜봤지만 다 해내더라구요. 👍 ) Ico - 만 5년차 개발자, 고이지 말고 더 나아가자Ico 본인 블로그 글: 2020년 회고 - Daun Joung’s Memory 이제 만 5년차가 된 모바일 SDK 개발자 Ico, 2020년에 있던 일의 회고 뿐만 아니라 지금까지의 경력도 포함해서 고민을 같이 이야기했습니다.2020년에 있었던 일 중 잘한 일, 아쉬웠던 일, 부족했던 일을 정리해서 쭉 이야기해주었습니다.회고 총평을 정리한 내용은, 2020년 내 자신에 대해 평가를 종합해보면 회사에서의 ‘일’은 잘 하였지만, 개발자로서 부족함을 깨달았던 한 해 였던 것 같다. 유지보수를 용이하게 하기 위한 코드 설계와 프로그램을 안정적으로 구현하기 위한 기초 동작 방식 고민에 대한 공부가 제일 필요하다고 느꼈다. 2021년은 부족한 부분을 탄탄하게 채울 수 있는 내실을 다지는 한해가 되고자 한다. 자세한 내용은 Ico의 블로그 글을 읽어봐주세요! 😸 회고 소감제가 관리를 돕는 팀에서 회고를 진행하는데요. 이 때는 잘한점/아쉬운점을 정리해서 다음 액션 아이템을 만드는 것에 집중했었다면, 이번 친구들과의 회고 파티에서는 수고했다! 내년에 잘 살아보자!의 느낌이 더 강한 즐거운 회고였습니다. 각자의 회고 느낀점도 한번 들어보겠습니다. 👂 Pino: 그동안 회고는 개인적으로 매년했는데 같이 이야기하면서 정리해보는 것은 처음이었습니다. 다른 사람들은 어떤 생각을 하는지 직접 들어볼 수 있어서 좋았어요. 그동안은 글을 통해서 보았지만 수다떨면서 회고를 해보는 경험 자체가 좋네요. 내년에도 그룹 회고하면 좋을 것 같아요. 내년에도 같이 합시다! Oso: 회고는 처음 해봤는데 한 해동안 있었던 일을 정리해보니 내가 이런 일들을 했었구나, 이런 걸 배웠구나 하고 느낄 수 있어서 좋았습니다. 그냥 지나쳤으면 잊어버렸을 일들도 되새겨보면서 뭔가 더 쌓인 것 같은 기분을 느낄 수 있었어요. 앞으로 어떻게 하고 싶은지도 좀 정리가 되는 것 같구요. 커리어로 고민이 많은 한 해 였는데 내년에는 새로운 고민으로 다시 회고해 보고 싶네요. 다른 사람들은 어떻게 살고 있는지 보고 배우면서 즐거운 시간이었습니다. Shy: TBU Ico: 회고를 준비기위해 과거를 정리하면서 신기하게도 미래의 내가 하고 싶은 일을 발견한 시간이었습니다. 올해의 방황은 미래를 위한 고민을 한 양분으로 삼고, 내년에는 가고싶은 길을 향해 여유롭지만 부지런하게 걸어볼까 합니다. 항상 내가 가려는 길을 응원해주고 각자의 길에서 최선을 다하는 친구들 너무 멋지고 고맙습니다! 2020 회고의 회고를 마치며온라인 회고를 준비하면서 페이스북에 다른 커뮤니티 리더분들도 온라인 회고 세션을 만들고 진행하시는 것 같더라구요.(역시 연말에는 회고가 제맛!) DevC Seoul 2020 원격 회고 기쁨 / 슬픔 / 이룸 / 깨달음 / 시작 / 끝 요렇게 키워드로 내용을 정리해서 회고를 진행하셨네요 🙂 Zoom을 통해 진행한 무려 30명이 같이한 회고네요! (이 회고의 후기도 궁금해집니다.) 온라인 2020 회고해봄 사진을 고르고 그 사진에 이야기를 붙이는 방식! 정말 편하게 되돌아보는 회고였네요. 회고해봄 작성 가이드 요런 가이드도 참 잘만드시는 해봄님! 😎 회고 방법에 참고해야겠어요 👍 2020년은 시국도 그렇고 많은 분들이 힘든 한 해였다고 생각합니다.모두 올해 2020년 고생많으셨고 남은 한해, 내년에도 건강하고 즐거운 날이 모두에게 가득했으면 좋겠습니다.","link":"/blog/2020/12/26/2020-Retrospective-with-friends/"},{"title":"About Jira new screen view","text":"새로운 Jira 이슈 뷰 소개 What is the new Jira issue view? 🎥 Jira Software: New Issue View - Demo Den - Nov 2020 2021년 3월 31부터 변경될 Jira Cloud 이슈 뷰의 소개 글을 번역, 정리해보는 글입니다.새로운 뷰에서는 어떤 것들이 달라지는지, 쓱 살펴보겠습니다. 뭐가 바뀌나요? Quick-add buttons: subtasks, 첨부 파일을 추가하거나 이슈 링크 등 퀵 버튼이 추가되었습니다. Transition issues: 워크플로우 버튼이 하나로 통합되어 드롭다운으로 한눈에 보여질 수 있도록 변경되었습니다. Watch, vote, and more actions: 지켜보기, 투표, 좋아요 등 액션 버튼이 위로 모이게되었습니다. Pinned fields: 자신에게 중요한 필드를 모아서 볼 수 있는 핀(먼저보기) 필드를 설정할 수 있게되었습니다. More fields: “Show more” 버튼을 통해 다른 필드를 볼 수 있도록 변경되었습니다. (담당자, 레이블 등) Configure issue layout: 필드를 이동하거나 숨기거나 설정할 수 있습니다. Activity section: 댓글 창이 항상 떠있게 변경되어 언제든지 댓글을 입력할 수 있게되었습니다. Attachments: 첨부 파일 목록을 한번에 받을 수 있게되었네요. Flexible layout: 필드를 오른쪽/왼쪽에 놓을지 설정할 수 있게되었습니다. 핵심 기능한 스크린에서 확인하고 수정 새로운 이슈 뷰에서는 view 스크린과 edit 스크린이 통합되어 한 화면에서 정보를 확인, 수정, 트랜지션 모두 가능하게되었습니다. 중요한 필드는 핀(Pin)! 이슈 필드 중 중요한 필드를 Pin하여 이슈 정보 화면 상단에서 볼 수 있게되었습니다. 이슈에 빠르게 연관 컨텐츠 추가 첨부 파일을 추가하거나 서브태스크 추가, 링크 추가 등을 할 수 있는 퀵 버튼이 생겼습니다. 트랜지션 단순화 워크플로우 스탭에 따라 버튼이 여러개 생기는 방식이 아닌 하나의 드롭다운에서 트랜지션 할 수 있도록 변경되었습니다. 이 변화가 좋은지는 모르겠지만 변경되면서 다음 상태 버튼이 바로 보이지 않아 약간의 불편함이 있을 것 같긴하네요. 어디서든 댓글 작성 가능! 댓글 창이 아래에 항상 보이게되어 스크롤을 내리지 않고 댓글을 바로 작성할 수 있도록 변경되었네요. 👍 첨부 파일 기능 개선 첨부 파일을 리스트로 보는 것, 미리보기 리스트(strip view) 화면이 개선되었습니다. 댓글/워크로그 링크 복사 댓글이나 워크로그 내용을 바로 복사 붙여넣기 할 수 있는 기능이 추가되었네요. New Atlassian editor (with markdown) 기존에는 h1, h2와 같은 매크로를 이용해서 렌더링 되었는데 마크다운 형식이 보일 수 있도록 변경된다고 합니다. Show more Show more 버튼을 눌러야 보이는 필드들에 대해 설정할 수 있게되었습니다. 많은 필드들이 show more 항목으로 들어가서 바로 보기 어려워질 수도 있겠다는 생각이 들지만…버튼 하나 누르면 보이긴해서 약간의 불편함이 추가되지 않을까 싶긴하네요. 향후 개선향후 개선할 내용은 아래와 같습니다. Issue layout: 필드를 찾기 쉽고 보기 쉽게 이슈 레이아웃을 개선합니다. Performance: 새로운 이슈 뷰의 성능이 이전 뷰에 도달하고 능가하도록 개선합니다. Additional features: 기존 뷰에 있던 기능들을 가져옵니다. 투표, 서브태스크 시간 추정, 남은 시간 필드 업데이트 등 새로운 이슈 뷰 내용 정리 소감새로운 이슈 뷰에 대해 정리해보면서 느낀점은… 차세대 프로젝트로 다 넘기고 싶어하는 것 같다는 느낌을 받았습니다.저는 개인 공부나 일을 정리하는데 차세대 프로젝트를 사용하고 있는데 새로운 이슈 뷰가 낯설지 않았는데요.변경되는 방향을 보았는데 차세대 프로젝트 이슈 뷰와 같아서 흐으으으음 했습니다. 😂 Atlassian 소프트웨어 개발 방식이 점차 클라우드, 단일 UX 개발 방향으로 가는 것 같네요.(지난번에 Atlassian 서비스 Cloud 전환 선언! 포스트와 연관이 있어보입니다.) 뭐 차세대 프로젝트 사용하면서 별다른 불편함은 없었는데 개인 혼자 사용하는 것과 많은 팀원들과 사용할 때는 어떤 어려움이 있을지 모르겠네요. 🤔 차차 개선되는 것을 지켜봐야겠습니다. 다음 포스트에서 뵈어요! 🙏","link":"/blog/2020/11/29/About-Jira-new-screen-view/"},{"title":"2021 회고","text":"2020 회고 때는 어떤 2021 목표 세웠을까?2020년에도 회고를 했는데 2021년도 빼놓을 수 없죠!근데 작년에 회고한 것 치고 2021년의 삶은 잘 살았는지 보았더니 반성할게 더 많았던 것 같습니다 😂😂 커리어 3년차, 컴포트존(참고: Wiki: 안전지대, Comfort zone)을 벗어나려고 노력해보자 조금 더 어려운 일, 도전적인 일을 시도하고 성장하자 운영보다는 개선을, 운영을 하더라도 개선을 생각하면서 하자 PM은 어떤 일들을 더 잘해야할까에 대해 고민하고 더 수련하자 엔지니어가 좋은지 PM이 좋은지 아직 갈팡지팡하지만 두개를 다 키워보자 (힐러+탱커 느낌으로 성기사..) 라이브 부서에서 이슈 대응을 원활히 할 수 있도록 개선하자 모니터링 툴 개선, 문제 수정 프로세스 개선 등 나 혼자 모니터링하고 대응하는 것이 아닌 팀이 대응할 수 있도록 만들자 개인 공부 2021년에는 개인 OKR을 세워서 살아보자 (OKR 책 읽은 것을 써먹어보자) 일단 2021년 1분기 목표부터 세워보자 (3개 Objective, 하위에 3개씩 Key Result) 블로그 글 한달에 2개씩 24개의 글을 쓰는 것을 목표로 하자 초과 목표로 30개까지?! PM 책 뿐만 아니라 기술서적도 많이 읽어보자 책 리뷰 포스팅도 해보자 2021년에는 어떻게 살았지?커리어3년차 컴포트존은 벗어나려고 노력했나? 팀 리드로 업무하는 것에 있어서 상반기에는 고민을 많이 했던 것 같은데 후반기에는 개인 업무에 집중해버린 느낌입니다 깊게 생각하지 않아도 할 수 있는 혼자할 수 있는 일, 운영에 또 집중해버린 것 같네요 개선한 것은? 잘했다고 생각하는 것은? 팀원들이 팀 업무를 돌아가면서 잘 진행될 수 있도록 한 것 (팀원들이 잘 해주었다) 팀 리드로 무난하게 보낸 것 (Not Bad) 개발 PM으로 내 정체성, 고민들을 했나 어느정도 내가 걷고 있는 길의 정체성은 정리된 느낌입니다 Dark PM/PO 모임에서 다른 분들이 이야기해주신 것들과 업무를 고민해봤을 때 지금은 릴리스 매니저로 정의할 수 있었네요 사실 PM 업무한지 2년째 부터 어렴풋이 릴리스 매니저로 이해하고 일하긴 했습니다 라이브 부서 이슈 대응 아직까지 제가 70% 대응하고 있는 상황이어서 이걸 다른 팀원들도 케이스를 경험하거나 스터디할 수 있도록 여러 정보를 공유해야겠습니다 개인 공부2021 OKR을 1분기로 세웠는데 아무것도 못했네요 😂 운동(몸무게=79kg, 근력량=59kg, 체지방=18%), 커리어(이력서, 포트폴리어 정리), 취미 생활(그림, 요리, IT 공부) 세워보았다는 것에 의의를 둬봅니다.. 나름 2주 정도는 목표잡고 진행하는데에 집중할 수 있었는데 일하다보니 다 까먹거나 피곤해서 그냥 살아버렸네요 블로그 열심히 쓰긴했습니다. 22개의 포스트를 작성했네요. 목표는 매달 2개, 24개 포스트가 목표였으니 거의 달성했습니다 (생각보다 열심히 썼다..?)블로그 지표는 아래와 같이 상승했습니다 주로 퍼포스 사용법과 관련한 글들이 강력하게 올라왔습니다 (다들 퍼포스 가이드 글에 목마른걸까 싶네요) 글 노출 수, 클릭 수 모두 늘었는데 내년에도 퍼포스 글과 게임 개발과 관련한 포스트들을 늘려봐야겠습니다 책 리뷰는… 3개 밖에 못썼습니다 읽던 책을 한번 더 읽고 새로운 책은 읽지 못했던 것 같네요 (읽었던 책 다시 읽은 것까지 합해도 뭐 5권정도 되려나 싶습니다) 22년에는 책 리뷰는 읽었던 책 중에서 쓸 이야기가 있다면 작성해봐야겠어요 21년 3월부터 합류한 Dark PM/PO 모임 다른 PM, PO들은 어떻게 살고있는지 귀한 경험을 이야기하는 자리에 함께할 수 있었습니다 릴리스 매니저의 일 + PUBG에서의 일들을 공유하고 있어요 KPT(Keep, Problem, Try)Keep 21년 상반기부터 주간 업무일지를 작성하고 있었는데 어떤 일을 해야할지, 어떤 목표로 한 주를 살 것인지 정하고 일할 수 있어서 좋았습니다. 22년에도 잘 써봐야겠어요 퍼블리(업무일지를 왜 써야 할까요? - 나만의 매뉴얼과 사수 만들기): https://publy.co/content/5696?s=szs2we 21년 블로그 목표했던 포스트 갯수 24개는 채우지 못했지만 꾸준히 공부하고 기록을 남기겠습니다 21년까지의 포스트 수는 72개! 올해는 블로그 총 포스트 갯수가 100개 넘을 수 있도록 해보자! 당연히 수 채우기 위한 포스트보다 공부하고 정리한 것, 필요한 정보가 담긴 포스트들을 작성해야겠습니다 (가치있는 글을 쓰자!) 팀 리드 업무 21년동안 한 일보다는 팀 관리 업무를 더 신경써서 해야겠지만 나름 선방했다고 생각합니다 1:1 미팅도 필요한 것을 같이 이야기하고 팀원들이 재미있게 일할 수 있고 성과를 낼 수 있는 환경으로 만들어나가야겠어요 운전: 더 연습해야한다! 9월 말부터 시작해서 3개월 동안 한 550km 운전했고 매주 주말에 연습 겸 인천도 다녀오고 마트도 가고 계속 연습해야겠어요 🚗 투자: 안전 자산으로는 예적금도 들고 주식으로 투자를 하고 있습니다 예적금 + 투자금 다 포함해서 목표한 금액보다 초과해서 모았네요 💪 https://youtu.be/de2HyXGjCMI 로드맵 영상보고 로드맵을 짜고 저축, 투자 공부도 하면서 이리저리 굴려보았는데 결과가 생각보다 좋아서 뿌듯합니다 22년에도 열심히 굴려(굴러)보겠습니다! (그나저나 삼성은 오를 생각을 안하네요..) Problem 여전히 하던 습관대로 일하고 있네요. 팀 리드임에도 실무에 더 집중하는 경우도 있었습니다 편안하게 일하고 싶은 욕구는 당연하지만 2가지 고민을 계속해야겠습니다 개발 PM으로 앞으로 어떻게 성장해나갈 것인지 더 고민해야한다 팀 리드로 어떤 일을 팀과 함께 해나가야할지 고민해야한다 21년에 정해둔 목표를 보지 않고 살았습니다 개인적으로 하고 싶었던 블로그 포스트나 작은 공부들만 챙기고 그 외에는 들여다보지 못했습니다 업무에서도 회고가 중요한 것이 아닌 회고 이후 액션 아이템을 챙기는 것이 중요하다는 것을 알면서 이러고 있네요 😅 코로나를 핑계로 운동을 소홀히 했습니다 건강이 엄청 나빠진 것은 아니지만 기름진 것을 많이 먹어서 건강검진에서 식이조절, 체중조절하라는 결과를 받았습니다 담낭 수술은 뭐 그전부터 있던 담석 문제였지만 이 역시도 기름진 음식이 문제였던 것 같습니다 Try 팀에 역량이 쌓일 수 있도록 내부 스터디를 더 강화해보자 이슈 케이스 스터디와 업무 로테이션을 해봐야겠어요 코로나 때문에 팀원들과 소통이 적은 것에 대해서는 더 고민이 필요합니다 22년 목표는 4개의 큰 카테고리로 정하고 매월 평가해보기 → 목표를 설정하고 리마인드하는게 중요! (팀 업무) 팀이 같이 설정한 목표에 맞게 업무를 하고 서로의 일을 이해하고 백업가능하도록 해야합니다 (개인 업무) 팀 리드로 조직 목표, 상위 방향성을 잘 전파하고 업무에 녹아들 수 있도록 합니다 (개인 공부) 블로그를 매월 2개 이상 포스팅! (개인 생활) 체중 77kg을 유지 (유산소 + 근력 운동 + 식이조절) 마무리2021년 열심히 살았지만 계획한대로(생각한대로) 살기보다 사는대로 생각이 흘러가지 않았나 싶습니다작년에도 비슷한 고민을 하고 계획을 했지만 제대로 안된 것을 보니 계획만 하고 꾸준히 챙겨보지 않아서 그랬던 것 같기도.. 2022년에는 Keep, Try에 있는 것 신경써서 살아봐야겠습니다 💪💪💪","link":"/blog/2022/01/19/2021-Retrospective/"},{"title":"Atlassian 서비스 Cloud 전환 선언!","text":"소식Atlassian Post:Accelerating our journey to the cloud, together 최근 아틀라시안에서 모든 서비스 타입 중 서버 라이센스를 2021년 2월 부로 판매를 종료하고 클라우드 서비스로 전환하겠다는 것을 발표했습니다.발표된 내용에 따르면 새로운 서버 라이센스는 2021년 2월 2일 부터 구매할 수 없습니다.서버 라이센스 갱신의 경우는 가격이 변경된다고 하네요. 관련 내용은 우선 Jira 기준으로만 한번 보겠습니다. Jira 서버 라이센스 가격 변경점 기존 가격 테이블: https://www.atlassian.com/software/jira/pricing?tab=self-managed 테이블은 따로 없고 하나하나 유저별로 가격을 확인해야하네요. 😂 1 ~ 10명: $10, 11 ~ 25명: $3,500, 26 ~ 50명: $6,800, 51 ~ 100명: $13,300, 101 ~ 250명: $26,400 … 변경 예정 가격 테이블: https://www.atlassian.com/licensing/future-pricing/server-pricing/pricing-tables 변경된 것은 10달러 라이센스가 사라졌네요. 😢 1 ~ 25명 $1,600이 최소 가격 라이센스가 되었습니다. 26 ~ 50명은 $3,000 51 ~ 100명은 $5,500, 101 ~ 250명: $10,900 … 으로 거의 반값으로 떨어졌네요. 참고할 점은 메인터넌스(유지)를 위한 라이센스라서 버그 수정과 관련한 유지보수 비용으로 봐야할 것 같네요. 유지보수 라이센스 갱신이기에 싸졌다고 보기에도 애매하긴 합니다. 이후 3년이 지난 2024년 2월 2일에는 서버 라이센스는 더 유지보수를 하지 않는다고 합니다.(Windows7 업데이트를 중지하는 것 처럼 업데이트가 중지되는 것으로 보시면 될 것 같습니다.) 향후 클라우드로의 전환 계획서버 라이센스를 사용하던 사용자들을 위해 3년의 유지보수를 진행하고 고객들을 위해 클라우드, 데이터 센터 라이센스를 더 낮은 가격으로 업그레이드/마이그레이션 할 수 있도록 할인을 제공한다고 합니다.클라우드로 매끄럽게 전환할 수 있도록 따로 툴이나 페이지들을 준비하고 있는 것 같습니다. 클라우드 마이그레이션 소개: https://www.atlassian.com/migration/cloud/explore 클라우드 마이그레이션 가이드: https://www.atlassian.com/migration/cloud/guide/introduction/overview 위 페이지를 제공하면서 무료 마이그레이션 trial을 고객이 가지고 있는 서버 라이센스의 남은 기간만큼 제공한다고 합니다. (최대 1년) 클라우드로 전환하지 못하는 고객들은? 데이터 센터로서버 라이센스 유지보수 3년의 기간이 있음에도 클라우드로 전환하지 못하는 고객을 위해서는 데이터 센터에서 사용할 수 있도록 환경을 제공한다고 합니다.2021년 2월 2일에 데이터 센터 구독 가격도 업데이트될 예정이라고 하네요. 새로운 라이센스 가격: https://www.atlassian.com/licensing/future-pricing/data-center-pricing/pricing-tables 라이센스가 2021/2/2 전에 생성되었다면, 견적서에 있는 가격은 만료일까지 유지됩니다. 라이센스가 2021/2/2에 또는 이후에 수정되었다면, 새 가격을 반영을 반영하기위해 전체 견적이 다시 계산됩니다. 라이센스가 2021/2/2에 또는 이후에 삭제되었다면, 가격이 복원되지 않고 새 가격(new license)으로 구매해야합니다. 가격 테이블을 보면 서버 -&gt; 데이터센터로 마이그레이션 하려면 미리 라이센스를 사두는게 낫지 않을까 싶긴합니다.근데 2000+ 사용자 라이센스 기준으로 계산해보면… 서버, 유지보수 라이센스: $25,200 2021/2/2 전 데이터 센터 신규(3000명짜리): $79,200 2021/2/2 후 데이터 센터 갱신(3000명짜리): $91,100 2021/2/2 후 데이터 센터 신규(3000명짜리): $165,000 (208% 상승) 어쨌든 라이센스 비용이 엄청 늘어나는 것은 맞네요. 😂 사용자 반응이 소식을 보고 “와, 클라우드를 얼마나 키우려고 하는지는 모르겠지만 아직 클라우드 별로 였던 것 같은데.. 괜찮으려나” 싶었습니다.다른 사람들은 어떻게 생각하는지 궁금해서 커뮤니티 글들을 보았는데요.https://community.atlassian.com/t5/Feedback-Forum-questions/Answering-your-questions-on-changes-to-server-and-Data-Center/qaq-p/1505535 예상대로 불타고 있네요.. 🔥🔥🔥중간중간 중립인 사람도 있지만(거의 안보임) 대부분 반기지 않는 느낌입니다. 다만, 기존에 사용하던 서버 설치 버전을 아예 사용하지 못하는 것은 아니고 기술 지원이나 유지보수가 중단된다는 점에서는 자체 서버를 사용하는 사용자들 입장에서는 어려운 상태네요. 윈도우즈 7과 비슷한 느낌이긴 합니다. 윈도우즈 7도 유지보수 기간이 끝났지만 아직 사용하는 사람은 많으니까요.참고1: 스팀 하드웨어 조사윈도우즈 7 사용자는 현재 전체 스팀 유저의 4.6% 정도라고 하네요.참고2: Netmarketshare.com OS 버전 별 점유율2020년 10월 기준, 윈도우즈 10은 20.41%, **윈도우즈 7은 25.41%**로 스팀 하드웨어 통계보다 더 큰 수치가 나왔네요. OS 버전의 통계처럼 각 라이센스 별로 사용자들이 얼마나 사용하는지를 확인하고 클라우드로 변경한다고 했을 것 같은데 통계가 어땠는지 궁금하네요.(개인적으로는 서버 설치 라이센스 사용자가 많을 것 같다는 생각은 듭니다.) 마치며아틀라시안의 클라우드 전환 선언을 보고 얼른 포스트 써봐야하지 한 것이 벌써 2주가 지났네요.가격이 얼마나 오르는지, 클라우드 기능은 지금 얼마나 차이나는지 등등 보다가 늦었습니다. 😂 개인 태스크 관리로 클라우드 프로젝트를 사용하고 있지만 아직 개선될 점이 많아보이기도 하고 커스터마이즈 할 수 있는 것도 제한적이라는 생각이 들어서 저도 클라우드로의 전환 소식이 마냥 반갑지는 않네요. 다만, 아틀라시안에서 향후 개선 방향이나 여러가지 방법들을 들고 올테니 기대해봐야겠지요.앞으로의 아틀라시안 행보를 지켜봐야할 것 같습니다. (추가) 블로그 포스팅 내용 앞부분을 읽으면서 이런 생각이 들었습니다.‘그래, 설치형이랑 클라우드 둘다 통합해서 개발하는게 개발팀 관리나 프로덕트 관리 측면에서는 더 좋을 것 같기는한데.. 🤔’사용자들에게 어떻게 공유하고 옮겨가게 할 수 있을지는 고민이 많이 들겠다 싶었어요. 긴글 읽어주셔서 감사합니다. 🙇‍♂️","link":"/blog/2020/11/01/Atlassian-Jira-Clound/"},{"title":"Atlassian playbook - 5 whys","text":"Atlassain playbook 번역해보기 #2 오래전에 DACI 번역하고 이제 두번째로 번역, 정리해보는 프레임워크네요. 5 Whys 프레임워크입니다. 원글: https://www.atlassian.com/ko/team-playbook/plays/5-whys 5 Whys Analysis framework5 Whys 프레임워크는 문제의 근본 원인을 찾아냅니다.컨플루언스 템플릿이나 다른 템플릿들은 원글에서 확인하실 수 있습니다. 플레이북 진행1. 준비 Prep문제 설명을 준비하세요. 팀이 현재 직면하고 있는 문제일 수도 있고 해결해야 할 과거에 발생한 문제일 수도 있습니다.원격 팀의 경우 협업 문서(위의 선택적 템플릿 참조)를 만들고 팀과 미리 공유하세요. 대면 팀의 경우 다음 열로 화이트보드에 레이블을 지정합니다. 문제 설명 1 문제 설명 2 문제 설명 3 문제 설명 4 문제 설명 5 어떻게 해결할 수 있는지? 2. 무대 설정회의 시작 시 팀에 다음 사항을 알리세요. 우리는 문제의 근원을 찾기 위해 깊이 파고들 것입니다. 우리는 비난하기 위해 여기 있는 것이 아니라 조사하기 위해 왔습니다. 팁: 5 Whys Analysis Play는 호기심과 실수로부터 배우는 것을 장려하는 문화에서 가장 잘 작동합니다. 이런 종류의 환경은 비난 게임으로 변하는 것을 방지합니다. 3. 브레인스토밍초기 문제 설명의 경우 팀에 “왜 이런 일이 발생했습니까?”라고 질문하세요.타이머를 5분으로 설정합니다. 팀이 공동 작업 문서 또는 화이트보드에 자신의 답변을 추가하도록 합니다. 팁: 다른 방법으로 물어보세요 문제의 원인은 무엇입니까? 무엇이 문제로 이어졌습니까? 문제가 발생한 조건은 무엇입니까? 문제에 기여한 것은 무엇입니까? 4. 선택팀으로서 다음 문제 설명으로 자세히 설명할 답변 중 하나를 선택하세요.초기 문제 설명을 이것으로 바꿉니다. 팁: 투표하기앞으로 나아갈 문제 진술에 투표하세요.Trello Voting Power-Up을 시도하거나 팀이 선택한 진술에 +1을 추가하도록 합니다. 5. 반복총 5번을 “왜?”라고 물을 때까지 3단계와 4단계를 반복합니다. 팁: WHYS팀에서 의미 있는 수준의 근본 원인에 도달했다고 동의할 때까지 “왜”를 계속 물어보세요. 6. 솔루션 제안근본 원인의 지점에 도달하면 팀 구성원이 최종 문제 설명에 대한 솔루션을 제안하게 합니다.진행할 솔루션을 한두 개만 선택하고 각 솔루션에 담당자를 지정하고 팀이 담당자로부터 응답을 받을 수 있는 시점을 결정합니다. 팔로업 Follow ups 모든 메모 캡처 전체 팀이 볼 수 있는 장소에 세션의 메모를 게시합니다. 작업 추적 Jira 또는 Trello와 같은 팀의 작업 보드에 문제 설명을 작업 항목으로 추가합니다. 체크인 합의된 시간에 제안된 솔루션의 진행 상황을 확인하고 있는지 확인하세요. 변형 Variations브레이크아웃 / Breakout첫 번째 브레인스토밍 단계 후, 하나의 문제 진술에 투표하는 대신 그룹이 각 문제 진술에 대해 하나씩 팀으로 나뉩니다.그런 다음 나머지 팀 플레이를 따라 각 팀이 끝나는 근본 원인을 확인하세요. Playbook - 5 Whys 활동 문서 번역을 마치며이번 플레이북 5 Whys는 내용이 어렵지 않기도 하고 본문이 길지도 않아서 금방 번역을 마쳤네요.실제 업무에서도 5 Whys 처럼 단계를 모두 따라서 문제를 정의하는 경우가 있긴하겠지만 대부분 2-3번째 쯤에 문제가 정의되는 것 같긴합니다.정의하기 어려운 문제는 5번 이상 원인에 대해 파악해봐야겠지만요. 😇 이 프레임워크에 대해 알게된 건 박물관 이야기였던 것 같네요. 제퍼슨 기념관(Jefferson memorial) - 대리석 지붕이 빨리 부식되는 원인을 찾자 왜 대리석이 빨리 부식되는가? 세제로 자주 씻고 있음 왜 세제로 자주 씻는가? 비둘기 배설물이 많아 자주 씻음 왜 비둘기가 많은가? 비둘기의 먹이인 거미가 많음 왜 거미가 많은가? 거미의 먹이인 나방이 많음 왜 나방이 많은가? 직원들이 일찍 퇴근하면서 해지기 전 전등을 켜서 나방이 몰려듬 -&gt; 기념관 직원들의 업무시간을 조정하여 해가 진 후 전등을 켬 이 외에 많은 예시가 있겠지만 여러 단계에 걸쳐서 문제 원인을 찾고 해결해나가는 기법입니다.대부분 머리속에서 정리되는 경우가 있지만 큰 문제나 다같이 문제를 풀어야하는 경우에는 이 기법을 사용해보면 좋지 않을까 싶네요. 참고하면 좋을만한 글 Medium PM101, Learn About the Five Whys Technique(EN) 5 Whys 분석법, 근본 원인을 찾는 문제 해결 기법","link":"/blog/2022/08/21/Atlassian-playbook-5whys/"},{"title":"Atlassian playbook - DACI 프레임워크","text":"Atlassain playbook 번역해보기 #1올해 초 부터 해보고 싶었던 Playbook 번역이었는데 조금씩 하다가 이제 정말 해보자하고 진행하고 있네요.이번 글에서는 Atlassian Playbook에 있는 DACI 프레임워크를 소개해보고자 합니다.되도록 글의 번역에 초점을 맞춰보고 추가할 내용은 조금씩 수정, 보완해볼 예정입니다. 원글: https://www.atlassian.com/team-playbook/plays/daci30초 설명: https://youtu.be/68iWkZQ2Zdg DACI (Driver, Approver, Contributors, Informed) frameworkDACI 프레임워크는 그룹 결정을 효율적이고 효과적으로 내릴 수 있도록 도와줍니다. 이 플레이북 활동을 사용하면? 이 DACI 프레임워크 활동을 사용하여, 영향력이 높거나 위험이 높은 그룹 결정을 내리기 위한 역할을 정의합니다. 의사 결정, 균형 잡힌 팀 또는 건강 모니터(Health Monitor)에 대한 공유 이해에 어려움을 겪고 있는 경우 이 플레이를 실행하는 것이 도움이 될 수 있습니다. 의사 결정: 단기적 및 장기적 영향 모두를 고려할 때 적절한 수준의 긴급성과 논의를 통해 적절한 수준에서 의사결정이 이루어지며, 이에 대한 절충이 적극적으로 고려됩니다. 의사결정은 시기적절하고 효과적으로 전달됩니다. 균형 잡힌 팀: 역할과 책임은 명확하고 합의된 것입니다. 이 프로젝트에는 적절한 기술 조합의 사람들이 있습니다. 팀 구성원은 단계(stage)별로 변경할 수 있습니다. 공유된 이해: 비즈니스와 사용자의 관점에서 성공이 무엇을 의미하는지 분명하고, 타겟 사용자와 비즈니스에 대한 고유한 가치 제안이 있습니다. 성공은 목표와 함께 정의되며, 성공이 어떻게 측정될 것인지에 따라 결정됩니다. DACI가 왜 필요한가요? (상황 예시) 당신이 좋아하는 샌드위치 가게의 카운터에 서서 루벤(Reuben)을 먹을 것 인지 칠면조를 먹을 것 인지에 대한 질문으로 고통받는 자신을 발견했다면, 이 보편적인 진실을 알고있을 것입니다. 결정은 어렵습니다. 직장에서의 결정은 훨씬 더 어렵습니다. 그런 다음 팀원, 이해 관계자, 고객 및 상사의 의견을 방정식에 추가합니다… 으으 😰 프로젝트에 대한 의사결정에 긴급하게 접근하지 않으면 아무도 결정을 내리지 못하기 때문에 지연됩니다.그리고 우리가 누구의 결정이냐에 동의하지 않으면, 우리는 결국 결정을 반복해서 재검토하게 되고, 이것은 우리의 발전을 더욱 지연시킵니다. 각 의사 결정에서 누가 어떤 역할을 하는지 명확히 함으로써, 올바른 결정을 내리고 적절한 시기에 결정을 내릴 수 있는 더 나은 기회를 얻을 수 있습니다.(항상 루벤을 선택하는 것이 옳은 것 처럼요.) 이건 작성자 개인의 취향인듯 합니다. 😂루벤 샌드위치를 비유할만한 한국 음식은 떠오르지 않는군요. 😄 누가 참여해야하나요?결정 및 진행을 위해 그룹 전체 인원이 참여합니다. 플레이북 활동 진행DACI는 그룹 의사결정에 구조를 가져오는 것에 관한 것입니다.그러니 먼저 이 활동을 자세히 복습하여 그 구조를 확실히 이해하시길 바랍니다. 인원 수 준비 시간 시간 난이도 4-8 15분 다양 중간(Moderate) 준비물 컴퓨터(노트북) Confluence 용 DACI 프레임워크 템플릿 DACI 프레임워크 템플릿 PDF (EN) 활동 시작 전에 먼저“DACI”는 무엇을 의미하나요? 용어 설명 Driver(운전자) 이해 관계자를 모으고 필요한 모든 정보를 수집하고 합의된 날짜까지 결정을 내릴 책임이 있는 한 사람입니다. 결정에 따라 프로젝트의 풀타임 작업자일 수도 있고 아닐 수도 있습니다. Approver(승인자) 결정을 내리는 한 사람입니다. Contributors(기여자) 그들은 결정에 영향을 줄 수 있는 지식이나 전문 지식을 가지고 있습니다. 즉, 목소리는 있지만 투표권은 없습니다. Informed(정보 수신자) 최종 결정에 대한 정보를 받습니다. DACI는 비록 그들이 동의하지 않더라도, 그룹의 모든 사람들이 일단 결정이 내려지면 결정 뒤에 집회를 열 때만 작동합니다.우려와 신뢰를 기꺼이 공유하지 않으면, 여러분의 팀은 끝없는 토론과 무반응의 늪에 빠질 것입니다.팀원들은 심지어 공식적인 결정이 실패하기를 바라면서 몰래 선호하는 선택지를 추구할 수도 있습니다.여러분이 헛소리 정치는 건너뛸 수 있도록 모든 사람들이 결정된 모든 일에 완전히 전념할 준비가 되어 있는지 확인하세요. DACI가 필요한가요? 그것은 우리가 자주 하는 질문입니다. 그룹 의사결정에 전체 DACI 치료가 필요한지 여부를 고려할 때 적절한 시기와 영향을 고려해야 합니다.프로젝트에서 여러 사람의 작업에 영향을 미치는 의사 결정(예: “내년에는 어디에서 사용자 회의를 개최해야 합니까?”)에는 DACI가 필요할 수 있습니다.소규모의 고립된 결정(예: “회의의 소셜 미디어 해시태그는 어떻게 될 것인가?”)은 그렇지 않습니다. Step 1, 결정을 추적할 페이지를 만듭니다. (5분) 대부분의 프로젝트는 검토 중인 사항, 관련 연구, 트레이드오프, 권장 사항 등을 문서화함으로써 이득을 얻습니다.이를 통해 핵심 팀은 보다 쉽게 옵션에 대한 피드백을 제공하고 이해 관계자가 최종 결정을 이해할 수 있도록 지원합니다. 컨플루언스(또는 문서화 도구 선택)에서 새 페이지를 열고 맨 위에 2x4 그리드를 삽입하거나 DACI Blueprint for Confluence를 사용하여 페이지를 만듭니다.왼쪽 열의 행에 드라이버, 승인자, 기여자, 알림으로 레이블을 지정합니다. 결정을 진행하는 동안 며칠/주 내에 이 페이지에 더 많은 정보를 추가할 수 있습니다. 컨플루언스 사용자가 아닌가요? 걱정하지 마세요.대신 DACI 템플릿 PDF을 다운로드하여 사용할 수 있습니다. Step 2, 그룹 결정을 위한 역할을 정의합니다. (10분)운전자(Driver)는 누구입니까? 각 결정마다 한 사람씩 있는 것이 좋습니다. 이 사람들은 반드시 전체 프로젝트를 주도하지는 않습니다. 그 결정에만 있으면 됩니다. 승인자(Approver)는 누구입니까? 다시 한 번 말하지만, 한 결정당 한 명만 있어야합니다. 기여자(Contributors)는 누구입니까? 이 사람들은 결정당 여러 사람이 될 수 있으며, 심지어 핵심 팀 외부의 사람을 포함할 수도 있습니다. 관련 지식이나 경험이 있는 사람은 누구나 공정한 게임입니다. 정보 수신자(Informed)는 누구입니까? 이 사람들은 그 결정의 직접적인 영향을 받는 모든 사람들입니다. 여기에는 핵심 팀 외부의 사람들이 포함될 수 있습니다. “운전자가 부재중이라면 누구에게 위임하겠습니까?”, “상담을 받아야 할 사람이 너무 많습니까?”와 같은 질문을 던집니다. 이에 따라 DACI를 조정합니다. Step 3, 공격 계획을 세우세요. (15 min) 결정을 내리기 위해 수집해야 할 모든 정보를 생각해 보세요.Confluence에 DACI Blueprint를 사용하지 않는 경우 페이지에서 다음 섹션을 표시합니다.지금 바로 작성하실 필요는 없지만, 각 메모에 내용을 추가하셔도 됩니다. 항목 설명 마감일 결정 기한 결정 배경 결정이 필요한 이유 현재 상태 지금 결정 단계상 있는 곳 정보 지원 당신의 결정을 알리기 위해 당신이 조사한 것 고려된 옵션들 장단점, 리스크, 트레이드오프, 예상 비용 또는 노력 등을 요약할 수 있는 각 옵션에 대한 열이 있는 표 추천 사항/제안 기여자들의 의견 FAQs 자주 묻는 질문(또는 예상 질문)에 답변할 수 있는 곳 참조 참조 자료로 연결되는 링크 목록과 관련 이유를 간략히 설명 조치 목록 결정과 관련된 작업 또는 후속 조치 목록 결정 결과 최종적으로 어떤 옵션을 선택하는지 설명하는 곳 Step 4, 팀을 참여시키기 피드백과 입력을 요청하는 페이지를 팀으로 보냅니다.페이지의 특정 섹션을 작성하는 데 도움이 되는 특정 사용자가 필요한 경우, 지금이 바로 알려야 할 때입니다. 만약 어떤 시점에서 상황이 정체되거나 빙빙 돌고 있다고 느낀다면, 운전자와 기여자들을 방에 함께 모으세요. 결정에 가까워질 경우, 승인자를 포함시키는 것도 도움이 될 수 있습니다. 사람들이 자신의 우려 사항, 추천 사항, 고려해야 할 다른 옵션에 대한 아이디어 등을 표현할 수 있도록 합니다. 한 시간 동안 직접 해싱하면(합의에 도달하기 위해 다른 사람들과 이야기를 나누면) 며칠간의 의견(또는 - 공포! - 이메일) 스레드를 절약할 수 있으며, 결정을 다시 정상으로 되돌릴 수 있습니다. …그럼 심호흡을 하세요! DACI 활동은 특히 결정이 논쟁적이거나 정치적 책임을 지는 경우 스트레스가 될 수 있습니다. 여러분은 함께 일할 수 있는 명확한 그룹 의사 결정 프레임워크를 구축하는 것에 시간을 할애하여 팀원들에게 훌륭한 서비스를 제공했습니다. 다른 사례 - 서비스 팀 데스크톱 지원 또는 채용과 같은 서비스를 제공하는 맥락에서, 일련의 DACI는 일선 서비스 팀 구성원들이 독립적으로 어떤 통화를 할 수 있는지, 팀원이나 관리자가 언제 참여해야 하는지 이해할 수 있도록 도와줍니다. 위에서 설명한 전체 결정 페이지가 매트릭스의 각 결정에 필요하지 않습니다. 각 시나리오에 대한 간단한 설명과 D, A, C 및 I로 충분합니다. 서비스 별로(프로젝트 별로) DACI 매트릭스를 만듭니다. 이러한 독립적 의사 결정이 이루어진 후 정보를 전달하기 위한 일련의 에스컬레이션 경로 및 절차로 제공될 수 있다고 생각하시면 됩니다. 서비스 팀의 DACI 매트릭스는 비교적 정적인 편이지만, 돌에 새겨진 것은 아닙니다. 확립되어있고 안정적인 서비스에 대해 DACI를 매년 검토하고 수정하세요. 신규 서비스 팀의 경우 DACI를 분기별 또는 1년 동안 2회 검토하기를 권장합니다. 다음 조치(Follow-ups) - 의사결정 기록 선택 사항입니다. 여러 그룹 또는 부서에 영향을 미치는 대규모 이니셔티브(리더십 팀, 리더십 팀)는 종종 의사결정 기록 페이지에서 이점을 얻습니다. 의사결정 기록 페이지는 팀 구성원과 이해관계자가 각 결정에 대한 세부 정보에 쉽게 액세스할 수 있는 포털 역할을 합니다. 의사결정 기록에 프로젝트에 대한 간략한 요약(예: 엘리베이터 피치(EN))을 포함합니다. 그 아래, 각 결정을 자세히 설명하는 페이지로 연결합니다. 또한 각 결정의 상태, 영향 수준, 운전자, 승인자 및 만료 날짜를 기록합니다. 또한 중요한 용어를 정의하는 범례도 포함할 수 있습니다. 예를 들어, 의사결정에 “높은 영향”이라는 레이블이 지정된 경우 정확히 무엇을 의미하는지 알 수 있습니다. 연관된 활동 프로젝트 킥오프(Kick-off) 역할과 책임 트레이드 오프 슬라이더 Playbook - DACI 활동 문서 번역을 마치며맨 처음에 DACI라는 내용을 들었을 때, 무슨 프로세스지? 방법론인가? 하고 막연히 생각했습니다.(프레임워크라고 해서 SWOT(강점, 약점, 기회, 위협) 같은 것으로 생각했었죠.)다른 PM 분들이 소개해주시는 내용이나 요즘 PM과 관련한 글들을 많이 보면서 어렴풋이 알게되었고 Atlassian에 관련 자료가 있어서 마침 공부하는 겸 번역하게되었습니다. 제가 일하고 있는 곳에서 일어나는 일을 DACI에 대입해보면.. 프로젝트(작은 피쳐 또는 스펙)를 진행할 때에 PM이 보통 운전자(드라이버)로 진행을 하고PD, 리더분들이 승인자 역할 그리고 사업 부서와 운영 부서는 기여자와 정보 수신자가 될 수 있겠네요. 사실 번역하면서 어느정도 이해는 했고 실제 업무에 알맞게 써먹을 수 있을지가 관건이겠죠.나중에 이런 프레임워크가 있으니 한번 써볼까하는 생각은 들 수 있겠습니다. (언젠가 🙈)이 글을 읽으신 분들에게 조금이나마 도움이 되었기를 바라며 마칩니다. 고맙습니다. 참고하면 좋을만한 글 브런치: DACI 팀 결정을 효율적으로 하는 방법 ProductPlan: DACI Decision-Making Framework(원문) Medium PM101, DACI Framework: a Tool For Group Decisions(EN)","link":"/blog/2020/10/25/Atlassian-playbook-DACI/"},{"title":"2023 회고","text":"22년 회고를 되돌아보면 PM 리드(PMO 리드)의 옷을 어느정도 어색하지 않게 입을 수 있게되었다. 무려 팀장 시작한지 2년 만에.. 😇 22년 팀장의 일에 대해 나름 고민하고 시도해본 것 같다. 23년에도 치열하게 고민해보자 그 동안에도 팀장은 팀을 돕는 사람으로 포지션을 잡았는데 왜, 어떤 것을 돕고자 하는지 설명하고 서포트해야겠다는 생각을 해본다 지금 살펴보면 22년에 연초에 크게 HP, MP 모두 1% 남은 상태였고 회복하는데 전념했다 삶에 있어서는 어려움을 극복하는 법, 살아가는 것에 대해 고민을 했던 것 같고,일에 있어서는 팀이란 무엇인지, 팀장은 어떤 일을 해야하는지 고민을 했다 23년 개선해보고 싶었던 것을 개선했을까?요약해보자 👍💪 팀장 교육을 통해 고민해야하는 포인트들을 상세하게 알 수 있었다! 👍 팀 리더십 책을 보고 적용해보려 노력했다. 팀장 바쁘지 마라, 실리콘 밸리식 팀장의 탄생, 처음 리더가 된 당신에게 하이 아웃풋 매니지먼트 → 이 책은 12월까지 완독! 적용해보았던 것: 팀원 다면 평가를 위해 협업했던 분들에게 피드백 요청 아쉬웠던 점: 고민 → 액션까지 빠르게 하지 못했음. 앞으로 작은 실행, 결과까지 많이 해봐야겠다 사실 22년에 회고 이후 딱 개선해야겠다! 싶었던 것은 크게 있지 않았던 듯. 현재로도 충분하다는 생각을 많이했는데 하나만 생각해본다면 팀 리드로 기여하려면 어떤 일을 더해야할까를 고민하고 실행해보자 정도였다.그런 의미로 생각해보면.. 팀장 교육에서 배운 것이 여러가지로 도움이 되었다고 생각한다. 팀장 교육에서 첫 내용으로 리더 자신 파악하기에 대한 내용이 있었는데 RGPI(Rohen Grow Potential Inventory) 검사 결과나 리더십 스타일에 따른 상세 가이드가 있어 좋았다 RGPI에 있던 나의 리더 속성 일상생활에서 가장 중요하게 여기는 가치는 “조화로운”삶입니다.이와 더불어 “이타적인” 삶을 추구합니다.반면, “재미있는”삶에 대해서는 상대적으로 관심이 적습니다. “다양한 가치들을 존중하며 조화롭게 사는 것“을 중요하게 생각합니다.자신을 보호하기 위해 “작은 일에 예민하게 반응하고 화를 표출하는 스타일“입니다. 리더 자기 인식 과정이 처음 필수 과정이었는데 나의 리더십 타입을 알 수 있어서 좋았다 이후 동기부여 커뮤니케이션, 효과적인 업무관리 2개를 다 들었는데 이것도 좋았다 이후 리마인드 콘텐츠로 공유한 내용도 복습 차원에서 좋았음 다만 개발 업무 중에 볼 시간이 없었다는 것이 아쉬운 점.. 리더는 리딩을 위해 시간 내서 공부해야하겠다 싶었음 이 과정에서 나는 동기 부여하고 업무 부여에 강점이 있지만 중간에 목표를 확인하고 성과를 올리기 위한 액션(목표 관리)에는 약하다는 것을 알게됨(전에도 어렴풋이 알고 있었지만 확실하게 알게되었다) 올해 주로 어떤 고민을 했나 올해도 역시나 팀 리드가 어떤 일에 집중해야하는가에 고민이 많았다 지금까지의 결론은 팀이 해야하는 일을 잘할 수 있도록 정의하고 지원한다 팀장 개인으로는 스페셜한 능력도 갖추긴해야한다 공부한 것 블로그 포스트에 해보려했지만 11개 정도 밖에 못했다. (22년에도 12개 였지만..) 공부가 부족했다기보다 뭔가 팀 리드 업무에 고민이 많아지면서 포스트할 내용이 좀 줄어든 느낌..? PM이 알아야하거나 고민해야하는 것들을 주로 포스트하면 좋았을텐데 하는 아쉬움 그래서 주로 퍼포스(Perforce) 사용법이나 팁을 포스트하게된 것 같은데 사내에서 뭔가 퍼포스 블로거가 된 느낌이 있다 ㅋㅋㅋ 블로그는 올해 26.8% 유저가 늘어 1.9만명. 광고 수익은 25달러를 벌어서 지금 속도라면 내년에 100$ 도달해서 정산받을 수 있을지도 모르겠다 😃 건강은 챙겨보려고 노력했지만 체중 관리는 뭔가 잘 안되는 느낌. 목표를 설정해야하나 싶다 잘한 점, 아쉬운 점잘한 점과 아쉬운 점(개선하고 싶은 점) 하나씩만 꼽자면, 잘한 점: 팀장으로 초급에서 중급 초입으로 넘어왔던 것 같다. 앞으로도 고민 많이하고 실행해보자 아쉬운 점: 팀장의 일 뿐만 아니라 개인의 강점도 잘 발전시켜보자. 목표 설정이나 목표 관리를 개인적으로도 못하는데 연습하고 습관화해보자 23년 나에게 한마디23년 한 해는 가족과 행복하고 건강하게 보낼 수 있어서 다행이라고 생각한다. 일에 있어서의 나도 중요하지만 일상이 평화로운 것이 삶에 있어서 중요한 것을 22년에 깨닳았기에 24년에도 평화롭게 살아보자. 🙏","link":"/blog/2024/01/21/2023-Retrospective/"},{"title":"Atlassian playbook","text":"Atlassain 플레이북(playbook)? https://www.atlassian.com/team-playbook아틀라시안에서 일에서의 조율, 팀 활동 등 업무에서 사용할 수 있는 프레임워크의 활동 양식을 모아둔 말그대로 활동서같은 곳입니다. 어떤 활동이 있을까?https://www.atlassian.com/team-playbook/plays 활동 중에 사람들이 가장 많이 본 활동은 홈페이지에도 있지만 다음과 같네요. 활동 설명 Retrospective 회고, 어떤 일에 대해 잘한점, 개선할 점을 이야기, 개선하는 활동 Roles &amp; Responsibilities R&amp;R 설정, 책임과 권한을 설정하는 활동 Health Monitor 헬스 체크, 팀의 헬스를 확인하는 활동 DACI Decision-making Framework DACI 결정 프레임워크, 결정이 효율적으로 이뤄질 수 있도록 하는 프레임워크 소개 및 활용 방법 소개 Icebreaker Activities 아이스브레이커 활동, 어색함을 깨거나 협동을 잘할 수 있도록 분위기를 만드는 활동 Stand-ups 스탠드업 미팅을 어떻게 진행해야할지 알 수 있는 활동 Objectives and Key Results (OKRs) OKR 설정 활동 Project Kick-off 프로젝트 킥오프 방법에 대한 활동 Sparring 스파링, 구조화된 방법으로 동료에게 피드백을 받을 수 있는 활동 이 외에도 전체 활동 수는 46개가 있네요.애자일 팀 되는 방법, 리모트 팀워크 올리기, 강한 관계 생성 등 여러 카테고리에 맞춰 활동들이 있으니 하나하나 보면서 참고해보면 좋을 것 같습니다. 플레이북 아쉬운 점브런치나 미디엄에서 아름아름 찾아보는 인사이트들을 아틀라시안에서 정리해주어서 좋지만.. 한글 언어 선택해도 이 플레이북은 번역이 되지 않아서 약간 아쉽긴합니다. 😂많은 분들이 보고 일에 적용해보고 Confluence, Jira를 사용할 수 있을 것 같은데 아무래도 한국어 지원이 안되면 접근성이 떨어지는 것은 사실이어서요. 번역을 더 멋지게 해주시는 분이 있겠지만 저라도 블로그에 번역한 내용을 올려보고 공부하면서 업무에 활용해보려 합니다. 😀그러면서 업무에 적용했던 실제 사례도 올려보면 재미있을 것 같기도 하네요. 국문 번역이 하루 빨리 필요한지는 모르겠지만.. 아틀라시안에서도 조금이나마 신경써서 국문으로 번역된 컨텐츠를 제공해주었으면 하는 바람이 있습니다.이만 짧은 소개를 마치겠습니다. 포스트를 읽어주신 분들도 한번 플레이북 활동을 사용해보시고 업무에 도움이 되면 좋겠습니다.","link":"/blog/2020/11/21/Atlassian-playbook/"},{"title":"Book review: 테크니컬 리더(BTL, Becoming a Technical Leader)","text":"테크니컬 리더 책 소개 테크니컬 리더 Becoming a Technical Leader 원서는 1986년에 나왔고 2013년에 번역되어 국문으로 볼 수 있게되었습니다.혁신, 동기부여, 조직화를 통한 문제 해결 리더십 라는 제목으로 소개되어있습니다. 짧은 소개이 책에서는 앞서 짧게 소개했던 3가지(동기부여(M), 조직화(O), 혁신(I))를 통해 문제 해결 리더십에 집중합니다.문제 해결형 리더십을 정의하고 MOI 모델을 만들어보면서 어떻게 문제를 해결해나갈지 각 장 마지막에 질문을 통해 고민해봅니다. 책 뒤에 있는 추천사에 김창준님이 적어주신 내용이 꼭 맞는 것 같습니다. 이 책은 읽는 책이 아니고 경험하는 책이다. 매 장 끝에 나오는 질문들 하나하나를 귀중히 여겨 고민해보고 직접 종이에 답을 쓰고, 믿을 만한 사람들과 그 답을 공유하고 토론하고, 또 해보라는 실험은 모조리 해보도록 노력하라.그렇게 한다면 아마 여러분들은 나와는 매우 다른, 그러나 매우 유사한 어떤 경험을 하게 될 것이고, 이 책에게 그리고 와인버그에게 매우 고마워하게 될 것이다. - 김창준, 애자일 컨설팅 대표 물론 저는 PM으로 테크니컬 리더는 어떤 사람일까, 어떤 사람이고 싶은걸까 하고 궁금증에 읽어보아서 질문 항목을 성실히 답변해보지는 못했습니다.다만, 질문 내용을 보았을 때 테크니컬 리더 뿐만 아니라 리더라면 고민해봐야할 내용이 많았어요. 책을 읽으면서 공부하고 이해한 내용을 중심으로 리뷰해보겠습니다. MOI 모델?맨 처음에는 MOI가 뭐야 했는데 사실 책 소개 앞에 이야기했던 혁신, 동기부여, 조직화였습니다 😂하나하나 살펴보면 다음과 같네요. 동기부여(Motivation): 위협하거나 보상하거나, 밀거나 당겨서 관련 있는 사람을 움직이도록 만드는 일 조직화(Organization): 아이디어 실현이 가능하도록 만드는 구조 아이디어(Ideas) 또는 혁신(Innovation): 씨앗, 실현될 것의 이미지 책에서는 이 3가지에 집중해서 성공적인 테크니컬 리더로 나아가야하는 방향을 설명합니다.각 2부(혁신), 3부(동기부여), 4부(조직화)에서 상세 내용을 다루고 각 장에서는 질문을 통해 내용들을 같이 고민해볼 수 있었습니다. 22장 변화 계획다른 장들도 읽고 질문에 답을 해보는 것이 좋았지만 저는 22장이 기억에 남아서 따로 남겨봅니다.(실제로 업무를 하면서 고민했던 점도 있었어요 ⭐️) 이 장에서는 혁신과 관련하여 변화에 대해 이야기합니다.변화를 어떻게 이끌어나갈 것인가, 새로운 것에 대해 거부하는 자연스러운 현상을 어떻게 계획해서 극복할 수 있을까 등을 고민해봅니다.책에 있는 방법을 살짝 공유해보면 다음과 같습니다. 개인적 달성 목표를 세운다. 목표는 안전하고 새로운 것이며 스스로 해낼 수 있어야한다. 도달한 성과 수준을 곧바로 알 수 있어야 한다. 첫날에는 성과의 기준선을 정한다. 그 다음 적어도 하루에 한번 연습하고 매일 일기에 진행 상태를 기록한다. 마지막 날에는 성과를 보여줄 수 있도록 준비하고 달성을 위해 노력하면서 무슨 일이 일어났는지 이야기한다. 달성 목표, 계획을 세우는 것 자체가 어떤 것을 이루려는 방법을 배우는 것이라고 생각합니다.어떤 변화를 위해서라면 변화하고자 하는 목표와 계획을 세우고 진행해야한다는 것을 알 수 있었습니다.(어찌보면 되게 당연한 말인데도 정리해본적은 없다보니 새로운 것을 배운 느낌이긴하네요. 😂) 22장의 질문은 작은 기술을 매일 연습하고 기록하는 것, 지금까지 어떤 교육 과정에 참여하고 무엇을 배웠는지 등을 생각해보는 것이 있었습니다.과거에 어떤 교육을 받았고 향후에는 어떤 교육을 받을 것인지도 질문에 있어서 계획을 세우고 공부해라 정도로 질문을 이해하긴했습니다. 이 챕터를 읽으면서 개인적인 달성 목표 매일 업무 일지(업무 회고)를 작성하는 것을 하고 있는데요.사실 매일 일기쓰기 같은 느낌이어서 종종 피곤하면 빼먹고 몰아쓰기도 하고 있습니다.마지막 날(매월 말일)에는 월말 회고를 계획하고 있는데 최대한 빼먹지 않고 열심히 써보려하고 있어요. 💪 테크니컬 리더: 테크니컬 리더를 위한 책책 자체가 두껍긴 한데 테크니컬 리더가 어떤 고민을 하면서 살아가야하는지를 알려주는 책이라고 생각합니다.질문 내용을 모두 고민하고 살기는 어렵겠지만 하나하나 실천해보면 좋은 리더로 나아갈 수 있지 않을까 싶었어요. 전에 리뷰를 작성했던 Book review: 개발 7년차, 매니저 1일차 이 책보다는 어렵다는 생각은 했습니다.테크니컬 리더는 뭘해야하지? 어떤 고민을 하면서 살아야하지? 하는 고민을 크게 하시는 분들이라면 집중해서 읽어보기 좋을 것 같고,리더가 된지 얼마 되지 않았다면 개발 7년차, 매니저 1일차를 입문서로 읽어보시는 것을 추천합니다. 👍 책 내용은 많았지만 제가 느꼈던 내용을 중심으로 짧게 책 리뷰를 해보았습니다.저는 몇 가지 책갈피해둔 질문들을 리더로 일을 하면서 한번씩 되돌아보려고 합니다.(테크니컬 리더가 아니더라도 일반적인 리더가 고민하면 좋은 것이 많아서요. 😈)","link":"/blog/2021/04/06/Book-review-BTL/"},{"title":"Book review: 개발 7년차, 매니저 1일차","text":"개발 7년차, 매니저 1일차 책소개 yes24-개발 7년차, 매니저 1일차 Oreilly-The Manager’s Path 추천책 뒤에는 아래와 같은 사람들에게 추천한다고 되어있습니다. 개발자 VS 매니저 갈림길에 서있는 사람 개발자 관리를 체계적, 효율적으로 하고 싶은 사람 내 사수가 사수 역할을 못해서 내가 고생 중인 사람 정말 개발(여기서는 엔지니어링)을 해왔던 사람이 어느 날 팀을 맡았다면 어떤 것 부터 해야할지, 어떤 것을 고민하고 팀을 운영, 매니징해야하는지 하나하나 잘 설명해주었습니다.어떤분들에게 어떤 내용들이 도움이 될지 간단하게 추천해보고자 합니다. (사실 서평처럼 써보려고 했으나 가볍게 추천한다고 보시면 될 것 같습니다. 😸 ) 참고: 여기서 매니저는 “프로젝트 매니저”할 때의 매니저 보다는 팀장, 실장 등 엔지니어링 팀을 관리하는 매니저로 보시면될 것 같습니다. 주니어 엔지니어, 엔지니어링팀 팀원들을 위한 추천 장(챕터)책에 있는 챕터 별로 매니저가 하는 일, 해야하는 일을 설명하고 있는데요.그 중에서 주니어, 팀원들이 읽으면 좋을 만한 이야기들이 있는 장은 초반에 있는 장입니다. (+ 9 문화 개선 챕터) IT 관리 101 멘토링 테크리드 사람관리 문화 개선 위 챕터들에서는 처음 매니저 업무를 시작하거나 어떤 커리어 패스를 고민해야하는지를 설명합니다.1~4의 챕터들에서 많이 나오는 항목은 원온원(1 on 1) 미팅입니다. 원온원(1-on-1) 미팅원온원 미팅은 팀장-팀원이 1:1로 업무, 개인 이슈 등 여러가지 이야기를 하고 피드백을 하는 미팅으로 이해해주시면될 것 같습니다.이 원온원 미팅은 매니저가 주도적으로 할 수도 있지만 팀원도 같이 참여해서 어떤 이야기들을 할지 고민하고 참여해야한다는 점에서 주니어 엔지니어도 알아두면 좋을 내용이라고 생각했습니다. 주니어 엔지니어, 팀원들은 프로젝트 업무 외에도 커리어와 개인적인 일들을 매니저와 이야기할 수 있는 자리가 있어야합니다. 팀으로 같이 잘 일하기 위해서는 서로 공유해야하는 미팅이 필요하지요.팀장, 팀원은 팀으로 일하기 위해 서로에게 신뢰를 쌓아야한다고 생각합니다. 잡담이나 티타임 정도로도 신뢰가 쌓일 수 있겠지만 팀으로 일하는데에 업무 신뢰도가 쌓이려면 조금 더 업무와 관련한 이야기를 집중해서 할 수 있는 자리가 필요하다고 생각합니다.이러한 역할을 원온원 미팅이 할 수 있을 것으로 책에서 이야기하고 있습니다. 물론 어떻게 미팅을 진행하냐에 따라 신뢰를 잃을 수도 있겠지만요 😂 책에서는 원온원 미팅 처음을 어떻게 시작하면 좋은지, 어떻게 진행해나가면 좋을지를 짚어주어서 좋았습니다.제가 완전히 주니어일 때 이 책을 보았다면 이런 것도 있군! 하고 팀장님에게 이야기하고 해봤으면 좋겠다고 이야기했을 것 같네요. 지금은 프로젝트 매니저로 일하고 있기에 어떻게하면 팀이 일을 잘 만들고 진행할 수 있을지를 더 많이 고민하고 있습니다. 😀 시니어 엔지니어, 팀장이 될 예정이거나 팀장인 엔지니어사실 팀장이 될 예정인 혹은 팀장이 되었지만 어떻게 해야 할지 혼란스러운 엔지니어분들에게는 꼭 읽어보고 이런 방법도 있구나 하고 하나둘씩 적용해보았으면 좋겠습니다.주니어 엔지니어에게 추천했던 챕터를 먼저 읽어보고 그 뒤로는 매니저 커리어 패스를 잡을 때 참고하면 좋을 것 같다는 생각을 했습니다. 추천하고 싶은 내용 중에서는 3장 테크 리드, 4장 사람관리를 추천하고 싶습니다. 엔지니어링 팀장을 맡으면서 태스크 관리나 팀원 관리에 대한 이야기가 튜토리얼로 해볼 만한 것들이 많았습니다.예를 들면, 테크 리드의 기본 역할(주요 역할), 팀원과 관계 맺기 (신뢰 관계 구축하기) 등 매니저가 되면 어떤 것들을 신경 써야 하는지를 알 수 있는 내용들이 Getting Started와 같은 내용이라고 생각합니다. 여기서 원온원 미팅 스타일도 나열해주었는데 살펴보면 아래와 같습니다. 할 일 목록 점검 미팅: 업무 목표를 정리하여 논의하고 우선순위에 따라 각 업무 목표를 다룸. 팀원의 이야기 듣기: 팀원의 이야기를 듣는다. 다만 위로하고 불평을 듣기만 하는 자리라면 무의미해지는 것을 조심해야 함. 피드백 미팅: 비공식적인 피드백, 코칭 시간으로 활용. 개인 목표나 회사 내 목표 등 진행 사항을 같이 검토할 수도 있음. 진행보고 미팅: 프로젝트 세부 사항을 논의하는 시간이 될 수 있음. 프로젝트와 무관한 내용을 이야기하는 방법도 같이 해볼 수 있겠으나 상황에 따라 미팅 빈도를 줄이는 것도 고려해야 함. 인간적인 관계 강화 미팅: 팀원의 사생활 캐묻기가 아닌 팀원 개인에게 인간적인 관심을 갖고 이야기하는 것. 미래 목표를 묻는 것도 괜찮음. 다양한 방식으로 시도하기: 산책이나 커피, 점심을 먹으며 미팅을 할 수도 있음. 다만 민감한 주제를 이야기할 수 있도록 방음이 잘되는 회의실에서 하는 것도 고려해야 함. 여기서 마지막 조언으로 공유 문서에 미팅 노트를 작성해서 팀원들과 공유하는 것을 짚어주었습니다.어떤 피드백을 받았는지 서로 알 수 있고 기억할 수 있는 점과 나중에 성과 평가할 때나 다른 피드백을 줄 때 기억하기 쉬운 점에서 조언을 주었습니다. 이후에는 좋은 매니저, 나쁜 매니저를 이야기하는데 이 부분도 추천하고 싶네요. “좋은 매니저, 나쁜 매니저: 마이크로 매니저, 위임하는 매니저”를 제목으로 썼는데 정말 위임을 어떻게 해야 할까에 대한 내용은 “효율적으로 위임하기 위한 실질적인 조언”에서 볼 수 있었으니 참고하시면 좋을 것 같습니다.맛보기로 부제들의 내용을 나열해보겠습니다. 어떻게 보면 누구나 말할 수 있는 내용일 수 있겠지만 초보 매니저로서 겪는 문제를 해결하는 데에 좋은 표지판이 될 수 있다고 생각합니다. 팀의 목표를 통해 어떤 세부 사항을 파악해야 하는지를 판단하라 팀원을 만나기 전에 시스템에서 정보를 수집하라 프로젝트 단계에 따라 확인할 부분을 달리하라 코드 및 시스템 표준을 설정하라 좋은 정보든 나쁜 정보든 중립적 태도로 정보를 개방하기 이후의 챕터들도 모두 참고할 만한 내용이 많으니 읽어보시면 좋을 것 같습니다. 마치며처음으로 책을 읽고서 추천해봅니다. 사실 자기 계발서에 가까운 책이긴 합니다.자기 계발서를 꺼려하시는 분들에게 말씀드리고 싶은 점은 매니저 튜토리얼 책으로 봐주시면 어떨까 합니다.매니지먼트 책 중에서 엔지니어가 빠르게 읽고 적용해볼 수 있는 책이라고 생각합니다. 매니저로 일을 시작하면서 겪는 것이 엔지니어링 하면서 겪는 것보다 사람 관리, 팀 관리가 더 어려운 것 같습니다. 컴퓨터에 대한 문제는 구글링이나 스택오버플로우에 검색해보면 나오 기라도 하지.. 관리는 어떻게 하면 팀이 일을 잘하게 할 수 있을지 등 많은 것을 생각해야하기도하구요. 제가 이 책을 보고 크게 와 닿았던 것 중에 하나는 코딩, 개발 업무는 Quick Win이 가능하다. 구현 후 빠르게 결과를 볼 수 있다는 것인데 이 이야기는 곧 빠른 피드백을 받아볼 수 있는 것 반면 관리(매니징)는 여러 요인으로 인해 Quick Win이 힘들다. 때로는 조직의 복잡도로 인해 문제 해결이 오래 걸릴 수도 있고, 개개인의 사정이 있어 시간이 걸릴 때도 있고 등등 이런 차이로 인해 엔지니어 업무를 하다가 매니징 업무로 가기 더 어렵기도 하다는 것 어렵지만 누군가 해야 하는 관리 업무를 모두가 잘 헤쳐나갈 수 있었으면 좋겠습니다. 🙏매니저, 팀장이 되고자 하는 분들, 지금 팀장을 하고 있는 모든 분들이 이 책을 보고 매니저 업무에 도움이 되었으면 좋겠습니다.","link":"/blog/2020/09/29/Book-review-Engineering-7-year-Manager-1-day/"},{"title":"Book review: 크래프톤 웨이(Krafton way)","text":"크래프톤 웨이 책 소개 크래프톤 웨이 크래프톤(블루홀)이라는 회사가 어떻게 시작되었고 살아왔는지 보여주는 책입니다.경영진의 입장에서 게임 개발 회사가 성장보다는 어떻게 살아남았는지, 어떤 고민들을 했는지를 볼 수 있습니다. 책에 대한 소개는 링크에서도 보실 수 있으니 바로 감상평으로 넘어가겠습니다 😸 감상책은 재미있게 술술 읽힌다!시간순으로 내용이 작성되기도 했고 당시의 결정이나 고민들이 간접적으로 느껴져서 시간가는 줄 모르고 읽었습니다. (300장이 넘지만 3-4일안에 다 읽은 것 같네요) 한편으로는 경영자의 시야와 실무자, 직원 입장에서는 다르게 느꼈을 수 있겠구나하는 관점의 차이도 알 수 있었네요. 지금까지 알지 못했던 크래프톤(블루홀) 초창기 모습, 초기의 어려움을 알 수 있어 좋았다.저는 2018년 초에 PUBG(펍지)에 입사한 사람이어서 당시 블루홀이 어떤 회사인지, 연합군은 무엇인지 사실 지금까지도 잘 알지 못했습니다. (관심이 크지 않았다고 말할 수 있겠네요.) 이 책을 보면서 회사 초기의 모습을 어렴풋이 알 수 있어서 좋았고 회사 초기 어려움들을 조금이나마 느낄 수 있어서 느낀점이 많았습니다.(느낀점이 많다고는 했지만 모두 자세하게 나열하기는 어렵네요. ㅎㅎ) 블루홀의 뜻을 이제 알았고 블리자드와 연관된 것도 처음 알았네요. 종종 블라인드에서 크래프톤 경영진, 리더십에 대한 무책임함에 대한 이야기가 있었는데 이런 일들 때문에 그럴 수 있었겠구나 이해할 수 있었습니다. 블루홀의 비전이었던 “MMORPG 제작의 명가”는 지금 “제작의 명가”로?책을 읽으면서 지금은 어떻지? 하면서 읽었네요. 지금 크래프톤에 있기에 그런 생각을 하면서 읽게된 것 같습니다. 우리에게 그 비전을 계속 이야기하고 있나? 어떻게 하면 모두가 그 비전을 동일하게 생각할 수 있을까?스튜디오, 본부, 실(유닛), 팀으로 비전이 스며들어 있을까? 하는 생각이 들었습니다. 그리고 연합군이 목표했던 바를 이루고 있는가도 궁금해졌어요.크래프톤이 퍼블리셔에게 단일팀보다 더 큰 존재가 되었는가, 경쟁우위가 생겼는가 말이죠. 책의 마지막 부분에서의 PUBG크래프톤 웨이에는 대부분 블루홀 때의 이야기가 많았고 후반부에 PUBG, 지노 게임즈에 대한 이야기가 나옵니다.이런 흐름만 봤을 때 책에는 지금까지 쓰여온 블루홀, 크래프톤의 시작에 대한 (경영자 시점의) 역사가 쓰여있습니다. 창한님이 크래프톤 CEO가 되고 그 이후의 길들은 또 다음 책에서 쓰여질 수 있겠네요. 마무리저는 이 책을 회사에서 나눠주어서 볼 수 있었는데요. 나름 재미있게 보았습니다.주변 스타트업에서 리드로 일하시거나 대표로 일하시는 분들은 다들 잘 읽었다고 하시는 것 같았는데반대로 사측의 내용이 많다는 의견도 들었네요. 아무래도 경영자의 관점에서 풀어낸 책이어서 그럴 수 있을 것 같습니다. 두 측면에 이야기가 모두 이해가 되기도 해서 고민을 많이해볼 수 있어서 좋았던 책이었습니다.","link":"/blog/2021/07/31/Book-review-Krafton-way/"},{"title":"Book review: 리더, 절대로 바쁘지 마라","text":"책 소개리더 절대로 바쁘지 마라 감상첫 인상저자 소개를 보면 김종명님은 보증보험, 패션 업계에 리더로 일하셨고 업계에서 어떻게 일해왔는지를 알 수 있는 내용으로 각색하셨네 하는 느낌을 받았습니다.실제 차장님, CEO 정도의 연령대의 이야기로 보고 뉘앙스를 이해해보았어요.IT 업계쪽 리더보다는 역사가 있는 업계의 리더십 관련 서적으로 추천하면 좋을 것 같은 맛이긴 합니다.(제가 보기엔 약간은 올드한 표현이나 상황들이 있었지만 고전을 읽는 느낌으로 읽었어요 😃) 눈치보는 리더가 성공한다, 공포의 시간을 견뎌라책의 시작 쯤에 “눈치보는 리더가 성공한다”로 시작해서 팀원들이 어떤 상황인지, 어떤 부분에서 어려워하는지를 알고 지지해줄 수 있는 등, 리더는 살피는 사람이라고 이야기합니다.그 외에도 팀원들이 스스로 잘할 수 있다는 것을 믿어야 팀원들이 잘 해낸다는 것과 팀의 설장을 위해 공포의 시간을 견뎌야하는 것도 좋은 이야기였습니다. 종종 리드로 일하면서 “저건 저렇게 하는게 맞을까?” 또는 “나라면…” 하는 생각을 하곤하는데,처음에 방향성과 목표/목적을 팀원과 잘 맞추고 이후의 일은 팀원이 알아서 잘 할 수 있도록 지켜보고 장애물을 치우는 일을 하라는 이야기였습니다. 공포의 시간이라는 표현이 재미있었네요.리더에게는 팀원을 지켜보면서 잘하고 있나? 저 방식이 괜찮나? 하는 생각도 들고 때때로 팀원들이 잘 할 수 있음에도 참지 못하고 끼어드는 경우도 있을 것이라 생각합니다.그 공포의 시간을 잘 견디고 팀원들이 잘 나아갈 수 있도록 돕는 일을 해야한다고 이해했는데 돕는 것도 견디지 못하고 끼어드는 것이 아닐까? 싶은 생각도 들었습니다. 아무튼 팀원들의 상태, 상황을 잘 이해하고 팀의 성과를 낼 수 있는 방법은 눈치를 잘봐야한다 -&gt; 센스가 좋아야한다 정도로 이해했습니다. 조직은 리더의 고민을 먹고 자란다 (시스템을 연구하라)조직에서 일어나는 일들이 왜 그렇게 발생했는지, 어떤 부분을 개선하면 좋을지 등은 팀 모두가 고민하면 좋겠지만리더가 먼저 고민을 하고 개선에 앞장서야한다는 내용입니다. 문제가 발생하면 사람에게 잘못을 이야기하기보다 시스템을 개선하고 연구해야한다는 것. 결국 조직이 어떻게 동작해야하는지, 팀의 일이 어떻게 동작해야하는지를 같이 고민하되 리더가 앞서서 고민해야한다고 이해했습니다.이렇게 고민을 많이 할 수 있으려면 리더의 일은 팀원 업무 관심갖기, 팀의 성과 고민, 상위 조직 목표 고민/방향 맞추기 등을 많이 해야겠구나 싶습니다.책 제목에 바쁘지마라고 했으나 실무가 많은 리더로 살아가고 있어서 현실성이 떨어진다는 생각도 드네요.다만 바쁘게 자기 일만 하는 것은 줄이고 팀이 시너지를 낼 수 있는, 팀 에너지의 총합보다 더 큰 결과를 만들어낼 수 있는 시스템을 고민해야한다고 항상 생각은 합니다.(행동이 생각을 따라가지 못해서 문제죠 ㅎㅎ 😂) 불평에 감사하라. 눈치보는 리더가 성공한다다시 한번 눈치보는 리더가 성공한다고 수미상관으로 마무리합니다.책의 예시로는 사업쪽 담당자가 보는 시야에서 비판하는 내용으로 디자인 실장이 그 비판을 수용하고 반영하는 이야기가 있었습니다.약간 허구가 있는게 다른 팀의 실장님에게 비판적인 이야기를 쉽게 할 수 있을까? 싶긴했지만 이야기 뒤에 “실장님이 피드백을 잘 듣는다”는 설정이 있지 않을까 싶긴했습니다. 비판, 피드백 등을 잘 수용하는 리더, 눈치보는 리더가 성공한다는 이야기네요.비판을 하지 않는 조직, 피드백이 없고 소통이 없는 조직은 목표를 달성하거나 성공하기 힘들겠죠. (물론 팀 목표가 무엇이냐에 따라 다를 수 있겠지만요) 마무리김장수의 디자인 브랜드 런칭 TF에서 일어나는 이야기로 리더가 고민하고 생각해야할 것들을 이야기 형식으로 재미있게 다뤘습니다.바쁘지 말아야한다는 제목을 해석해보자면 자기일에만 바쁘게 살지말고 팀을 생각하는 시간을 잘 지켜야한다 정도로 볼 수 있을 것 같네요.사실 팀 생각하는 것도 바쁜 일에 한몫을 하는 것 같기도 한데요. 어쨌든 리더, 생각할 시간 없이 바삐 살지 말고 여유 시간 잘 챙겨야한다고 해석해보며 마무리해봅니다.","link":"/blog/2023/11/07/Book-review-leader-dont-busy/"},{"title":"Bulk remove change Jira issue links","text":"Jira 이슈에 연결되어있는 이슈 링크 한번에 삭제하기참고: https://community.atlassian.com/t5/Jira-questions/Bulk-remove-change-issue-links-in-Jira/qaq-p/659381 문제 인식최근 특정 Jira 이슈에 연결된 이슈들을 삭제해야하는 일이 있었습니다.(한 작업 이슈에 확인한 버그를 모두 링크를 달고 링크된 버그 이슈들을 보다가 링크 타입이 잘못된 것도 있는 등의 이슈가 있어 수정이 필요했습니다.)Bulk로 링크들을 삭제하는 기능이 있는지 찾아보았는데 없더군요. 그래서 스크립트러너로 가능한지 찾아보았습니다. 다행히, 당연하게도 이미 같은 고민을 했던 사람들이 있었고 아틀라시안 커뮤니티 채널에 해결방법이 있었습니다.기본 Jira 기능에는 없지만 스크립트러너를 사용해서 가능하다는 것이었죠. 제가 현재 사용하고 있는 Jira 버전은 8.5여서 위 링크의 8.x 코드를 보면서 설명해보고자 합니다.(위 링크에 7.13 버전에서 사용할 수 있는 코드도 있으니 참고해서 쓰시면 됩니다.) 문제 해결 방법 (ScriptRunner)123456789101112131415161718192021import com.atlassian.jira.component.ComponentAccessorimport com.atlassian.jira.issue.IssueManagerimport com.atlassian.jira.jql.parser.JqlQueryParserimport com.atlassian.jira.bc.issue.search.SearchServiceimport com.atlassian.jira.web.bean.PagerFilterimport com.atlassian.query.Querydef searchService = ComponentAccessor.getComponent(SearchService)def jqlQueryParser = ComponentAccessor.getComponent(JqlQueryParser)def user = ComponentAccessor.getJiraAuthenticationContext().getLoggedInUser()def results = searchService.search(user, jqlQueryParser.parseQuery(&quot;Your JQL Filter&quot;), PagerFilter.getUnlimitedFilter())def issueManager = ComponentAccessor.getIssueManager()results.getResults().each{ def issue = issueManager.getIssueObject(it.id) log.warn(issue.key) // get all linked issues log.warn(ComponentAccessor.issueLinkManager.getLinkCollection(issue, user).getAllIssues()) ComponentAccessor.issueLinkManager.removeIssueLinks(issue, user)} 로그 관련한 코드는 설명 중 불필요하여 삭제했습니다. 실제 코드 동작하는데에 영향이 없습니다.사실 코드 상으로는 크게 어려운 부분이 없습니다. 스크립트 Flow 검색, JQL 파서, 사용자, 이슈 컨트롤러를 정의한다. (검색 및 설정 준비 과정) JQL을 통해 이슈들을 가져온다. 각 이슈들의 모든 링크를 삭제한다. issueLinkManager, removeIssueLinksissueLinkManager 인터페이스 설명은 jira/docs/api/8.5.1/…/IssueLinkManager 이 문서에서 볼 수 있습니다.이 매니저에는 여러가지 함수들이 있습니다. 이슈 링크의 생성, 삭제, 조회, 변경 등이 가능합니다. removeIssueLinks() 함수도 위 issueLinkManager에서 볼 수 있는데요. 123456int removeIssueLinks(Issue issue, ApplicationUser remoteUser)// Parameters:// issue - the Issue// remoteUser - the remote user// Returns:// The total number of issuelinks deleted. 모든 링크를 삭제하고자하는 이슈와 삭제할 때 필요한 사용자를 받아 함수가 동작합니다. 스크립트 결과맨 처음 이미지를 보여드렸던 이슈의 키를 JQL로 입력하고 실행해보겠습니다.“key=PUBGTEST-112”로 입력하고 스크립트 콘솔에서 테스트 해보았습니다. Logs: 122020-02-23 02:16:42,545 WARN [runner.AbstractScriptRunner]: PUBGTEST-1122020-02-23 02:16:42,545 WARN [runner.AbstractScriptRunner]: [PUBGTEST-75, PUBGTEST-111, PUBGTEST-225] Timing: Elapsed: 4949 ms / CPU time: 531 ms동작하는데 생각보다 시간이 많이 걸리긴 하네요.(약 5초 정도 걸리는 것으로 보이는데 링크 삭제가 오래걸리는 것인지 다른 것이 오래걸리는 것인지는 봐야겠습니다.) 실행 결과로는 이슈의 히스토리에 아래와 같이 남았습니다. 링크가 걸려있는 이슈의 모든 이슈 링크들이 삭제되었습니다! 👍 문제 해결!제가 했던 하나의 이슈만 링크를 삭제할 수도 있고 JQL로 검색된 모든 이슈들의 모든 링크를 삭제할 수 있습니다.다만 여기서 제가 원했던 것은 모든 링크의 삭제가 아니라 특정 타입의 링크들만 삭제하고 싶었던 것이어서다음 포스트에서는 특정 링크 타입의 링크를 삭제하는 내용으로 한번 더 다뤄봐야겠습니다. 다음 포스트에서 만나요! :)","link":"/blog/2020/02/23/Bulk-remove-change-Jira-issue-links/"},{"title":"Confluence 6.12-6.15 Release notes","text":"Confluence Release Notes All Release Notes 6.13 Release Notes 6.14 Release Notes 6.15 Release Notes Confluence 6.12 - 6.15 릴리스 노트컨플루언스 릴리스 중 6.12부터 6.15를 살펴보고자 합니다.왜 6.12부터인지는… 현재 회사에서 6.12에서 6.15로 업데이트하면서 알게된 내용을 남겨보게되었습니다.지금은 7.0 버전의 릴리스 노트가 나왔네요. (나중에 7.0 버전도 업데이트하면서 정리해봐야겠습니다.) 그럼 최신 순서대로 살펴보겠습니다. 6.15 릴리스Filter your search by space category 스페이스(공간) 카테고리에 따라 검색할 수 있도록 스페이스 카테고리가 추가되었습니다.스페이스를 카테고리로 나누고 그에 따라 검색할 수 있는 기능을 사용할 수 있게되면서스페이스를 많이 사용하는 곳에서는 유용한 기능일 수 있겠네요. Import with confidence 임포트할 때 실수하지 않도록 UI를 개선했다는 내용이네요.경고 사항이나 여러가지 설명 사항들이 추가되었습니다. 6.14 릴리스Find work faster with the new Confluence search이번 업데이트에서 검색이 빨라졌다고 합니다.그동안에는 약간 느린 느낌이 있었는데 업데이트 이후에는 빨라진 느낌이 있긴했습니다.검색 기능이 많이 강화되긴 했습니다. Search for anything기존에는 제목을 기반으로 검색하여 결과가 제한적이었습니다.이번 업데이트에서는 파일, 내용 등 컨플루언스 컨텐츠 전체를 대상으로 검색하도록 개선되었습니다. Quickly refine results with filters검색 결과에 필터를 할 수 있도록 반응형 필터가 추가되었습니다.스페이스, 작성자, 작성 시간 등으로 검색 결과를 필터링 할 수 있습니다. Massive editor improvements에디터의 기능 및 버그 등을 많이 수정했다고 합니다. table cells, bullet points, and cursor behaviour, especially when copying and pasting content 위와 같은 것들을 수정했다고 하는데 많이 개선된 것 같기는 하지만 몇가지 버그가 계속 존재하긴 하는 것 같습니다.(에디터 특성상 어쩔 수 없다고 생각하긴합니다. 명확히 정리하기 힘든 버그들이 있긴해요) More ways to edit files6.11 릴리스에서 첨부 파일 업데이트 기능이 업데이트 되었는데이번 릴리스에서는 페이지에서 직접 파일을 수정할 수 있는 기능이 추가되었습니다. (Attachments macro) Delete profile picture관리자가 사용자의 프로필 사진을 지울 수 있는 기능이 추가되었습니다.Delete Profile Picture 내용으로 검색해보면 메뉴를 볼 수 있습니다. Number your PDFs the easy way스페이스를 익스포트할 때 PDF로 하는 경우 페이지 숫자를 넣을 수 있는 기능이 추가되었습니다.사실 사용해보지 않아서 잘 모르겠는 기능이긴 하지만 많은 페이지를 익스포트할 일이 있고그것을 리포트 형식으로 보여줘야한다면 쓸만할 것 같기도 합니다. 6.13 릴리스6.13 릴리스는 엔터프라이즈 릴리스 입니다.(엔터프라이즈 릴리스: 해당 릴리스가 수명이 다할 때까지 버그 수정 릴리스를 제공하는 릴리스) Supporting your GDPR effortsGDPR에 대응할 수 있도록 기능을 몇가지 추가하였습니다.계정을 삭제하거나, 사용 중지 등을 할 수 있고 그 계정의 컨텐츠도 삭제할 수 있게됩니다.(한번에 모든 내용이 삭제될 수 있게됩니다.) PDF export improvementspdf 익스포트 기능이 개선되었습니다. (자주 개선되는 PDF 익스포트 기능이네요.)레이아웃에 맞게 익스포트하는 것이 어렵다는 점 알고 있어서 항상 개선하는 점은 좋은 것 같습니다.아래는 수정된 내용입니다. Tables better match their Confluence counterparts, no longer filling the whole width, or forcing the columns to be equal width. Headings have been refreshed, with more consistent sizing. Ugly ducklings like the recently worked on, status, and tip macros now display more consistently. Each Confluence page starts on a new PDF page, making your documents easier to read. Long words and strings now wrap correctly. Moving to the Cloud has never been easier 컨플루언스 클라우드로 마이그레이션을 쉽게 진행할 수 있도록 개선되었습니다.마이그레이션이 필요한 내용들을 직접 선택하고 마이그레이션이 진행되는 모습도 볼 수 있도록 개선되었다고 합니다.(그전에는 어떻게 마이그레이션을 할 수 있었는지 모르겠습니다..) 마무리컨플루언스는 많은 기능들이 추가되기보다 버그 수정이나 QoL의 내용이 많은 것 같네요.사실 많은 기능들은 매크로로 빠져있어서 그런 것 같기는 합니다.다음에는 7.0 릴리스 소식을 들고오겠습니다. 감사합니다.","link":"/blog/2019/10/15/Confluence-6-12-6-15/"},{"title":"Confluence 7.0~7.8 Release notes","text":"Confluence Release Notes All Release Notes Confluence 7.0 - 7.8 릴리스 노트지난 Confluence 6.12-6.15 Release notes 포스트에서 컨플루언스 버전 6에 대한 릴리스 노트를 소개하고 한동안 정리를 안했더니 버전 7이 어느새 7.8까지 나왔네요.모든 내용을 다루기는 힘들 것 같아 하이라이트 기능만 짚고 넘어가보고자 합니다. 😀(하이라이트 항목은 없지만 사용자 입장에서 알아두면 좋을만한 내용들을 정리해본다고 생각해주시면 될 것 같습니다.) 7.0 Release notes 7.0 Release notes 버전 7의 첫 버전 업데이트는 2019년 9월이었네요.7.0 버전 업데이트에는 사용자 측면에서는 큰 변경사항은 없습니다. 다만 버전 7에서는 어떤 것을 해나갈지 릴리스 노트 앞에 이야기를 해두었네요. Welcome to Confluence 7In Confluence 7.0 we’re continuing to invest in the future of Confluence, providing solutions for geo-performance challenges, better upgrade planning tools, and new admin tools to help meet your organization’s needs for years to come. 컨플루언스 7에서는 컨플루언스의 미래에 투자하는 것을 지속한다고 합니다. geo-performance(지역, 리전별 성능. 예를 들면 다른 나라에서 페이지를 로딩할 때의 성능 같은 것) 도전과 플래닝 툴 개선, 새로운 어드민 툴을 만들 것이라고 하네요.현 시점에서 얼마나 지켜졌는지도 한번 확인해보면서 릴리스 노트 소개해보겠습니다. 😂 Be better prepared for upgrades Jira에 업데이트 되었던 pre-upgrade 플래닝 기능이 추가되었네요.버전 업데이트를 더 안정적으로 할 수 있도록 하는 툴의 추가는 좋은 것 같습니다. Move your site to the Cloud 버전 업데이트와 더불어 클라우드로 마이그레이션 할 수 있도록 마이그레이션 툴이 추가되었습니다.최근에 클라우드 버전으로 완전히 변경하기 위한 기반 작업이 아니었을까 싶네요 7.0은 별다른 업데이트 내용이 없어 마치고 다음 릴리스 노트로 가보겠습니다. 7.1 Release notes 7.1 Release notes 2019년 11월에 업데이트되었던 릴리스 노트입니다.7.1 업데이트에도 크게 소개할만한 내용은 없네요.매크로 관련 기능 개선 및 페이지 복사할 때에 첨부 파일도 같이 복사할지에 대한 옵션이 추가되었습니다.Java 11 지원 및 컨플루언스 내에서 엑셀이나 워드 파일 등 Office 파일들을 Office 앱으로 바로 연결해서 수정할 수 있는 기능을 컴패니언 앱에서도 사용할 수 있도록 지원한다고 합니다. 그 외에는 더 소개할만한 내용이 없네요. 7.2 Release notes 7.2 Release notes 2019년 12월에 업데이트되었던 릴리스 노트입니다.데이터 센터 쪽 업데이트 한개가 있네요. 인프라에 있는 서버들을 관리하기 위해 클러스터 모드를 이용해서 관리할 수 있도록 업데이트가 되었네요.인프라에서 관리되는 서버들의 설정 등을 관리할 수 있도록 업데이트 되었습니다.요거 하나 업데이트 있는 7.2 버전이었네요. 7.3 Release notes 7.3 Release notes 2020년 2월에 업데이트되었던 릴리스 노트입니다.파일 수정 컨트롤과 관련한 내용 및 권한 등에 대해 업데이트가 되었네요. Advanced permissions management for easier administration권한과 관련한 업데이트 내용은 공간 권한 관리를 관리자가 쉽게할 수 있도록 하는 기능들이었습니다.(사용자 권한이 올바른지 확인하거나 한번에 권한을 변경하거나하는 등의 기능이 추가되었습니다.)자세한 내용은 여기서 볼 수 있습니다. Inspect permissions Safeguarding performance &amp; rate limiting페이지 트리를 로딩할 때, 많은 페이지를 로딩하면서 권한에 따라 보여주는 것이 달라집니다.이에따라 성능에도 영향을 주는데 이를 피할 수 있도록 트리 단계당 최대 200페이지까지만 보이도록 하고 이후 내용은 Show all로 볼 수 있도록 변경했다고 합니다.(페이지가 많고 한 단계에 많은 페이지가 있다면 유용하긴 할 것 같네요.) rate limiting은 간단하게 컨플루언스 시스템에 요청을 제한하여 안정적으로 동작할 수 있도록 하는 기능입니다.주로 REST API 요청이 많은 것을 예로 들고 있고 그에 대한 제한을 이야기하고 있습니다.자세한 내용은 여기서 볼 수 있습니다. Improving instance stability with rate limiting 7.4 Release notes 7.4 Release notes 2020년 4월에 업데이트되었던 릴리스 노트입니다.이번 7.4버전은 LTS(Long Term Support) 업데이트 버전으로 설정되어 진행된다고 합니다.그 외의 업데이트 내용은 특별히 공유할만한 내용은 없고 컨플루언스 서버 앱을 Mobile Device Management (MDM) 솔루션을 이용해서 디바이스 관리를 할 수 있다고 합니다. 7.5 Release notes 7.5 Release notes 2020년 5월에 업데이트되었던 릴리스 노트입니다.7.5 버전 업데이트에는 audit log, 테이블 색상 추가, 위젯 커넥터 업데이트 등이 있습니다. Audit like a pro with our new Audit log audit log와 관련해서 어떤 내용을 저장할 것인지 설정화면이 사용성이 개선되었습니다.얼마나 저장할 것인지, 어떤 내용을 저장할 것인지 등 관리할 수 있게되었다고 하네요. Bring some colour to your tables 원래는 색이 몇개 안되었었는데 많이 추가되었네요. (색이 많이 추가되어서 하트도 그릴 수 있네요 😸) Widget connector gets a modern makeover페이지 매크로에 여러가지 위젯 커넥터를 이용해서 페이지를 작성할 수 있도록 위젯이 추가되거나 업데이트되었습니다페이스북, Figma, LinkedIn, Microsoft Stream, Frezi, Spotify를 사용할 수 있다네요.구글 캘린더, 맵, 구글 docs, 트위터도 위젯이 개선되었다고 합니다. ETC추가로 OpenID 커넥트 프로토콜을 사용할 수 있게된 내용이나 컴패니언 프로그램 언어 지원 등에 대한 내용도 있습니다. 7.6 Release notes 7.6 Release notes 2020년 6월에 업데이트되었던 릴리스 노트입니다.사용자 입장에서는 볼만한 내용은 없고 관리자 입장에서는 audit log 관련 기능이 눈에 띄겠네요. 사용자들의 액션 중 페이지나 블로그 포스트를 옮기거나 공유, 권한 요청, 권한 생성 등을 볼 수 있게되었습니다. 7.7 Release notes 7.7 Release notes 2020년 8월 업데이트되었던 릴리스 노트입니다.웹훅, 에디팅 기능 개선, 접근성 개선, 성능 개선 등 이번 업데이트에는 변경사항이 많네요.Audit log에서는 필터를 할 수 있는 것이 많아져서 더 보기 편해질 것 같습니다. Take Confluence to the next level with webhooks기존에 컨플루언스에 웹훅이 없다가 7.7 버전에 웹훅이 추가되었다고 합니다. 유저 또는 그룹이 추가되거나 삭제되었을 때 컨텐츠가 추가되거나 업데이트되었을 때 컨텐츠가 삭제되거나 복원되거나 휴지통에서 제거할 때 이런 이벤트가 발생할 경우 웹훅이 동작할 수 있게 설정할 수 있다고 합니다.관련한 자세한 내용은 Managing Webhooks 페이지에서 볼 수 있습니다. Seamless editing experience &amp; Accessibility improvements에디팅할 때 여러가지 이슈들을 수정하고 개선했다고 합니다. (끝나지 않는 에디터 기능 개선..)부디 많은 개선이 이뤄졌기를 🙏 추가로 접근성 개선도 함께 이뤄졌네요.버튼에 이름이 빠진 것, 키보드 네비게이션 버그 수정 등이 이뤄졌습니다. Reindex your cluster without downtime클러스터에 리인덱스를 다운타임(점검) 없이 할 수 있도록 개선되었다고 합니다. More control of your audit log 카테고리, 제목 별로 필터를 할 수 있도록 audit log가 개선되었네요.많은 로그를 봐야하는 관리자 입장에서 로그 관련한 기능이 또 추가되어 사용성이 올라간 느낌입니다. :) Page Properties Report macro performance improvements페이지 속성 보고서 매크로의 성능 개선이 이뤄졌습니다.보고서를 500개 까지만 제한하여 로드하는 것을 통해 3000 페이지까지 보여줄 수 있도록 개선이 되었다고 하네요.이 제한 값은 시스템 값으로 변경할 수 있다고 합니다. 7.8 Release notes 7.8 Release notes 2020년 9월에 업데이트되었던 릴리스 노트입니다.audit log에서 유저 활동 관련 내용 추가와 페이지 속성 보고서 매크로 레이블 제한 수 증가, 중지된 매크로 보여주기 등이 업데이트되었습니다.(추가로 allowlist, blocklist 변경건도 있네요 💃🏿) 마무리7.0 버전부터 7.8 버전까지 살펴보았습니다.하나하나 모든 기능을 설명해보려고 했으나 내용이 너무 많아서 생략하거나 압축한 버전도 있네요.사실 컨플루언스는 지라보다는 문서 에디팅 기능에 초점이 있다보니 다른 기능에는 눈이 가지 않네요. 😂 이 글이 컨플루언스 업데이트 시 작은 도움이 되었으면 좋겠네요. 감사합니다.다음 포스트에는 “아틀라시안 앞으로 클라우드로 서비스한다?!”는 내용을 가져와보겠습니다.","link":"/blog/2020/10/18/Confluence-7-0-7-8-Release-notes/"},{"title":"(Game Dev Study) DirectX, Vulkan 정리","text":"Low level Graphics API (저수준 그래픽스 API)DirectX, Vulkan을 소개하기에 앞서 저수준 그래픽스 API는 뭔지 알아봐야겠죠? https://en.wikipedia.org/wiki/List_of_3D_graphics_libraries 위키에서는 3D 그래픽스 라이브러리로 이야기하고 있지만 그래픽스 API로 이해하고 보시면될 것 같습니다.말 그대로 컴퓨터에서 3D를 볼 수 있게하는 그래픽스 엔진, 라이브러리로 이해하시면 편하겠네요. 이런 API를 통해서 언리얼 엔진이나 각종 게임 엔진에서 오브젝트들을 렌더링하고 그래픽 결과물들을 보여주고 있습니다. DirectX, Vulkan 소개DirectXhttps://ko.wikipedia.org/wiki/DirectX 마이크로소프트에서 만든 주로 게임 개발에 널리 쓰이고 있는 API입니다. (멀티미디어를 위한 API)DirectX에는 2D, 3D 등 그래픽 렌더링을 위한 API가 포함되어있습니다. DirectX는 마이크로소프트 플랫폼(Windows, Xbox)에서 동작하는 그래픽스 API로 많은 게임에서 사용되는 API입니다.현재 최신 버전은 12버전으로 Dx12, D3D12로 많이 부르기도합니다. 관련 자료들은 마이크로소프트 페이지에서도 확인하실 수 있으니 참고해보세요! https://docs.microsoft.com/en-us/windows/win32/direct3d12/direct3d-12-graphics Youtube Videos: https://www.youtube.com/channel/UCiaX2B8XiXR70jaN7NK-FpA Vulkanhttps://ko.wikipedia.org/wiki/%EB%B2%8C%EC%BB%A8_(API) Vulkan은 크로스 플랫폼 3D 그래픽스 API입니다. 모바일, 리눅스, 마이크로소프트 플랫폼 등에 사용될 수 있다는 뜻이죠.크로노스 그룹에서 OpenGL의 차세대 버전으로 준비하다가 Vulkan이라는 이름으로 릴리스되었습니다. OpenGL처럼 게임이나 미디어 처럼 고성능 실시간 3D 그래픽스 앱을모든 플랫폼에서 고성능으로 CPU를 적게 사용하도록 개발하는 것을 목표로 만들어진 API입니다. 영상에서는 기존 OpenGL 보다 Vulkan이 CPU 코어 활용성이 좋고 에너지를 덜 쓰는 것을 비교해서 보여주고 있네요. DirectX 11, DirectX 12, Vulkan 뭘 써서 개발해야할까?요즘 게임 개발을 하는데 바로 저수준 그래픽 API를 사용해서 개발하는 경우는 별로 없을겁니다.언리얼 엔진이나 유니티 등 상용 엔진들을 사용해서 게임 컨텐츠를 개발하고 있죠. 컨텐츠 개발 이후 최적화에 있어서 어떤 것을 중점으로 최적화를 할지, 어떤 플랫폼에 런칭을 할지에 따라 위 질문에 있는 모든 것을 사용해야할 수도 있습니다.Dx11이 Dx12 보다 버전이 낮지만 현재 개발된 환경에 따라 11 버전을 사용해야할 수도 있겠죠.API에 맞게 최적화도 필요한 것이 있어 각 개발 환경에 맞춰 개발해야한다 정도로 이야기할 수 있을 것 같습니다. (너무 정론이네요 😂) DirectX vs Vulkan? 2개의 API를 확인해보았으니 비교를 안해볼 수 없죠! 사실 Youtube에서 2개의 API를 치면 많이 나오는 것이 비교내용입니다.게이머 입장에서는 그래픽 품질은 좋고 FPS가 잘나오면 최고이니까요. 게임 개발 엔진들에서도 각 API를 사용하여 개발할 수 있도록 지원하고 있기도하구요. 영상만 보았을 때는 Dx11은 Dx12, Vulkan에 비해 안좋은 버전으로 보이지만 사실 버전에 맞춰 게임 코드도 최적화가 필요하기에 버전만 12로 올리기는 어렵습니다. 다른 블로그 글이나 아티클들을 보면 두 API를 비교한 것은 대부분 성능상의 비교가 대부분인데요.이건 사실 하드웨어 + 게임(앱) 마다 천차만별이라서 뭐가 더 좋고 나쁘다를 판별하기는 어렵다고 생각합니다. 마무리사실 2개의 API를 비교하고 차이점을 정리하기에는 어려움이 있네요. 각각 그래픽을 렌더링하기 위해 다른 동작을 사용하고 있는 것도 있고 기본 개념이 같은 것들도 있었습니다. 이번 포스팅을 위해 공부를 얕고 짧게했지만 누가 우위에 있냐는 크게 중요하지 않은 것으로 결론을 내렸습니다. 아마 다음에는 하나하나 조금 더 깊게 공부할만한 주제로 찾아올 수 있지 않을까 싶네요. 다음에는 게임 개발에 필요한 그래픽스에 대해 조금이나마 더 알 수 있는 지식으로 찾아오겠습니다. 감사합니다. 😈","link":"/blog/2021/07/31/DirectX-Vulkan/"},{"title":"(Game Dev Study) Grahpics - RenderDoc","text":"RenderDoc이란? https://renderdoc.org/ 그래픽 작업, 렌더링 최적화를 위한 프로파일링으로 사용할 수 있는 디버거 툴로 사이트에서 설명하는 내용을 가져와보면 다음과 같습니다. RenderDoc is a free MIT licensed stand-alone graphics debugger that allows quick and easy single-frame capture and detailed introspection of any application using Vulkan, D3D11, OpenGL &amp; OpenGL ES or D3D12 across Windows, Linux, Android, or Nintendo Switch™.→ 요약해보면 오픈소스 그래픽 디버거로 쉬운 프레임 캡처와 상세 분석(검사)을 할 수 있는 툴입니다. RenderDoc은 Github에서 소스를 공개하고 있으며 빌드는 홈페이지에서 다운로드 받을 수 있습니다. Source: https://github.com/baldurk/renderdocDownload: https://renderdoc.org/builds RenderDoc으로 분석할 수 있는 것언리얼 서밋 2019에서 다룬 내용을 중심으로 정리해보려합니다. 영상에서는 언리얼 엔진에서 RenderDoc 플러그인을 설정하고 보여주고 있어서 언리얼 엔진의 렌더링 파이프라인에 맞춰 정리해보겠습니다. 위 파이프라인은 추상화한 내용으로 더 자세한 내용은 참고 자료 링크로 남겨두겠습니다.쉬운 이해를 위해 추상화를 하면서 그림을 그리는 단계와 비교해서 쉽게 설명해주셨어요. 밑그림 - 밑그림 색칠 - 다듬기 - 그리기 - 마무리각 단계별로 어떤 내용들을 볼 수 있는지 알 수 있었습니다. ⭐ 요약 ⭐ PrePass - BasePass - Lighting - Translucency 각 단계에서 일어나는 일을 분석할 수 있음 Event Browser 에서 각 단계의 이벤트를 확인하고 Texture Viewer, Mesh Viewer, Pixel History 등의 기능을 통해 분석, 프로파일링할 수 있다 PrePass - 밑그림 RenderDoc에서 렌더링 파이프라인에 따라 이벤트가 발생하고 그 시점에 따라 분석할 수 있게 되어있네요. (화면 왼쪽에 Event Browser에서 확인할 수 있음) 위에서 보고 있는 event는 PrePass(PrePass DDM_AllOpaque …)입니다. 이 단계에서는 하위 이벤트에서 각 에셋들의 메쉬들을 Mesh Viewer를 통해 확인하고 과도하게 메쉬를 복잡하게 만들지 않았는지를 확인할 수 있습니다.(폴리곤을 과도하게 사용하지는 않았는지 = 너무 디테일하게 메쉬를 만들었는지) BasePass - 밑그림 색칠 BasePass는 PrePass와 동일하게 모델을 화면에 맞게 변형합니다. 그 후에 PrePass과 대조해서 필요한 곳에만 색칠하는 작업을 반복합니다. PrePass를 이용하여 필요한 곳만 색칠할 수 있습니다.이 단계에서는 Texture Viewer에서 각 에셋을 텍스쳐로 색칠하는데에 필요하지 않은 텍스쳐가 사용되거나 잘못된 경우를 찾아볼 수 있습니다. 영상 예시로는 범용 머터리얼을 사용해서 발생한 이슈로 필요한 텍스쳐만 사용하는 머터리얼로 수정하고 해결하는 것을 볼 수 있었습니다. Lighting - 다듬기 Lighting 단계에서는 에셋들이 빛의 영향을 잘 받는지 비효율적으로 빛의 범위가 크게 설정되어있지는 않은지 확인할 수 있습니다. 라이팅 각 이벤트를 눌러보고 Texture Viewer의 Outputs를 보면 어떻게 라이트가 적용되어 렌더링 씬이 바뀌어가는지 알 수 있어요. 영상에서는 불필요한 큰 라이트 범위를 조정해서 라이팅 렌더링 비용을 개선했습니다. 👍 Translucency - 그리기 이 단계는 대략 그림이 완성되었으니 마지막 마무리로 계속 이미지를 겹쳐서 그리는 단계입니다.이 때에 추가로 그리는 범위가 커질수록, 겹쳐서 그릴수록 어려워지게됩니다. (비용이 커짐) 이 부분에 대한 프로파일링, 최적화는 언리얼 엔진 에디터에서도 쿼드 오버드로(Quad Overdraw)나 셰이더 복잡도(Shader Complexity) 뷰를 통해서 보고 개선해볼 수 있습니다. RenderDoc에는 Pixel History 기능을 통해서 픽셀이 어떻게 변화했는지 볼 수 있는 편리한 기능이 있습니다. Texture Viewer → Outputs → 이미지에서 확인하고자하는 픽셀 영역을 오른쪽 버튼을 누릅니다 Outputs 하단에 History를 누릅니다 → 픽셀이 변화한 히스토리를 확인합니다 영상에서는 확인한 곳의 픽셀은 안개에 의해 색이 변해야하는 곳인데 변하지 않는 것을 픽셀 히스토리를 통해서 확인 → 개선! PostProcess - 마무리PostProcess 단계는 포토샵의 필터 적용과 같은 단계로 볼 수 있는데요. RenderDoc에서 언리얼 엔진의 PostProcess를 보기는 쉽지 않다고 합니다.어떤 기능에 의해 합쳐진 효과들이 적용되고 보이게되어서 RenderDoc에서는 한계가 있다고 합니다. 나중에 엔지니어나 TA 분에게 물어보고 공부해보는 것으로 해야겠군요 😃 마무리오랜만에 최적화 부분을 이것저것 들여다보니 재미있었네요. 😎찾다보니 RenderDoc은 오픈소스로 알려져있는 툴이고 Nvidia나 Intel에서도 분석툴이 있어서 나중에 한번 슬쩍보는 것도 재미있겠다 싶습니다.나중에 시간나는대로 Nvidia 부터 살펴보고 포스트해보겠습니다. 👋 가이드 문서, 자료 https://youtu.be/EF0YpKHfbAw 언리얼 서밋 2019 아티스트를 위한 흥나는 프로파일링!: RenderDoc 추가적인 내용은 위 영상을 참고하면 좋을 것 같습니다 가이드 문서-튜토리얼: https://renderdoc.org/docs/getting_started/quick_start.html 가이드 영상 모임: https://www.youtube.com/user/baldurkarlsson 언리얼 파이프라인: https://unrealcommunity.wiki/unreal-schematics-2d6859 언리얼 엔진 RenderDoc: https://docs.unrealengine.com/4.26/ko/TestingAndOptimization/PerformanceAndProfiling/RenderDoc/ 다른 그래픽스 분석 툴 Nvidia Nsight Graphics: https://developer.nvidia.com/nsight-graphics Intel Graphics Performance Analyzers: https://www.intel.com/content/www/us/en/developer/tools/graphics-performance-analyzers/overview.html","link":"/blog/2023/08/13/Grahpics-RenderDoc/"},{"title":"주간 자바스크립트 #446","text":"Googlebot의 자바스크립트 실행 방법, HTTP 서비스를 위한 새로운 자바스크립트 플랫폼, 자바스크립트 팟캐스트JavaScript Weekly Issue 446: July 19, 2019본문: https://javascriptweekly.com/issues/446 Smashtest: 테스트 케이스들을 설명하는 언어보다 자연스러운 방법으로 엔드 투 엔드 테스트를 작성하는 Cucumber 스타일의 방법이지만 기본적으로 자바스크립트 기반 테스트로 요약할 수 있다. 홈페이지에 있는 예시들이 사견으로는(IMHO) 아이디어를 잘 납득시킬 것이다.SMASHTEST Osgood 소개: HTTP 서버를 구축하기 위한 새로운 V8 기반의 플랫폼Rust와 V8 자바스크립트 엔진을 사용하여 구축된 Osgood는 안전한 HTTP 서비스 구축에 초점을 맞춘 새로운 플랫폼(Node의 스타일)이다. 보안은 모든 것이 개방되기 보다는 I/O 정책을 지정하도록 요구함으로써 이루어진다. GitHub repo.THOMAS HUNTER II 신뢰할 수 없는 포크에서 신뢰할 수 있는 CI 작업 트리거이 포스트에서는 Git 자체를 신뢰할 수 있는 코드 표시 수단으로 사용하는 방법에 대해 논의하고, 이러한 개념을 특정 저장소 호스트(GitHub)와 CI 제공자(CircleCI)에 적용할 수 있는 방법에 대한 전체 데모를 살펴본다.CIRCLECI SPONSOR ▶ 자바스크립트, 자바스크립트…. Rocks You!웹 오디오 API를 통해 실시간으로 오디오로 재생할 수 있도록 자바스크립트에서 효과 페달의 소리를 재생하는 방법에 대한 재미있고 음악으로 가득한 볼거리이다.VITALII BOBROV Quark: Node를 위한 ‘Sketchbook’ 소프트웨어, HTML과 CSS 실험들Electron으로 만들어졌지만 현재 윈도우즈와 리눅스만 사용할 수 있는 Quark는 HTML, CSS 및 자바스크립트 기반 앱을 신속하게 만들 수 있는 Jupyter Nodebook/Glitch 와 비슷한 개발 환경으로, Node의 API와 Electron의 기본 기능에 대한 접근이 완벽하다.NISHKAL KASHYAP 구글이 설명하는 자바스크립트 SEO 기본Googlebot이 웹을 크롤링할 때, 화면 뒤에서 크로미움을 실행하고 실제로 당신의 자바스크립트를 실행한다는 것을 알고 있었는가? 이것은 알아야 할 것들이 있다는 것을 의미한다.GOOGLE DEVELOPERS 🎧 최신 자바스크립트 팟캐스트 에피소드자바스크립트 팟캐스트에는 몇 개의 훌륭한 팟캐스트가 있다. 우리가 최근에 즐겼던 몇 가지 에피소드들은 다음과 같다: ▶ 자바스크립트의 기본Wes Bos (JavaScript 30로 유명한)와 Scott Tolinski는 JS의 기본과 당신이 정말 알아야 할 것에 대해 논한다.SYNTAX.FM ▶ Christian Heilmann가 어떻게 자바스크립트를 하게 되었나My JavaScript Story는 자바스크립트 개발자를 인터뷰하는 팟캐스트다. 나는 특히 Chris Heilmann (인기 자바스크립트 스피커) 에피소드를 즐겨 봤지만 즐길 것이 많다.MY JAVASCRIPT STORY ▶ 서버사이드 렌더링(SSR)의 이점과 과제Wix의 성능 기술 리더인 Dan Shappir가 출연한 한 시간 동안 진행된 라운드 테이블 토론이다.JAVASCRIPT JABBER ▶ Jan Lehnardt와 npm 종속성 관리 논의REAL TALK JAVASCRIPT 💻 채용 공고Frontend Engineer at Goodreads (Amazon)Goodreads에 참여하여 8천만 명 이상의 독자의 독서 활동을 지원하는 야심찬 제품의 앞날을 구축해보십시오.GOODREADS Front End Engineer / TrackVia (Denver, CO)TrackVia는 정교한 엔터프라이즈 앱을 드래그 앤 드롭 방식으로 생성할 수 있는 강력한 기능이다. 아름다운 덴버 시내에서 즐겁고 빠른 우리 팀에 합류하십시오.TRACKVIA Land a New Dev Job on VetteryVettery는 기술 역할을 전문으로 하며 구직자들에게는 완전히 무료다.VETTERY 📘 튜토리얼, 오피니언, 영상 테트리스가 35살이 되었으니 테트리스 복제를 만들어 보자멋진 시각적인 트위스트와 함께 자신만의 테트리스 클론을 만드는 \u001d과정에 대한 가이드.JAVASCRIPT TEACHER postMessage는 느린가?postMessage와 관련한 성능 문제와 우려에 대한 환상적인 심층 분석, Web Worker에게 메시지를 보내는 데 사용되는 방법.(역자 주, 참고: https://youtu.be/j1JEZ7snw48?t=305 영상에서 한번 나온 이야기)SURMA 자바스크립트에서 Async Await 에러 처리하기async / await 시나리오에서 에러를 처리할 때 발생하는 혼동을 해결하려는 시도VALERI KARPOV 자바스크립트 SDK를 통한 포괄적인 이미지 및 영상 관리Cloudinary는 원활하게 통합되는 코드를 사용하여 리치 미디어를 업로드, 조작, 최적화하여 제공한다. Cloudinary를 무료로 사용해보자CLOUDINARY SPONSOR 제안된 자바스크립트 기능인 Private 클래스 필드의 고찰몇 주 전 Axel은 public 클래스 필드를 다루었지만 private 필드도 제안서의 일부다(현재 스테이지 3).DR. AXEL RAUSCHMAYER JS 16줄로 ‘떨어지는 모래’-스타일 이미지 변화 효과이것은 내가 예상했던 것보다 훨씬 더 깔끔하다.SLICKER 역공학(역설계) 또는 자바스크립트에서 테스트 라이브러리를 구축하는 방법여기서의 목표는 기존의 거대한 더미에 또 다른 테스트 라이브러리를 추가하는 것이 아니라, 여러분이 직접 구축함으로써 테스트 라이브러리가 어떻게 작동하는지 더 자세히 알아보는 것이다.CHRIS NORING Finally… Promise의 **finally** 포스트프로미스를 사용할 때, finally가 언제 동작하는지에 대한 간단한 설명.SARAH DRASNER Node.js 12: 서버 사이드 자바스크립트의 미래Node.js 12는 ES6 모듈 지원, 애플리케이션 보안 향상 및 시작 시간 단축과 같은 몇 가지 흥미로운 개선 사항을 소개했다.PAIGE NIEDRINGHAUS Angular 아키텍쳐 패턴과 모범 사례(확장에 도움이 됨)BARTOSZ PIETRUCHA Web Unleashed - The Front-End Developer Event in Toronto, Sept 13-14네트워킹, 세션, 워크샵 등. 코드 JAVASCRIPTWEKLY로 #WEBU19 티켓 20% 할인.FITC SPONSOR 할일 목록 앱을 만들며 Svelte 3 학습최근 많은 사랑을 받고 있는 build-time UI 프레임워크인 Svelte에 대한 실용적인 소개.AYO ISAIAH 웹은 단일 문화에서 살아남을 수 없다당신은 웹이 크롬(Chrome)이 지배하는 단일 문화가 되는 것을 막을 수 있는 힘을 가지고 있다고 Mike는 말한다.MIKE PENNISI 🔧 코드와 도구들 Color Thief: 이미지에서 색 팔레트를 가져오기이미지가 주어지면, 이것은 주요 색상의 목록을 반환하기 위해 canvas를 사용한다.LOKESH DHAKAR Polly.js: 기록, 재생 및 Stub HTTP 상호 작용Node와 브라우저에서 모두 동작하는 Polly는 HTTP API에 탭하고 요청을 기록하고 재생하는 기능과 함께 속도를 줄이거나 속도를 높히는 기능을 추가한다.NETFLIX, INC. MongoDB Atlas는 강력하고 안정적인 클라우드 데이터베이스. 사용해보십시오 MONGODB SPONSOR Airtable.js: Airtable을 위한 자바스크립트 클라이언트Airtable은 인기 있는 클라우드 기반 스프레드시트-meets-database 서비스다. 우리는 Cooperpress에서 그것을 사용하기 때문에 잘 정비된 공식 라이브러리를 보는 것이 좋다.AIRTABLE SurveyJS: 자바스크립트 설문과 양식 라이브러리라이브 데모DEVSOFT BALTIC OÜ jest-puppeteer: Jest와 Puppeteer를 사용하여 당신의 테스트를 실행해보십시오SMOOTH CODE ⚡️ 릴리스 요약전체 기록이 필요없는 최신 릴리즈가 있는 인기 라이브러리 및 도구: Ember 3.11 — 또한 내가 가장 좋아하는 윈도우즈 버전도 부수적으로. Mocha 6.2.0 — 유명한 테스팅 프레임워크 Lerna 3.16.0 — 여러개의 패키지를 가진 JS 프로젝트를 관리하기위한 툴 Johnny Five 1.2.0 — JS 로보틱스와 IoT 프레임워크 SystemJS 4.1.0 — 동적 ES 모듈 로더 MDX 1.1 — 마크다운 문서에 JSX를 포함(임베드) melonJS 7.1 — 가벼운 게임 엔진 autoComplete.js 6.1 — 단순한 vanilla JS 자동완성 라이브러리 추신. 우리가 트위터에 있는 것 알고 있었습니까? @JavaScriptDaily 팔로우해주세요.","link":"/blog/2019/07/27/JavaScript-Weekly-446/"},{"title":"주간 자바스크립트 #447","text":"Mithril 2 와 몇가지 자바스크립트를 잘 작성할 수 있는 실용적인 방법들JavaScript Weekly Issue 447: July 26, 2019본문: https://javascriptweekly.com/issues/447 ▶ 자바스크립트 탄생: 자바스크립트 탄생의 이야기 27분 동안 자바스크립트의 역사를 파헤치는 굉장히 고도로 제작된 팟캐스트 에피소드. 당신이 통근할 때 들을만한 팟캐스트.COMMAND LINE HEROES PODCAST Mithril.js 2: 굉장한 어플리케이션을 만들기 위한 자바스크립트 프레임워크 Mithril은 Vue, React 또는 Angular와 같은 것들에 대한 정말 깔끔한 대안이다. 매우 작고 빠르며(모바일에 맞는) 대안보다 Vanilla JS에 조금 더 가깝게 동작하고, 자체 대안이 필요하지 않고 Vanilla JS 라이브러리를 묶는 데에도 좋다. 2.0는 큰 릴리스로 축하한다.MITHRIL 개발자들을 위한 이미지 &amp; 비디오 관리 모든 장치에서 모든 대역폭에서 이미지 및 비디오를 업로드, 조작, 최적화 및 전송하는 프로세스를 단순화하고 자동화하십시오. Cloudinary를 사용해 보십시오. 미디어 관리가 얼마나 쉬운지 알아보십시오. 오늘 무료 계정을 만드십시오.CLOUDINARY SPONSOR 자바스크립트를 작성하는 실용적인 방법 당신이 모든 것에 반드시 동의하는 것은 아니겠지만(예: “타입스크립트 사용하자!”), 전반적으로 생각해 볼 수 있는 상당히 견고한 배치의 글.RYLAND GOLDSTEIN Stage 3에 들어간 옵셔널 체이닝(Optional Chaining)과 Nullish Coalescing 새로운 자바스크립트 기능들은 공식화되기 전에 다양한 단계를 거치고 있으며, 이 ‘?.’ 연산자는 당신이 체인된 속성이나 함수 호출을 선택적으로 할 수 있도록 하는 것으로 이제 표준으로 만들어지기 직전에 있다. 3단계도? Nullish Coalescing!ECMA TC39 타입스크립트 3.6 베타 공지 기능 완료, 몇 주 후에 최종 출시 예정.DANIEL ROSENWASSER (MICROSOFT) 💻 채용 공고시니어 프론트엔드 엔지니어 - 뉴욕 우리의 임무는 재정을 고치는 것. 엔지니어링 팀에 참여하여 강력하고 강력한 금융 애플리케이션을 위한 플랫폼을 구축하십시오.ADDEPAR 풀스택 시니어 소프트웨어 &amp; 마케팅 엔지니어 전 세계 운동선수와 코치가 훈련을 분석하고 계획하는 데 도움이 되는 브랜드에 여러분의 엔지니어링 능력을 접목시키십시오.TRAININGPEAKS Vettery를 통한 취업 Vettery는 최고의 기술 인재를 성장하는 회사와 연결한다. 시작하려면 프로파일을 작성하십시오.VETTERY 📘 튜토리얼, 오피니언, 영상 139 바이트의 자바스크립트로 구현된 Mini Black Hole 해부 이것은 아주 작은 (인정하건대 엄청나게 작은) 자바스크립트 코드를 아주 깔끔하게 탐구한 것이다.FRANK FORCE React의 기본 React에서 알아야 할 모든 기본 개념을 다루는 항상 최신의 한방(원스톱 숍) 소개 가이드. P.S. 우리는 또한 React 모든 것에 초점을 맞춘 React 뉴스레터를 가지고 있다!SAMER BUNA IDE As-You-Type의 즉각적인 자바스크립트/타입스크립트 테스트 피드백 Wallaby.js는 입력하는 즉시 테스트를 실행하는 개발자 생산성 도구로서 코드 옆에 있는 편집기에서 결과를 강조한다.WALLABY.JS SPONSOR ▶ Vue.js 3.0에서 제공되는 새로운 굉장함 Vue의 다음 주요 버전에 대해 Vue.js의 핵심 팀원인 Chris Fritz와 한 시간 동안 이야기를 나누었다.DEVMODE.FM PODCAST 재 작성이 아닌 경우: 데스크탑 슬랙 다시 만들기 채팅 서비스 슬랙이 어떻게 Electron 기반 클라이언트에서 아키텍처를 크게 개선했는지에 대해 간략히 살펴보았다.MARK CHRISTIAN AND JOHNNY RODGERS (SLACK) CSS-in-JS를 사용하는 방법을 왜 꼭 배워야 할까BRENT JACKSON 🔧 코드와 도구들 Tabulator: 대화형 테이블 및 데이터 그리드 라이브러리 모든 주요 브라우저를 지원하며 원하는 경우 Angular, Vue 및 React와 함께 사용할 수 있다.OLI FOLKERD CesiumJS: A Geospatial 3D Mapping and Virtual Globe Library 몇 년이 지났지만 (2016년에 처음으로 연결했습니다!) 요즘에는 많은 릴리스와 WebGL에 대한 보편적인 지원이 제공되므로 지구나 지도를 렌더링해야하는지 다시 확인해 볼 가치가 있습니다. GitHub 저장소. 데모들은 모두 매우 인상적입니다.CESIUM CONSORTIUM 안정적이고 덜 벗겨진 브라우저 자동화 경험 Taiko는 무료/오픈 소스 브라우저 자동화 도구로서 마지막 단계에서 안정적인 테스트를 수행한다.THOUGHTWORKS - TAIKO SPONSOR json-complete: 참조를 유지하고 순환 종속성 등을 처리하는 JSON 대안 상태를 인코딩하고 저장하는 흥미로운 방법을 제공하고 자바스크립트에서 사용 가능한 ‘거의 모든 데이터 유형’을 지원합니다.CIERELABS Vuetify 2.0 릴리스: Vue.js 머터리얼 컴포넌트 프레임워크 Google Material Design 원칙을 준수하는 Vue 앱에 깨끗하고 재사용 가능한 구성 요소를 제공하는 프레임워크. 시작하는 방법은 다음과 같다.VUETIFY.JS Moveable: 요소를 보다 쉽게 조작 할 수 있는 라이브러리 이것으로 요소에 이동, 드래그, 크기 조정 및 회전 기능을 추가하십시오.DAYBRUSH (YOUNKUE CHOI) Jay: ‘더 강력한’ 자바스크립트 REPL npm 레지스트리에서 직접 모듈로드, 열성적인 평가, 색상 입력, 브래킷 완성, 자동 완성 기능 등과 같은 기능을 추가하는 Node의 내장 REPL에 대한 흥미로운 대안입니다.MACIEJ ŁASZCZ Git 워크플로우에서 직접 JavaScript에 대한 자동화 된 코드 리뷰CODACY SPONSOR 자바스크립트의 고전적인 컴퓨터 과학 패러다임과 알고리즘 모음 7가지의 데이터 구조와 5가지의 정렬 방식 포함NICHOLAS C. ZAKAS Treat: 주제별, 정적으로 추출된 CSS-in-JSSEEK ⚡️ 릴리스 요약 ESLint 6.1 — 자바스크립트를 무료로 개선하는 도구. Node 12.7.0 — 여전히 우리가 좋아하는 서버 JS 플랫폼. Anime 3.1 — 경량 애니메이션 라이브러리. Lighthouse 5.2 — 당신의 페이지에 대한 강력한 성능 통찰력. 추신. 우리가 트위터에 있는 것 알고 있었습니까? @JavaScriptDaily 팔로우해주세요.","link":"/blog/2019/08/10/JavaScript-Weekly-447/"},{"title":"주간 자바스크립트 #448","text":"Electron 6, String#replace 트릭과 JS에서의 스코프 학습JavaScript Weekly Issue 448: August 2, 2019본문: https://javascriptweekly.com/issues/448 Hotkey: 키보드에서 ‘핫키’가 눌렸을 때, 요소에 동작을 트리거하는 것 페이지의 요소에 대한 빠르고 간단한 바로 가기 키를 원하십니까? data-hotkey 특성을 설정하고 핫키를 사용하십시오. 순차적으로 누르는 여러 개의 키를 지원하기도 한다. GitHub를 구축하여 사용(GitHub 페이지에서 소스 확인 및 data-hotkey 속성 확인)GITHUB Electron 6.0 릴리스 버전 5가 출시된 지 3개월 만에, 인기있는 JavaScript 기반 크로스 플랫폼 데스크탑 앱 구축 플랫폼은 버전 6에 도달했고 Chromium 76, Node 12.4 및 V8 7.6을 사용한다.ELECTRON.JS TEAM Jason Lengstorf와 함께 Gatsby 과정 소개 기본적으로 Gatsby를 사용하여 굉장히 🔥 빠른 웹 사이트를 구축하십시오. 이 과정에서는, 당신은 처음부터 블로그를 만들고, 당신의 새로운 블로그를 Netlify로 배포하여 세계가 볼 수 있도록 할 것이다!FRONTEND MASTERS SPONSOR 당신은 String.prototype.replace가 치환 패턴을 지원하는지 알고 있습니까? 약간 Perl처럼 느껴지지만, 이것은 내가 전에 자바스크립트에서 본 적이 없는 흥미로운 기능이다. (MDN에 문서가 있음에도 불구하고) 예시: 'abc'.replace('b', '$&amp;-$&amp;') === 'ab-bc'.STEFAN JUDIS 간단한 MVC 앱을 플레인 자바스크립트로 만들기 만약 여러분이 React, Angular, Mithrill, Ember, 그리고 나머지 것들에 대해 듣는 것에 싫증이 나서 자바스크립트를 쓰고 싶다면, 이것은 여러분을 위한 것이다. (궁극적으로, 그러한 모든 프레임워크들은 매우 유용하지만 그것들 없이 먼저 작업할 수 있다는 것은 그들이 하는 것에 감사하는 데 도움이 될 것이다!)TANIA RASCIA Comlink로 메인 스레드에서의 Redux 해제 Web Workers를 주의깊게 사용하면 UI 스레드에서 계산을 제거하여 주요 UX 및 성능상의 이점을 얻을 수 있다. 여기 Redux를 사용할 때 할 수 있는 한 가지 방법이 있다.SURMA 짧은 소식들 VueConf US 2020가 3월 2-4일 Texas에 Austin에서 열린다. CFP는 9월 1일에 열린다. Ember 프로젝트가 그들의 미래를 위한 로드맵을 발표했다. Amazon Transcribe, AWS의 speech-to-text 서비스가 앞으로 웹소켓을 통한 스트리밍과 실시간 녹음을 지원한다. Chrome은 앞으로 ‘www’ 서브 도메인과 ‘https’ 형식을 URL이 쉽게 읽힐 수 있도록 주소창에서 숨기려한다. Kyle Simpson가 그의 유명한 책 시리즈인 You Don’t Know JavaScript의 2번째 에디션 작업을 시작했다. 💻 채용 공고채용 공고는 따로 번역하지 않습니다. JavaScript Developer at X-Team (Remote)Join the most energizing community for developers. Work from anywhere with the world’s leading brands.X-TEAM Front-end EngineerGoldstar is looking for front-end Engineers with React experience on-site in Portland, Oregon and Pasadena, California.GOLDSTAR Get Hired Based on Your Skills Not Your CVOur AI makes it easier and quicker to match with top JavaScript jobs, with no recruiters and an average salary of £70k.HACKAJOB 📘 튜토리얼, 오피니언, 영상 ▶ 자바스크립트에서 스코프에 대해 알아보자 구글의 역동적인 자바스크립트 듀오 Jake와 Surma가 태블릿 기반의 데모를 완성한 변수 스코프와 관련된 재미있는 대화를 선보이고 있다.GOOGLE CHROME DEVELOPERS 옵셔널 체이닝에 대한 ES 제안 보기 당신이 알아야 할 필수 사항으로 제안을 요약한다.DR. AXEL RAUSCHMAYER 필요한 측정 지표를 잃지 않기 위한 개발자 가이드 측정 지표를 수집하고 저장하는 것은 생산의 일부분이다. 안좋은 사건이 발생할 때, 당신은 문제를 디버깅하기 위해 이용할 수 있는 지표를 가질 필요가 있다.INFLUXDATA SPONSOR React Hook이 Redux를 대체하는가? 이 질문은 최근 커뮤니티에서 훅(hook) 사용 사례가 증가함에 따라 자주 제기되었다. 그러나 Eric의 TLDR은 ‘훅은 위대하지만, 대체할 수 없다’이며, 그 이유를 심도 있게 설명한다.ERIC ELLIOTT Vuetify 2.0 시작하기 Vuetify는 Vue.js를 위한 머터리얼 디자인 기반 구성요소 라이브러리이다.BEN HONG Jest를 사용한 유닛 테스트 시 Mock 사용을 위한 빠른 팁DANIEL CALDAS 자바스크립트에서 최상위 함수들 왜 1등 시민으로서의 기능(즉, 그 나름대로의 물건으로서)을 취급할 수 있는지 궁금해 하는 초심자를 대상으로 하는 간단한 튜토리얼은 장점이 있다.NICK SCIALLI 상위 10개의 GitHub 모범 사례 - 수천 개의 저장소에서 얻은 교훈DATREE.IO SPONSOR 나의 VS Code 설정: VS Code를 최대한 활용 VS Code 사용자라면 고려할만한 추가 기능 및 툴.DEEPU K SASIDHARAN RxJS Observable을 이해하고 왜 필요한지 RxJS는 ‘observables’을 기반으로 하는 반응형 프로그래밍 라이브러리로서, Angular가 반응성을 위해 사용한다. 따로 쓸 수도 있다.NWOSE LOTANNA 🔧 코드와 도구들Hackathon Starter: Node 웹 앱용 보일러 플레이트 필요한 거의 모든 것이 포함되어 있기 때문에 (해커톤과 같은) Node 앱을 빠르게 만들기 시작할 때 사용하는 보일러 플레이트.SAHAT YALKABOV Esprint: 여러 스레드 간에 ESLint를 실행하여 성능 향상 이것은 ESLint로 통합될 수 있다고 여겨져 왔다.PINTEREST 병합하기 전에 코드가 오류 없는지 확인하십시오 적용 범위, 중복, 복잡성 및 스타일 문제에 대한 표준을 설정하고 Git 워크플로우에서 실시간 피드백을 확인하십시오.CODACY SPONSOR Treeverse: 트리 구조를 깊이 또는 면적을 먼저 걷기ISAAC Z SCHLUETER Rollup: 최신 ES6 모듈 번들러 새로운 프로젝트는 아니지만, 최근에 많이 릴리스되고 있다. ES 모듈을 사용하여 코드를 작성하고 트리 흔들기/죽은 코드를 삭제하고 필요한 형식으로 번들링하십시오. Rollup이 더 인기 있는 대안들에 비해 이긴 것 중 하나는 속도다.ROLLUP CONTRIBUTORS WebStorm 및 IntelliJ용 자바스크립트 플러그인 상위 25개ILANA BRUDO ⚡️ 릴리스 요약 Font Awesome 5.10.0 — 유명한 아이콘 툴킷. webpack 4.39.0 — ‘웬만한 건 빼고 거의 다 있는’ 번들러. TUI Editor 1.4.5 — 마크다운 기반의 WYSIWYG 에디터. Spectacle 5.7 — \\React.js 기반 프레젠테이션 라이브러리. Duktape 2.4 — C/C++ 프로젝트를 위한 내장형 자바스크립트 엔진.","link":"/blog/2019/09/01/JavaScript-Weekly-448/"},{"title":"12 Jira Features from 2021","text":"2021에 업데이트된 12가지 Jira Featurehttps://community.atlassian.com/t5/Jira-articles/December-to-Remember-12-Jira-features-from-2021/ba-p/1873465 Jira 커뮤니티에 올라온 Jira 기능 업데이트 소개글이 있어 가져와봤습니다.Jira Cloud에 업데이트된 기능들의 소개글이니 참고해서 봐주세요. 1. “Done(완료)” 상태 추가 기능그동안 Done(완료) 상태 밖에 없었는데 원하는 상태명으로 완료 카테고리 상태를 추가할 수 있게되었습니다. Learn more 2. 리스트 뷰 - 이슈 네비게이터에서 이슈 상태 업데이트 가능!이슈를 열어서 상태 변경하지 않고 리스트뷰 상에서 상태 업데이트가 가능하도록 업데이트되었습니다. Learn more 3. 드래그 &amp; 드랍으로 이슈를 로드맵에서 관리로드맵 기능에서 태스크를 생성하고 드래그 &amp; 드랍으로 태스크 순서를 조정하는 등 태스크를 관리할 수 있습니다. Learn more 4. 다른 프로젝트로 이슈 레이아웃 복사프로젝트를 복사하거나 동일하게 이슈 레이아웃을 만들기 위해 이슈 레이아웃 복사 기능이 추가되었네요. Learn more 5. Reopen closed sprints 끝난 스프린트 다시 열기완료된 스프린트를 다시 열 수 있도록 기능이 추가되었네요.실수로 완료되었거나 일정이 연장되는 등 이슈가 있는 스프린트을 다시 열 수 있도록 추가된 것 같습니다. Learn more 6. Estimation 기능을 통한 진행도 확인스토리 포인트, 시간 등 기존에 태스크 관리하던 데이터를 통해 작업의 진행도를 확인할 수 있는 estimation이 추가되었습니다. Learn more 7. 이슈 타입별 워크플로우 추가21년 중순까지는 이슈 타입별로 워크플로우 추가할 수 있는 기능이 없었는데 4분기쯤에 업데이트가 이뤄졌나보네요. 이슈 타입별로 워크플로우 설정하는 것은 서버버전에는 기본적으로 있었는데 클라우드 버전에 추가되었다니 다행이네요. Learn more 8. 컨텍스트 뷰 업데이트필요한 정보를 오른쪽 뷰에서 볼지 중간 뷰에서 볼지 설정할 수 있도록 업데이트가 되었습니다.자세한 설정은 프로젝트 설정 &gt; 이슈 레이아웃에서 해볼 수 있습니다. Learn more 9. Your Work(내 작업)에 “Assigned to me(나에게 할당됨)” 추가나에게 할당된 작업들을 바로 볼 수 있는 기능이 추가되었습니다. 기존에 대시보드를 통해 내 작업을 보던 사용자는 이게 유용한 기능일지 모르겠네요. 😈 10. JQL 에디터 업데이트JQL을 이용한 이슈 검색에 유용한 에디터 업데이트가 이뤄졌습니다. 하이라이트 기능이나 자동완성 등이 깔끔하게 반영되었네요. 서버 버전에도 반영해주면 좋겠.. Learn more 11. 공지 배너공지 배너에 대한 기능이 추가되었습니다. 닫을 수 있는 배너로 설정할 수도 있게 추가되었네요. 🤩 Learn more 12. 사이드바 네비게이션 개선사이드바에서 보이는 메뉴의 우선순위 등을 조정한 것 같네요. 차세대 프로젝트에서는 볼 수 없고 기존 프로젝트에서 보드에 연결된 메뉴들을 따로 보거나할 수 있는 것 같습니다. Learn more 마무리21년 말에 작성된 글인데 이제 슬쩍보고 정리해볼 수 있었네요.내용 대부분은 차세대 프로젝트에서 설정할 수 있는 내용이기보다 기존 프로젝트에서 사용할 수 있는 기능들이었던 것 같습니다. 서버 버전 업데이트는 없지만 클라우드 Jira도 슬슬 쓸만한 상황인건가 싶기도한데 개인 프로젝트나 일 정리할 때 써보면서 업무에 적용할 수 있을지 한번 조금씩 봐야겠습니다. 😁","link":"/blog/2022/01/14/Jira-12-features-2021/"},{"title":"Jira 7.11 to 8.0 Upgrade","text":"Jira 7.11 to 8.0 Upgrade SpecsJira Software(서버 설치버전)을 사용하면서 7.11에서 8.0으로 버전 업그레이드될 때정리해보았던 내용을 포스트해봅니다. 사전 참고 링크 Jira 릴리즈 노트: Jira Software release notes 각 버전별 릴리즈 노트를 볼 수 있으며 버전별 업그레이드 문서도 함께 있습니다 Jira 버전별 업그레이드 매트릭스: Upgrade matrix 각 업그레이드 버전 항목 별로 간단하게 내용이 정리되어있는 표가 있습니다 각 버전 별 변경 사항사내에서 기존에 사용했던 Jira 버전은 7.11 버전이었는데 8.0으로 업그레이드했습니다이 업그레이드에는 7.12, 7.13, 8.0 수정사항이 모두 반영되어서 변경 사항에 대해 정리해보았습니다각 변경 내용은 릴리즈 노트에 기반하여 정리하였습니다 7.12 변경 내용jira-software-7-12-x-release-notes New look and feel of the Custom fields page 어드민 기능 수정 내용으로 설정 &gt; Fields &gt; Custom fields 간략하게 볼 수 있는 내용 커스텀 필드가 적용된 프로젝트, 스크린을 한가득 보던 화면을 최적화해서 어드민 QoL 기능 Share edit rights for filters and dashboards 필터 수정 권한을 추가로 설정할 수 있는 기능 추가 필터를 다른 사람도 수정할 수 있게 된 것이 매우매우 좋다! More search power Development 관련 검색 기능 추가 (Open PR, Merged PR, Failling builds, Passed builds 등등) 작업이 어떻게 진행되고 있는지 파악하기 좋을 것으로 보임 Boost Jira performance 보드에 있는 이슈의 수를 보여주는 것이 느리게 만드는 데 그 숫자를 안보이게하면 빠르게 할 수 있음 컬럼에서 얼마나 머물러 있었는지 볼 수 있는 내용도 끌 수 있는데 끄면 성능을 개선할 수 있음 다만 이 기능을 사용할 경우 보드에서 이슈가 얼마나 있는지, 얼마나 그 상태에 머물러 있었는지 알 수 없어서 불편할 것으로 예상됨 그 외의 버그 수정 다수7.13 변경 내용jira-software-7-13-x-release-notes AdoptOpenJDK 8 comes to Jira 내부 개발 플랫폼 내용이라 자세히 알 필요는 없음 End of year Enterprise release roundup 공식 릴리즈에 대한 이야기 Enterprise releases, performance-wise 성능 향상 - performance-and-scale-testing-966063698.html 7.12와 비교했을때 눈에 띄는 성능 향상은 아니지만 7.6 버전에 비하면 성능 향상이 이뤄졌음 (하지만 기존에 사용하고 있던 버전도 낮은 버전은 아니어서 큰 성능 차이를 느끼지 못했습니다) 8.0 변경 내용jira-software-8-0-x-release-notes Look and feel: Scrum and Kanban 보드의 외형이 바뀌었음 카드 정보를 어떻게 설정하여 보여줄 수 있을지 봐야할 것 Better email notifications 이메일이 너무 많이 와서 압도되는 것을 줄여보고자 했음 예시로는 10분간의 알림 사항을 모아서 메일주는 것을 보여줌 설정 &gt; System &gt; Batching email notifications 에서 설정 가능 상세 내용: configuring-email-notifications 댓글의 수정 내용이 계속 오는 것이 아닌 정리되서 와서 좋았던 기능 Significant backlogs load faster 백로그 로딩 시간이 줄어들었음 몇개를 샘플링해서 보여주고 추가적으로 로딩할 수 있도록 하여 로딩 속도 개선한 것으로 보임 Dropping Linked pages count to boost performance 이슈에 링크되어있는 페이지의 숫자를 보여주지 않는 것으로 성능 향상 New priority icons 새로운 priority 아이콘 추가 (리뉴얼 되었음) New options in advanced search Find authors (updatedBy) UpdatedBy() guide 어떤 사용자가 업데이트했는지 알 수 있음. 추가로 특정 시간부터 또는 특정 시간 동안 수정했는지 알 수 있음. Find link types (issueLinkType) issueLinkType guide 링크된 타입에 따라 이슈를 검색해볼 수 있음 Massive performance improvements 보드, 백로그가 보이는데 걸리는 시간이 62%, 87%까지 빨라졌음 JQL 프로세싱 과정은 33% 빨라졌음 보드 브라우징은 16% 빨라졌음 Faster indexing 리인덱싱 속도가 71% 빨라졌음 인덱스의 크기가 줄어들어 인덱싱에 부담을 덜었음 인덱싱 관련 최적화가 되었음 (실제로도 각 프로젝트에서 인덱싱할 때에 다른 프로젝트에서 영향 받지 않고 빠르게 된 것을 확인했습니다) REST API for issue type schemes 이슈 타입 스킴(Scheme)을 REST API로 수정할 수 있게 되었습니다. jira/docs/api/REST/8.1.0/#api/2/issuetypescheme Misc(Bonus resources) Small improvements to make your day 4 Byte characters 지원 add-ons → apps 이름 변경 Using sprints when your backlog isn’t sorted by rank (백로그가 rank로 정렬되지 않아도 스프린트 사용 가능) 성능 및 스케일 테스트 performance-and-scaling 보안 관련 페이지 JIRA Server mobile App 지원 (베타 앱으로 지원되고 있어서 베타로 깔아야 함) Android: https://play.google.com/apps/testing/com.atlassian.jira.server iOS: https://testflight.apple.com/join/6JbjYbSY Pre-upgrade planning page 추가 설정 &gt; Applications &gt; Plan your upgrade 기능으로 볼 수 있음 그 외의 버그 수정 다수 업그레이드 버전 별 정리 후기PM 업무를 하면서 Jira를 어떻게하면 더 잘 사용할 수 있을지, 개발 프로세스에 어떻게 잘 녹여낼지고민하다보니 Jira 시스템도 많이 보게되어 정리하게 되었네요.8.0 업그레이드를 했으니 곧 8.1, 8.2 업그레이드 릴리즈 노트도 정리해서 포스트 해보겠습니다.","link":"/blog/2019/07/13/Jira-7-11-to-8-0-Upgrade/"},{"title":"Jira Software 8.1 릴리스 노트","text":"Jira Software 8.1 릴리스 노트Jira Software 8.1.x 릴리스 노트: https://confluence.atlassian.com/jirasoftware/jira-software-8-1-x-release-notes-966669112.html 지난 4월에 릴리스된 Jira Software 8.1 기능에 대해 살펴보는 포스트입니다.위 릴리스 노트에서 자세한 내용을 보실 수 있으며, 이 포스트는 주관적인 생각을 담고 있습니다. 하이라이트하이라이트 기능으로는 아래 리스트와 같습니다. 하나하나 살펴보겠습니다! Issue archiving (Jira Data Center) Managing old components Development info on issue cards Flexible boards More performance improvements Jira Data Center on Microsoft Azure New JMX metrics Small improvements to make your day Resolved issues Issue archiving (Jira Data Center) 위 이미지 처럼 이슈를 아카이브 할 수 있는 기능입니다. 다만 Data center만 가능한 기능입니다.자세한 내용은 아래 링크를 참고하세요.https://confluence.atlassian.com/adminjiraserver/archiving-an-issue-968669980.html Managing old components 기존에는 컴포넌트를 삭제하는 방식으로 컴포넌트를 관리할 수 있었는데 한가지 추가 옵션이 생겼습니다.아카이브하여 해당 컴포넌트는 아카이브되었다는 것을 보여줄 수 있게 되었네요.입력된 컴포넌트가 아카이브될 경우, 선택 옵션에서는 선택할 수 없으나 이미 입력된 것은 유지됩니다. Development info on issue cards 이제 칸반, 스프린트 보드에서 이슈 카드에서 커밋되었거나 브랜치가 생성된 내역을 볼 수 있습니다.이 기능은 커밋 내역을 트래킹하여 보여주는 서비스가 연결되어 있을 경우 볼 수 있겠군요.(예: Fisheye, Crucible, Bitbucket) 이미지 상으로는 커밋 내역과 브랜치, 리뷰가 완료되었는지 진행 중인지 알 수 있겠네요.배포 관련 내용은 bitbucket과 관련 내용인지 봐야할 것 같기는 합니다.(정확한 것은 모르겠지만 아틀라시안 제품과 연동이 잘 되어 있을 것으로 예상합니다) Flexible boards 보드에서 오른쪽에 이슈 카드의 디테일 내용을 볼 때 가로의 크기가 정해져 있어 보기 힘들었던 것을옆으로 늘려서 볼 수 있도록 개선한 내용입니다. (QoL 내용 같네요. ㅎㅎ) More performance improvements항상 열심히 성능 개선에 힘쓰고 있는 아틀라시안!이번에도 성능 개선 소식이 있네요. 보드 피커 개선보드 페이지를 열 때 마다 모든 보드 리스트를 가져왔는데 그렇게 하지 않도록 개선했다고 합니다.보드를 고를 때는 차이가 나지 않지만, 다른 페이지에서는 성능 상 효과가 있을 것이라고 하네요. :) 이슈 카드 색깔 설정 속도 개선보드에서 JQL에 따라 카드에 색깔을 넣을 수 있는 기능을 개선했다는 내용입니다.내부 로직을 개선한 내용으로 색깔을 입히는데에 더 효율적으로 계산한다고 하네요. Jira Data Center on Microsoft AzureJira Data Center 버전-MS Azure 배포 템플릿을 개선했다고 합니다.(사실 데이터 센터 버전을 사용하지 않아서 잘 모르겠지만 8.1 버전 외에 다 적용되는 사항이라고 합니다.) New JMX metricsJira 성능을 보기 위해서 JMX라는 매트릭스를 도입했다고 합니다.자세한 것은 이 링크(Live monitoring using the JMX interface)에 있네요.다만 이 기능은 모니티링도 성능에 영향을 줄 수 있으니 1초에 한번정도만 새로고침하라고 경고하네요. :)기능을 켜면 Administration &gt; System &gt; System info 밑에 Instrumentation이라는 메뉴가 나타납니다. Small improvements to make your day작은 개선 사항이지만 우리에게는 꿀맛같은 개선사항입니다.(이번에는 그렇게 많지는 않군요.) Sorting projects by columns 이미지 처럼 각 컬럼 별로 여러 프로젝트를 소팅해서 볼 수 있습니다.프로젝트가 많지 않으면 와닿지 않겠지만 프로젝트가 많을 경우에는 좋을 것 같네요! Additional custom fields in batched email notifications특정 커스텀 필드를 이메일 알림에 포함하는 것을 조정할 수 있는 기능이 추가되었다고 합니다.기능은 심플한데 설정하기에는 까다로운 것 같네요. 참고 링크나중에 한번 해보고 정리해서 따로 포스트 작성해보겠습니다. 그 외에는 계정 로그인, 로그아웃 시간을 볼 수 있는 기능과 아바타 이미지가 추가된 것이 있네요.버그 수정 사항은 따로 다루지 않겠습니다. 마무리8.0에도 변경사항이 많았는데 8.1도 변경 사항이 많았네요.글을 작성하면서 QoL이 되었으면 하는 것 중 프로젝트 별 이슈 필드 리스트 개선이 언젠가는 생기겠지하는 생각을 했네요.잡생각을 마무리하며, 포스트 마치겠습니다.","link":"/blog/2019/09/02/Jira-8-1-Upgrade-Contents/"},{"title":"Jira 클라우드 무료 플랜 사용하기 (Jira Software Cloud Free Plan)","text":"Jira Software Cloud Free Plan!https://www.atlassian.com/ko/software/jira/free Jira 클라우드 버전에 대해서 무료(Free) 플랜이 생긴 것은 생각보다 오래되었습니다.작년인 2019년 10월부터 무료 플랜이 공개되었고 위와 같은 조합으로 사용해볼 수 있도록 공개되었죠. 저는 여기서 Jira Software만 사용하고 있습니다. 한국어 번역이 되어서 이상해보이지만설명서는 Confluence, 지원 센터는 Service Desk를 의미합니다.(아래에 다 나와있긴하네요. 😅) 제가 진행했던 것 처럼 Jira Software의 무료 플랜 설정이 어떻게 되는지 소개하고자 합니다. Jira Software Cloud Start “하나만 선택”으로 진행하면 위와 같은 화면을 보실 수 있습니다.Free 플랜은 아래와 같은 조건으로 사용할 수 있어요. Free 옵션 Free 기능 사용 기본적인 기능은 다 동작한다고 보시면 됩니다. Free 기능이라고 해도 제약이 있는 것은 별로 없습니다. 2GB 저장 공간 첨부 파일을 많이 사용한다고 하면 제약이 있을 수 있겠지만 이미지, 동영상은 되도록 다른 곳에 올린다면 큰 문제는 없는 용량입니다. 최대 10명 사용자 작은 스타트업, 테스트 용도로 적합한 사용자 수 입니다. 커뮤니티 지원 커뮤니티는 그냥도 열려있으니 패스! 설정 항목 이메일: 기존에 아틀라시안(Atlassian) 계정이 있다면 그것으로 사용하셔도 됩니다. 없다면 생성! 아틀라시안 계정은 Google 또는 Microsoft 계정으로 생성하여 사용할 수 있습니다. 이름, 성: 이름 입력해주시면 됩니다. 사이트 이름: Jira software를 사용하게 될 URL을 입력합니다. 저는 저의 닉네임인 pineoc를 입력했습니다. 참고, 사이트 이름은 3자 이상이어야 합니다. Create!모든 입력을 마친 후 “동의 후 가입” 버튼을 누르면 몇가지 질문을 합니다. (스킵하셔도 괜찮습니다)그 이후에 팀초대 항목을 보실 수 있습니다. (이것도 스킵 가능합니다.) 그리고 이후에 나오는 질문에 따라 프로젝트 유형을 추천받을 수 있습니다. 저는 제가 답변한 내용을 기반으로 차세대 템플릿, 칸반으로 추천받았습니다. 추천받은 프로젝트 유형으로 해도 괜찮고 따로 원하는 유형으로 해도 괜찮습니다.차세대 템플릿(Next-gen Template)은 최근 나온 템플릿인데 기존에 있던 프로젝트 템플릿보다는 기능들이 추가된 것들이 있어서 사용해보시는 것도 추천드립니다.이전 프로젝트 템플릿이 필요하실 경우 밑에 **”클래식 템플릿 탐색”**을 눌러서 기존 프로젝트 템플릿을 사용하실 수도 있습니다. 각각의 템플릿에 대한 설명은 “여기에는 무엇이 포함됩니까?” 메뉴를 누르면 보실 수 있습니다. 😀 Jira project create 프로젝트 템플릿 중 하나를 선택하면 프로젝트 이름, 프로젝트 키를 입력하여 프로젝트를 생성할 수 있습니다.여기서 프로젝트 키는 이슈가 만들어질때 앞에 붙을 프로젝트 ID prefix로 이해하시면 됩니다.PINO-1, PINO-1234 이런식으로 키를 PINO로 설정할 경우 이슈 ID 앞에 PINO가 붙게됩니다. 여기까지 오셨다면 프로젝트 생성까지 끝났습니다. 👏Jira의 세계에 오신 것을 환영합니다! 마무리Jira를 기존에 서버 설치 버전을 사용하고 있었는데 Cloud 버전을 무료 플랜으로 사용해보게되었습니다.그런 와중에 무료 플랜에 대한 글들이 많이 없어서 다른분들이 사용해보실 수 있도록 소개해보았습니다.설정 중에 문제가 발생한다면 facebook에 Atlassian User Group(Seoul)에 문의주시면 많은 분들이 같이 봐주실겁니다.이만 마치겠습니다. 긴글 읽어주셔서 감사합니다. 👍","link":"/blog/2020/06/18/Jira-Cloud-Free-Plan/"},{"title":"Jira Bulk remove issue links (by link type)","text":"Jira 이슈 링크(issue link) 삭제하기관련 포스트: Bulk remove change Jira issue links위 포스트에서는 이슈에 걸려있는 모든 링크를 삭제하는 것을 공유드렸었습니다.이번 포스트에서는 이슈에 걸려있는 링크 중에 특정 타입의 링크를 삭제하는 방법을 공유해보겠습니다. 이슈 - 이슈 링크Jira에서 이슈와 이슈를 연결해주는 이슈 링크,전의 포스트에서는 링크를 그냥 다 삭제하는 포스트였기에 자세히 다루지는 않았지만 이번 포스트에서는 링크 타입에 대해 알아야 정확하게 삭제할 수 있기에 조금 더 자세히 설명해보고자 합니다. 위와 같이 이슈 링크 속성에는 Name, Outward Description, Inward Description 항목이 있습니다. 한국어 버전으로는 이슈 링크 속성 이름이 명확한지 모르겠지만 다음과 같네요. 이름(Name), 가르키는 입장 설명(Outward Desc), 받는 입장 설명(Inward Desc) Jira 시스템에 기본적으로 있는 이슈 링크 타입은 4개로 Blocks, Cloners, Duplicate, Relates 이렇게 구성되어 있습니다.각각 링크 타입 항목들을 보면 이슈와 이슈를 연결했을 때 각 이슈에 보이는 링크의 이름이 다르게 보일 수 있도록 설정할 수 있습니다. 이슈 링크를 설정하고 어떻게 보이는지 아래의 문서 링크를 참고하시면 좋을 것 같습니다.(EN) Jira Docs: linking issues “이슈 - 이슈 링크”의 관계를 정리해보자면, 아래와 같이 볼 수 있겠습니다. 이슈는 목적지 이슈 링크는 출발지와 도착지 정보를 가지고 있는 화살표 이슈 링크 타입 확인해보자개념적인 설명은 이만 마치고 스크립트를 통해 이슈에 있는 이슈 링크들을 한번 확인해보겠습니다.우선 테스트를 위해 이슈에 설정한 이슈 링크들은 아래와 같습니다. 링크된 항목들을 정리해보면 다음과 같습니다. 괄호 내용은 이슈 링크 이름입니다. PUB-16 (blocks) PUB-1 PUB-16 (blocks) PUB-2 PUB-16 (blocks) PUB-3 PUB-16 (clones) PUB-5570 PUB-16 (duplicates) PUB-17 PUB-16 (is blocked by) PUB-4 PUB-16 이슈에 연결된 이슈 링크들을 확인하기 위한 스크립트 입니다.스크립트를 ScriptRunner에 Script console에서 실행된 내용을 볼 수 있습니다. 스크립트 코드12345678910111213141516171819202122232425262728import com.atlassian.jira.component.ComponentAccessorimport com.atlassian.jira.issue.IssueManagerimport com.atlassian.jira.jql.parser.JqlQueryParserimport com.atlassian.jira.bc.issue.search.SearchServiceimport com.atlassian.jira.web.bean.PagerFilterimport com.atlassian.query.Querydef searchService = ComponentAccessor.getComponent(SearchService)def jqlQueryParser = ComponentAccessor.getComponent(JqlQueryParser)def user = ComponentAccessor.getJiraAuthenticationContext().getLoggedInUser()def results = searchService.search(user, jqlQueryParser.parseQuery(&quot;key=PUB-16&quot;), PagerFilter.getUnlimitedFilter())def issueManager = ComponentAccessor.getIssueManager()def issueLinkManager = ComponentAccessor.getIssueLinkManager()results.getResults().each{ def issue = issueManager.getIssueObject(it.id) log.warn(&quot;Get InwardLinks&quot;) def linkInwardList = issueLinkManager.getInwardLinks(issue.getId()) linkInwardList.each { log.warn(&quot;${it.getIssueLinkType().getName()}, ${it.getSourceObject().getKey()}&quot;) } log.warn(&quot;Get OutwardLinks&quot;) def linkOutwardList = issueLinkManager.getOutwardLinks(issue.getId()) linkOutwardList.each { log.warn(&quot;${it.getIssueLinkType().getName()}, ${it.getDestinationObject().getKey()}&quot;) }} 스크립트 실행 결과12345678...: Get InwardLinks...: Blocks, PUB-4...: Duplicate, PUB-17...: Get OutwardLinks...: Blocks, PUB-1...: Blocks, PUB-2...: Blocks, PUB-3...: Clones, PUB-5570 이슈 링크 타입에 따라 이슈 링크를 삭제해보자이슈 링크 타입을 확인했으니 이슈 링크 타입에 따라 삭제할 수 있게 되었습니다.사실 위 링크 확인 스크립트 코드에서 타입과 inward/outward 만 확인해서 이슈 링크 삭제 함수만 사용하면 우리가 원하는 링크 삭제가 가능합니다. 이슈 링크 타입 확인 &amp; 삭제이슈 링크 타입을 확인하는 것 자체는 어렵지 않습니다.issueLinkObj.getIssueLinkType().getName()로 이름을 확인하면 되니까요.다만 Inward, Outward 링크 타입을 확인해야하는데, 삭제할 때에 아래 옵션을 선택할 수 있도록 함수를 만들어야겠네요. Inward 링크만 Outward 링크만 모든 링크 삭제 함수도 간단합니다. 참고: Jira API Docs: IssueLinkManager.removeIssueLink()아래 함수를 위에서 확인한 이슈 링크를 파라미터로 호출하면 링크 삭제가 가능합니다. 123// issueLink - the issue link to remove// remoteUser - needed for creation of change itemsvoid removeIssueLink(IssueLink issueLink, ApplicationUser remoteUser) 스크립트 코드123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.atlassian.jira.component.ComponentAccessorimport com.atlassian.jira.issue.IssueManagerimport com.atlassian.jira.jql.parser.JqlQueryParserimport com.atlassian.jira.bc.issue.search.SearchServiceimport com.atlassian.jira.web.bean.PagerFilterimport com.atlassian.query.Queryimport com.atlassian.jira.issue.MutableIssuedef searchService = ComponentAccessor.getComponent(SearchService)def jqlQueryParser = ComponentAccessor.getComponent(JqlQueryParser)def issueManager = ComponentAccessor.getIssueManager()def issueLinkManager = ComponentAccessor.getIssueLinkManager()def user = ComponentAccessor.getJiraAuthenticationContext().getLoggedInUser()// NOTE: jql optionsdef results = searchService.search(user, jqlQueryParser.parseQuery(&quot;key=PUBGTEST-3&quot;), PagerFilter.getUnlimitedFilter())// NOTE: remove link optionsdef removeLinkType = &quot;Blocks&quot;def removeLinkIO = &quot;all&quot; // all, inward, outwarddef removeInwardLinks = {MutableIssue issue -&gt; def linkInwardList = issueLinkManager.getInwardLinks(issue.getId()) linkInwardList.each { def link = it if (link.getIssueLinkType().getName() == removeLinkType) { log.warn(&quot;removed links: ${link.getIssueLinkType().getName()}, ${link.getSourceObject().getKey()}&quot;) issueLinkManager.removeIssueLink(link, user) } }}def removeOutwardLinks = {MutableIssue issue -&gt; def linkInwardList = issueLinkManager.getOutwardLinks(issue.getId()) linkInwardList.each { def link = it if (link.getIssueLinkType().getName() == removeLinkType) { log.warn(&quot;removed links: ${it.getIssueLinkType().getName()}, ${it.getDestinationObject().getKey()}&quot;) issueLinkManager.removeIssueLink(link, user) } }}results.getResults().each { def issue = issueManager.getIssueObject(it.id) if (removeLinkIO == &quot;all&quot; || removeLinkIO == &quot;inward&quot;) { log.warn(&quot;Get &amp; Remove InwardLinks&quot;) removeInwardLinks(issue) } if (removeLinkIO == &quot;all&quot; || removeLinkIO == &quot;outward&quot;) { log.warn(&quot;Get &amp; Remove OutwardLinks&quot;) removeOutwardLinks(issue) }} 스크립트 결과현재 스크립트 상으로는 all(inward, outward), blocks 타입의 링크만 삭제하도록 구성되어 있어 실행시 blocks 타입의 링크가 모두 삭제됩니다. 활용위 스크립트를 활용시에는 NOTE: 라고 표시된 내용에 링크 삭제가 필요한 이슈, 링크 타입을 알맞게 변경을 한 뒤에 사용하시면 됩니다.이슈 링크 삭제 시에 주의해서 사용해주세요! 마무리이번 내용은 약간 길어졌는데요. 포스트를 작성하면서 이슈와 이슈 링크의 관계, 이슈 링크의 속성 등에 대해서 공부할 수 있어서 좋았고 이 글을 보시는 다른분들도 스크립트를 이용하여 원하는 이슈 링크를 삭제할 수 있었으면 좋겠습니다.감사합니다. 😀","link":"/blog/2020/02/28/Jira-Bulk-remove-issue-links-by-link-type/"},{"title":"Jira Cloud Next Gen project (차세대 프로젝트) 둘러보기","text":"Jira 클라우드(Cloud)지난 포스트에서는 Jira 클라우드를 무료로 사용해볼 수 있는 방법을 소개해드렸었습니다.참고: Jira 클라우드 무료 플랜 사용하기 (Jira Software Cloud Free Plan)이어서 제가 개인 공부 겸, 사용해보고 있는 “차세대 프로젝트(Next Gen)”를 한번 둘러보고 소개드리고자 합니다. Jira Next Gen?현재 Jira에서 개발 진행중인 프로젝트 유형으로 기존 템플릿보다 심플한 유형입니다.이름도 차세대 프로젝트로 기존의 프로젝트 형태와는 다른 모습인데 자세한 내용은 둘러보면서 설명하겠습니다.(기본적인 기능들은 동일하지만, 다른 느낌정도로 이해해주시면 될 것 같습니다.) 차세대 프로젝트 둘러보기 Jira 프로젝트를 생성할 때 어떤 프로젝트 유형을 사용할지 고를 수 있습니다.클래식 프로젝트는 기존에 사용하던 유형이구요. 차세대 프로젝트가 우리가 살펴볼 프로젝트 유형입니다. 클래식 프로젝트 / 차세대 프로젝트 차이프로젝트 생성할 때 설명되어 있는 것을 정리해보았습니다.Classic, Next Gen 기능 상 차이점이 각 프로젝트 별 성격을 잘 보여주는 것 같네요. Type Classic Next Gen Team 여러 팀 간의 일관성 제어 민첩하고 독립적인 팀에 가장 적합함 Customize 전체 기능 집합, 고급 구성 제한된 기능 집합, 더 쉬운 설정 Admin 관리자가 설정 및 유지관리 누구든지 설정 및 유지 관리 가능 로드맵 x o advanced 로드맵 o x 카드 레이아웃 사용자 지정(카드 레이아웃 커스텀) o x 보고서(report) 20개 이상의 종류 4개 종류 예상치 o o (스토리 포인트만) 워크플로우 편집기 o x 병렬 스프린트 o x 세부 권한 o x 교차 프로젝트 설정 o x 빠른 필터(Quick Filter) o x 위 테이블 내용 중 차세대 프로젝트 기능은 현재 기준으로 기능이 정리되어있으며 아직 개발중인 것들이 많습니다.자세한 내용은 아래 링크에서 보실 수 있습니다.https://www.atlassian.com/ko/software/jira/whats-new/next-gen#overview 한 가지 다행인 것은, 워크플로우(Workflow) 편집기가 사라진 것은 아니며 아직 개발중인 상태로 2020년에 제공될 예정이라고 하네요. 프로젝트 유형 별로 기능에 대한 기본적인 소개 내용은 Jira 가이드 문서에도 잘 정리가 되어있었습니다.Jira Software 시작하기 가이드 문서 기본적인 기능, 차이점들을 보았으니 실제 모습을 한번 둘러보겠습니다. 프로젝트 보드 저는 우선 개인 작업을 관리하기 위해서 만든 것이어서 스크럼(Scrum)까지는 필요하지 않아 칸반(Kanban) 타입으로 보드를 만들었습니다.기본적인 컬럼 레이아웃, 기능은 클래식 유형과 거의 동일합니다. 다만 차이점에서 살펴보았듯이 몇가지 기능들이 없거나 간소화되었습니다.차세대 프로젝트에서의 기능을 기준으로 살펴보면 다음과 같습니다. 이슈의 그룹화 기준, 곧 **스윔레인(swimlane)**은 담당자, 에픽, 하위작업 정도로 나눌 수 있습니다. Classic에 있던 jql에 따라 스윔레인을 나누는 기능은 없습니다. 😂 보드 상단에 있던 빠른 필터(퀵 필터)가 없어서 보드 안에서 특정 조건의 이슈들을 골라서 보기 어렵습니다. 보드에서 제목으로 이슈를 검색할 수 있습니다. jql은 안되는 것 같네요. 보드 컬럼을 바로바로 만들 수 있습니다. 각 컬럼의 이름이 곧 상태 이름이 됩니다. workflow가 아직 없어서 이슈의 상태 변환이 굉장히 자유롭습니다. 맨 오른쪽에 있는 컬럼이 완료 컬럼입니다. 이슈가 맨 오른쪽 컬럼으로 움직였다면 그 이슈는 완료된 상태가 되며 보고서에서도 완료된 이슈로 계산될 것 입니다. 보드에 있는 이슈 카드 레이아웃을 설정할 수 없습니다. 제목, 우선순위(priority), 스토리 포인트 정도를 볼 수 있네요. 차세대 프로젝트 보드는 기존보다 기능이 간소화되었다는 느낌을 받았습니다. 이렇게 보니 민첩하고 독립적인 팀에 적합하다고 한 것 같네요. 😀 프로젝트 기능 설정 프로젝트에서 사용할 수 있는 기능들을 On/Off 할 수 있도록 되어있는데 처음에는 대부분 꺼져있는 상태입니다.프로젝트 기능 설정은 프로젝트 설정 &gt; 기능에서 살펴볼 수 있으며 On/Off 할 수 있습니다. 저는 로드맵, 백로그, 보고서, 예측, 페이지, 릴리스 및 버전 관리, 이슈 이렇게 기능을 켜서 사용하고 있는데요.간단히 각각 기능들을 짚어보겠습니다. 로드맵(Roadmap) 로드맵은 에픽을 기준으로 하위에 있는 이슈들을 계층 구조로 볼 수 있는 기능입니다.모든 작업이 에픽을 기준으로 묶이는 것으로 단순화하여 로드맵이 단순화 되었습니다. 피쳐 작업 또는 단위 기능 기준으로 에픽을 만들고 하위에 태스크 구성하면 한눈에 보기 좋을 것 같습니다.(물론 하위 태스크가 30개 이상이 되어버리면 보기 어려운 것은 기존과 마찬가지겠지만요. 😂) 필터링, 내보내기 기능 등 로드맵 쪽에 기능이 몇 가지 있네요. 이미지 내보내기 기능이 쓸모가 크게 있을 것 같지는 않지만, 이미지 공유로 가능하다는 점에서 좋은 것 같네요. 백로그(Backlog) 저는 개인 공부/작업의 백로그를 두고 관리하기 위해 사용하고 있습니다.차세대 프로젝트 백로그는 에픽, 버전 별로 필터를 적용하여 볼 수 있습니다.패널도 옆에 켜서 볼 수 있어서 에픽, 버전 별로 하위 작업의 프로그레션을 볼 수 있습니다. 백로그 중간에 있는 드래그 가능한 바(bar)는 보드 / 백로그 티켓을 바 기준으로 옮길 수 있도록 하는 기능을 합니다. 백로그는 사실 보드 보다는 많이 보지 않지만 필터 기능이 있어서 편하긴 한 것 같습니다. 👍 보고서(Report) 기존 클래식 타입의 프로젝트에는 많은 보고서 타입이 있는데 차세대 프로젝트에는 4개 정도 밖에 없습니다.그와중에 저는 칸반을 사용하고 스프린트를 사용하지 않아서 3개의 보고서는 보지 못하네요. 😂 기능 소개 참고 커뮤니티 포스트: We are reinventing the Sprint burndown for next-gen projects!스프린트 번다운 차트는 소개 문서에 있는 내용을 가져왔습니다. 스프린트 보고서와 번다운 차트를 차세대 제품에서는 단일 보고서로 통합했습니다. 스프린트 번다운 차트에는 스프린트에서 완료된 작업량과 남은 총 작업량이 표시됩니다. 또한 과도한 범위 증가를 파악하고 스프린트 회고 시 요약을 제공하는 데에도 유용합니다. 기존보다 세련되었다 정도 밖에 의견을 못남기겠네요.프로젝트 리포트를 현업에서 잘 사용해보지 못해서 그런 것도 있습니다. 😅현업에서도 잘 사용해보고 싶다는 생각을 하며 보고서 기능 소개를 마무리 합니다.(번다운 차트 외, 다른 리포트은 설명 링크 달아두겠습니다.) 번업 차트(Burnup Chart): View and understand the burnup chart 속도 차트(Velocity Chart): View and understand the velocity chart 위 2개 보고서는 따로 클래식, 차세대 나눠서 볼 필요는 없어서 클래식에 있는 내용을 공유드립니다. 예측(Estimation)예측이라고 적어두니까 특별한 기능이 있는 것 처럼 보이지만 사실은 스토리 포인트 기능을 의미합니다.클래식과 차세대에서 예측(estimation) 기능의 큰 차이는 없습니다.클래식에서는 스토리 포인트 외에 다른 필드 값을 사용할 수 있다는 점 정도가 다릅니다.(스토리 포인트, Original time estimate, 이슈 수, 커스텀 필드를 사용할 수 있습니다) 예측 설정으로 스토리 포인트를 통해 번다운 차트나 속도 차트를 볼 수 있습니다. 페이지(Page) 이 기능은 사실 컨플루언스와 연동해서 사용할 수 있는 기능입니다.Jira 프로젝트와 연결되어 관련 문서를 바로 볼 수 있다는 점은 좋은 것 같습니다.(사실 그냥 컨플루언스 기능을 연결한 정도여서 따로 살펴볼 내용은 없네요.) 저는 Jira 무료 사용자인데 페이지 기능을 사용하려면 Confluence는 Jira와 다른 제품이라서 사용하려면 추가 구매해야합니다.저는 테스트를 위해 30일 무료 테스트(free trial)를 해보고 있습니다.UI가 세련되서 좋긴한데 개인적으로는 차세대 프로젝트에 꼭 필요한 기능으로는 생각되지 않네요.접근성을 높혔다는 점이 좋은 것 같습니다. 릴리스 및 버전 관리(Release and Version) 작업한 버그나 태스크들을 버전에 맞게 플래닝, 정리할 수 있는 버전 관리입니다.버전별로 출시할 내용들을 릴리스 버전을 통해 관리하는 것이죠.기존 클래식 버전과 다른 점은 각 릴리스 버전을 누르면 버전이 입력된 이슈들을 보여주는 릴리스 페이지가 보이는 것이 아닌 이슈 검색 화면으로 이동한다는 점입니다. 기존 사용방법과 달라서 잠시 혼란이 있었지만 굳이 버전 페이지가 따로 있어야하는지는 한번 더 생각해보게 되었네요.사실 저는 클래식 버전의 릴리스 버전 화면이 마음에 듭니다. 😀 이슈(Issue) https://community.atlassian.com/t5/Next-gen-articles/Introducing-issue-navigator-in-next-gen-projects/ba-p/1339049“프로젝트 이슈 탐색기로 차세대 탐색 및 검색이 훨씬 더 간편해집니다. 텍스트 검색을 사용하거나 담당자, 보고자, 상태별로 필터링하여 프로젝트에서 이슈를 검색하세요. 다양한 기준으로 목록을 정렬하여 해당 목록에서 이슈를 바로 수정할 수 있습니다.” 기존 클래식 프로젝트의 경우 “이슈” 메뉴를 누르면 바로 필터 메뉴로 넘어가서 검색할 수 있도록 되는데요.차세대 프로젝트에서는 담당자, 보고자, 상태, 유형 별로 정렬해볼 수 있어서 좋은 것 같습니다.하나하나 검색하는 것 보다 접근성이 좋아졌네요. 이슈 기능은 바로 필터링해서 볼 수 있는 기능이 생겨서 사용성은 좋아진 것 같습니다.이슈의 수가 많아지면 빠르게 동작할 수 있을지 모르겠지만요. 올해 프로젝트 사용해보면서 더 정리해봐야겠네요. 차세대 프로젝트 정리지금까지 차세대 프로젝트에 어떤 기능들이 있는지, 어떻게 달라졌는지 살펴보았는데요.충분한 설명이 되었는지 모르겠습니다.저도 프로젝트를 생성해서 테스트한지 한달 정도 되어서 더 사용해봐야 유용한 정보들을 소개드릴 수 있을 것 같네요.향후 추가될 기능들도 기대가 되서 업데이트될 때마다 공유드리면 좋을 것 같네요.긴 글 읽어주셔서 감사합니다. 🙇‍♂️","link":"/blog/2020/06/30/Jira-Cloud-Next-Gen-project/"},{"title":"ScriptRunner를 이용하여 Jira 이슈 생성시 설명(Description) 기본 값 설정하기","text":"Needs: Jira 이슈 생성시 설명(Description) 항목 기본 값 설정하기Jira를 사용하다 보면 이슈를 생성할 때 설명 항목에 자주 쓰는 내용들이 있습니다.예를 들면, 현재 사용하는 프로젝트의 버그 이슈에서 버그에 대한 상세한 설명, 참고 사항 등이 있죠.현재 사용하고 있는 프로젝트에서는 아래와 같은 내용을 버그 티켓 생성시 작성하고 있습니다. 예시: 버그 이슈 설명(Description) 내용12345678910(QA 환경)환경 설명(상세 설명)상세 설명(참고)참고 설명(영상)영상 링크(기대 결과)기대 결과 설명 이러한 내용을 항상 이슈 생성시 마다 작성하는 것도 번거롭고, 각 작성자가 입력하는 내용도 일정하지 않을 때가 있었습니다.이런 상황들을 개선해보고자 기본 값, 템플릿을 설정할 수 있는지 확인해보았고 다른 Jira 앱(플러그인)들이 있지만 현재 설치되어있는 ScriptRunner로 개선해보았습니다. ScriptRunner로 설명 항목 기본 값 설정 FlowScriptRunner에는 많은 기능들이 있지만 그 중에서 Behaviours 기능을 사용하여 특정 항목의 기본 값 설정을 해보겠습니다.순서는 다음과 같이 진행합니다. (ScriptRunner 가이드 문서 - Setting Field Defaults에도 있는 내용이니 참고해주세요!) Jira &gt; Manage apps &gt; Behaviours 이동 Add Behaviours 추가 Add Mapping - 프로젝트 및 이슈 타입 설정 Fields 설정 &gt; Initialiser 스크립트 설정 Add Behaviours 추가첫 번째 설정으로 이동하는 단계는 스킵하고 Behaviours를 추가하는 것 부터 진행하겠습니다.위에 있던 이미지 항목대로 behaviour 이름을 입력해주고 Add 버튼을 누르면 끝입니다. Add Mapping - 프로젝트 및 이슈 타입 설정 Choose projects: 프로젝트는 기본 값 설정이 필요한 프로젝트를 선택하여 지정해주시면 됩니다. Choose Issue types: 모든 이슈 타입 또는 특정 이슈 타입에 대해서 지정할 수 있습니다. 이 설정으로 behaviour가 동작할 프로젝트, 이슈 타입이 맵핑되었습니다. Fields 설정 &gt; Initialiser 스크립트 설정 Add Behaviours 화면에서 만든 behaviour 항목에 있는 Fields를 눌러 설정을 진행합니다.처음에는 Initialiser Function이 없다고 나오는데 Create initialiser를 눌러 생성해주세요.생성하고 나면 위와 같은 스크립트를 입력할 수 있는 항목을 볼 수 있습니다. 스크립트를 입력해볼까요? 스크립트1234567891011import com.atlassian.jira.component.ComponentAccessorimport static com.atlassian.jira.issue.IssueFieldConstants.DESCRIPTION;if (getActionName() != &quot;Create Issue&quot;) { return // not the initial action, so don't set default values}def desc = getFieldById(DESCRIPTION);if (!desc.getValue()) { desc.setFormValue(&quot;test form&quot;);} 스크립트는 심플해서 설명할 내용은 많지 않네요. Create Issue 타입의 액션이 아니면 스크립트 실행 중지 getFieldById()를 가져오고 setFormValue() 함수를 통해 이슈 생성시 form에 기본 값을 입력 스크립트러너 가이드 문서에 있는 내용이 더 복잡한 내용을 담고 있어 다른 항목의 기본 값 설정시 참고하시면 좋을 것 같습니다.기본 값 설정시 setFormValue() 함수에 string 값으로 설정해주시면 됩니다.이미지와 스크립트가 다른 것은 설명 값이 있는지 유무를 확인하는 정도이니 설정시 참고부탁드립니다. 😀 설명 항목 기본 값 설정시 참고설명 항목 기본 값 설정하면서 몇가지 참고할 만한 사항이 있습니다. 기본적으로 설명 항목은 HTML 값을 인식하기에 줄바꿈이 필요할 경우 &lt;br/&gt;을 입력해서 설정해주시면 됩니다. h1, h2와 같은 항목도 마찬가지로 &lt;h2&gt;, &lt;h3&gt;로 입력해서 설정해주시면 됩니다. 만약 현재 Jira 시스템에 JEditor가 설치되어 사용중일 경우 JEditor 기능을 사용하여 기본 값을 설정해주셔야 합니다. 이건 ScriptRunner 기능보다는 JEditor 내용이니 다른 포스트에서 다뤄보겠습니다. 마무리ScriptRunner 기능 중에 Behaviours 기능을 이용하여 기본 값 설정을 해보았습니다.사실 다른 Jira 앱을 통해서 쉽게 설정할 수 있는데 ScriptRunner는 코드를 입력해야하는 점이 어려울 수 있겠다는 생각이 드네요.(그만큼 커스텀할 수 있는 것이 많아서 좋긴 하지만요. ㅎㅎ) 다른 항목에 대한 기본 값 설정은 가이드 문서를 참고해주시구요. 다른 유용한 기능이 있다면 포스팅해보겠습니다.긴글 읽어주셔서 감사합니다. 👍 참고 문서 / 링크 https://scriptrunner.adaptavist.com/6.3.0/jira/recipes/behaviours/setting-default-fields.html https://community.atlassian.com/t5/Marketplace-Apps-Integrations/Scriptrunner-behavior-default-text-and-validation-error-resets/qaq-p/581980","link":"/blog/2020/06/18/Jira-ScriptRunner-default-fields-setting/"},{"title":"Jira Software 8.10~8.12 release notes","text":"Jira Software 8.10 ~ 8.12 릴리스 노트Jira Software 8.10 ~ 8.12 릴리스 노트: 8.10 Release Notes 8.11 Release Notes 8.12 Release Notes Jira Software 8.10 ~ 8.12 버전 릴리스들을 모아서 보겠습니다.3개의 버전을 모아서 보아도 큰 업데이트는 없네요. 다만 QoL(Quality of Life) 개선 내용이 있어서 좋네요. 👍 Jira 8.102020년 6월(June)에 릴리스한 버전입니다. - 8.10 Release Notes 하이라이트 (Highlights) OAuth 2.0 for your incoming mail User anonymization (GDPR) improvements More insight into your custom fields Stale nodes automatically removed Optimized custom fields 8.10 릴리스는 커스텀 필드 관리 측면에서의 개선과 OAuth 2.0 추가된 것이 주 포인트입니다.다만 커스텀 필드 관리 측면의 내용은 모두 데이터 센터 한정한 내용이긴 합니다. 자세한 내용은 아래에서 더 자세하게 보시죠. OAuth 2.0 for your incoming mail구글과 마이크로소프트에서 Basic Authnication을 사용하지 않을 것에 대한 대응 업데이트입니다.기존에 메일에서 사용할 수 있는 기능을 계속 사용할 수 있도록 OAuth 2.0을 추가했네요.gmail, Microsoft Exchange에서 비밀번호를 사용하지 않고 기능을 사용할 수 있게 되었습니다.(물론 OAuth 2.0과 관련한 설정을 해줘야겠죠 😀) 자세한 내용은 Integration with OAuth 2.0 문서를 참고해주세요. 저도 봇 개발을 하고있는 입장에서 OAuth 2.0 추가는 좋네요.다만 Https 설정이 기본이고 URL도 잘 설정해둬야 잘 동작한다네요.문서를 꼼꼼히 읽어보고 나중에 설정하는 방법도 포스팅해보겠습니다. User anonymization (GDPR) improvementsGDPR과 관련하여 유저의 익명화 기능에 대한 개선 내용입니다. 익명화 기능의 범위를 늘렸다고 하네요. 이슈 검색에서 Reporter, Creator 익명화 이슈 히스토리에 있는 이름 익명화 (Assignee, Reporter, Single- and Multi-user picker fields) 이미 삭제된 유저에 대해 익명화할 수 있는 기능 추가 더 자세한 내용은 Anonymizing users에서 더 볼 수 있습니다. GDPR과 관련한 내용은 많이 와닿지 않는 내용이긴하지만 사용자의 정보를 지키고 관리하는 것은 필요하니 알아둘 필요는 있는 것 같습니다. More insight into your custom fields(데이터 센터) “Jira Administration &gt; System &gt; Clustering &gt; Actions &gt; Custom field indexing” 경로에서 커스텀 필드가 어떻게 인덱싱되고 있는지 볼 수 있도록 기능이 추가되었네요. 데이터 센터와 관련해서 관리자 역할을 하고 있지는 않아서 모르긴하지만 커스텀 필드의 값의 인덱싱 관리가 어려운 경우에는 좋을 것 같긴하네요. 😀 Stale nodes automatically removed(데이터 센터)지난번에 클러스터 관리와 관련한 자동화를 소개했었는데 자동으로 오래된 노드를 지워주는 기능이 추가되었네요.자세한 내용은 Jira cluster monitoring에서 볼 수 있습니다. Optimized custom fields(데이터 센터)많은 양의 커스텀 필드는 성능에 영향도 주고 인덱싱할 때에도 시간이 오래 걸리는 요인이기도 합니다.이런 상황을 개선하기 위해 필요한 상황에서만 커스텀 필드를 보여주거나 관리하도록 변경했네요.자세한 내용은 Optimizing custom fields에서 볼 수 있습니다. Jira 8.112020년 7월(July)에 릴리스한 버전입니다. - 8.11 Release Notes 하이라이트 (Highlights) Managing private filters and dashboards Issue detail view is now optional Improved email notifications about mentions Embedded Crowd upgrade More stability in the Favorite Filters gadget Restricting sprint selection Configure how fast stale nodes are moved offline 하이라이트만 봤을 때는 몇 가지 마음에 드는 기능들이 보이네요.프라이빗 필터, 대시보드 관리 가능해지는 점과 Jira에서 멘션시 메일 오는 것에 대한 개선이 눈에 띕니다.한번 각각 자세히 볼까요? Managing private filters and dashboards 이번 8.11 업데이트 부터 private 필터, 대시보드를 수정할 수 있게 되었습니다.주로 탈퇴한 사용자/유효하지 않은 사용자가 만든 필터, 대시보드를 관리하기 어려운 상황이 있는데 이런 상황을 해결할 수 있게되었네요. 👏(대시보드에 연결되어있는 필터 등 문제가 있을만한 내용을 관리자가 수정할 수 있게된 것은 좋은 것 같습니다.) Issue detail view is now optional 보드에서 이슈 카드를 누를 경우에 나오는 이슈 상세보기 화면을 보이지 않도록 설정할 수 있는 옵션이 추가되었습니다.칸반/스프린트 보드에서 Board &gt; Hide detail view로 설정할 수 있네요.이 옵션을 설정하고나면 이슈를 한번 클릭해도 상세보기 화면이 나오지 않습니다. Improved email notifications about mentions 이번 개선 기능도 그동안 메일 알림 읽는데에 어려움을 주었던 것을 해소해주는 기능이네요.8.0에 적용되었던 알림을 묶어서 메일로 전송해주는 기능이 있었는데요.멘션시 알려주는 알림과 별개의 흐름(기능)이라서 멘션 알림 따로 묶음 알림 메일이 따로 전송되고 있었습니다.이번 업데이트로 묶음 알림과 멘션 알림 메일이 같이 전송되도록 개선되었네요.참고할 점은 멘션 알림은 바로 알려질 필요가 있는 경우가 많으니 멘션시 묶어서 보낼 내용을 같이 보내준다고 합니다. 이 업데이트로 멘션 알림 따로 묶음 알림 따로 받지 않아도 되서 즐겁습니다. 😀 Embedded Crowd upgradeCrowd라는 라이브러리 2.0 -&gt; 4.0 업데이트가 있었다고 합니다.성능 향상과 클러스터링 지원, 디렉토리 페일오버, 버그 수정 등이 적용되었다고 하네요.(사용자 측면에서는 딱히 뭐가 달라졌는지 알 수 있을만한 내용은 없네요.) API 문서를 보아하니 유저 계정 싱크나 계정 관리 쪽 업데이트로 성능 향상이 된 것 같습니다.LDAP 싱크에 성능향상이 있을까 궁금하네요. (성능 향상이 있으면 벤치마크를 보여주지…) More stability in the Favorite Filters gadget 대시보드에서 가끔 favorit filters 가젯이 오류가 나서 안나오는 경우가 있습니다.필터에 문제가 발생했거나 시스템 상 필터에 있는 이슈를 가져오지 못하는 경우가 있어서 그런 것 인데요.문제가 있는 필터만 보이지 않도록 따로 에러 처리를 한 것으로 보입니다.(종종 쓰는 기능이긴한데, 느릴 때가 있긴해도 실제로 보지는 못했습니다. 물론 타임아웃을 겪은 적은 좀 있지만요.) Restricting sprint selection 스프린트 설정의 오류를 개선하기 위해 관리자 옵션에서 Relevant sprints 라는 옵션이 추가되었네요.옵션을 설정할 경우 프로젝트에 속한 스프린트만 볼 수 있게됩니다. (다른 스프린트를 보고 싶다면 Show all로 볼 수 있긴하지만요.) Configure how fast stale nodes are moved offline(데이터 센터) 앞서 8.10에서 소개했던 오래된 노드를 자동으로 삭제해주는 기능이 있었는데요.이번에 업데이트된 것은 오래된 노드를 오프라인으로 바꿔주는 시간을 설정할 수 있는 기능입니다.jira.not.alive.active.nodes.retention.period.in.hours 설정 값으로 오프라인으로 변경되는 데에 시간을 설정할 수 있다고하네요. Jira 8.122020년 8월에 릴리스한 버전입니다. - 8.12 Release Notes 하이라이트 (Highlights) Improved user picker More control over your Advanced Audit log Support for MySQL 8.0 Less app impact on indexing Users created automatically with Just-in-time user provisioning Small improvements to make your day Improved user picker 커스텀 필드에서 유저 피커 필드의 경우 리포터, 담당자와 같은 시스템 필드처럼 사용자 이미지 및 이름을 볼 수 있도록 개선되었습니다. 싱글 유저 피커만 개선된 것 같고 멀티 유저 피커는 나중에 개선될지 봐야할 것 같네요. More control over your Advanced Audit log(데이터 센터) 데이터 센터를 위한 기능들이 지속적으로 개선되고 있네요. 이번에도 Audit log 개선사항입니다.카테고리, 제목을 필터해서 볼 수 있게되었네요. 추가로 로그 파일을 어떻게 저장할 것인지도 옵션화되었습니다.그 외에 우선순위 수정, 시큐어 어드민 로그인, 이슈 익스포트, OAuth 2.0 설정에 대한 이벤트도 Audit log에서 볼 수 있도록 이벤트가 추가되었습니다. Support for MySQL 8.0말 그대로 MySQL 8.0 지원으로 추가된 내용입니다. Less app impact on Jira indexing(데이터 센터) 인덱싱 진행시 시간이 오래걸리는 이슈를 개선하고자 하는 기능입니다.Document-Based Replication 기능을 기반으로 인덱싱시 앱에 영향이 크지 않도록 한다고 하네요.Document-based replication in Jira Data Center와 관련한 내용은 여기서 자세히 보실 수 있습니다. Document-based replication을 DBR이라고 부르고 소개하고 있네요.링크의 문서에 보면 bad state를 완전히 없앤 기술이라고 하는데요. 정보를 리플리케이션하는 방식에 대한 개선 같습니다.자세한 것은 링크를 참고해보셔요! Users created automatically with Just-in-time user provisioning(데이터 센터) Small improvements to make your day작은 개선이라고 소개했지만 너무나 큰 선물! 이번에도 좋은 개선 사항이 추가되었네요. Order of statuses on boardsboard &gt; Configure에서 보드에서 보이는 이슈를 상태 순서대로 볼 수 있도록 설정할 수 있게 되었습니다. todo를 맨 밑에서 보고 싶다면 순서를 상태 컬럼에서 todo 상태를 맨 밑으로 보내면 됩니다. Accessibility: Background in subtle buttons이 기능은 단순히 마우스 오버시에 표시되는 회색을 기본 상태가 회색으로 보일 수 있도록 설정하는 기능입니다.기존에 버튼이 잘 안보였다면 이 개인 설정을 켜보는 것이 좋겠군요. 😄 마무리8.10 ~ 8.12 Jira 기능을 살펴보았습니다.생각보다 많은 업데이트가 있었네요. (작성하면서 절반이 데이터 센터 전용 기능이었던 것 같은데 기분탓이겠죠 😂)다음 업데이트인 8.13도 준비되고 있는 것 같지만 아마 LTS 릴리스라서 큰 변경사항은 없을 것 같네요.8.13 업데이트 이후에 8.14를 기대하면서 다음 포스트를 준비해보겠습니다.다음에 만나요! 감사합니다! 👋","link":"/blog/2020/09/06/Jira-Software-8-10-8-12-release-notes/"},{"title":"Jira Software 8.2 릴리스 노트","text":"Jira Software 8.2 릴리스 노트Jira Software 8.2.x 릴리스 노트: https://confluence.atlassian.com/jirasoftware/jira-software-8-2-x-release-notes-968676271.html 2019년 5월에 릴리스된 Jira Software 8.2 기능에 대해 살펴보는 포스트입니다.위 릴리스 노트에서 자세한 내용을 보실 수 있으며, 이 포스트는 주관적인 생각을 담고 있습니다. 하이라이트 (Highlights) Filters on the Export archived issues page Color updates for issue statuses Support for Java 11 Support for Microsoft SQL Server 2017 Updating apps has never been easier Exporting all the issues you need 하이라이트 내용에서는 Jira 서비스를 사용하는 사람 입장에서 주요한 기능들만 강조해보았습니다.(그 외의 내용은 시스템 관리자가 봐야할 내용이라서 건너뛰겠습니다. :)) Filters to limit the number of archived issues you export데이터 센터 버전에서 사용할 수 있는 기능입니다.익스포트하려는 아카이브된 이슈의 수를 제한할 수 있는 기능입니다.(저는 서버 설치 버전을 사용하고 있어 해당 기능이 정확히 어떤 기능을 하는지 모르겠습니다.)자세한 내용은 아카이빙 이슈에서 참고해주세요. Color updates for issue statuses간단하게 설명하면 이슈들의 상태 카테고리 색깔이 변경되었습니다.서버 버전과 클라우드 버전의 일관성을 맞추기 위해서 바꾸었다고 하네요. 노란색은 사라지고 파란색이 더 강조된 느낌입니다. Exporting all the issues you need기존에는 1000개까지 밖에 안되었던 이슈 익스포트가 최적화를 통해 더 많은 양을 익스포트할 수 있게되었습니다.다만 이 제한 설정은 시스템 관리자가 설정할 수 있습니다.System &gt; Advanced Settings &gt; jira.search.views.max.limit 마무리8.2 릴리스는 변경사항이 그렇게 많지 않네요.그 외에 버그 수정사항도 약간 있으니 자세한 내용인 실제 릴리스 노트 링크를 참고해보세요!","link":"/blog/2019/10/06/Jira-Software-8-2-release-notes/"},{"title":"Jira Software 8.4 릴리스 노트","text":"Jira Software 8.4 릴리스 노트Jira Software 8.4.x 릴리스 노트: https://confluence.atlassian.com/jirasoftware/jira-software-8-4-x-release-notes-975017507.html 2019년 9월에 릴리스된 Jira Software 8.4 기능에 대해 살펴보는 포스트입니다.위 릴리스 노트에서 자세한 내용을 보실 수 있으며, 이 포스트는 주관적인 생각을 담고 있습니다. 하이라이트 (Highlights) Archived issues taken to the next level (Data Center) Better email notifications, right from the start Filters in Multi User picker Custom field External links open in a new tab Jira becomes more accessible A large number of versions is OK for boards Time tracking in bulk edit Open links in your mobile app Jira Docker New supported databases 이번 8.4 릴리스는 하이라이트 리스트만 봐도 내용이 많긴하네요.몇가지는 시스템 설정 관련 내용이긴 하지만 한번 보겠습니다. Better email notifications, right from the start8.0 버전에 들어갔던 Batch 이메일 알림에 대한 추가 개선 내용했고, 이 내용이 기본 설정으로 변경되었습니다.기본 템플릿이 있지만 추가적으로 커스텀하게 알림 받고 싶은 것에 대해 설정할 수 있게되었기도 합니다. customizing-email-content-batched-notifications adding-custom-fields-to-emails-batched-notifications 다만 시스템 설정 상에서 쉽게 변경할 수는 없고 Velocity template이라는 것을 수정해야한다고 합니다.나중에 관련해서 세팅하는 방법을 따로 포스트해봐야겠습니다.(저도 아직 사용해보지 않아서 얼마나 힘들지 모르겠네요.) Filters in Multi User picker Custom field릴리스 노트에 있는 내용 그대로 들고와보았습니다. 유저 요청에 따라 추가된 기능이라고 하네요. In response to user requests, we’ve made it possible to limit the multi user picker custom field to hold only specific set of users.This is to prevent sending notifications to random users as a result of mistyping user names.This adds to the overall security of issues. 추가된 기능은 필터에 멀티 유저 피커 커스텀 필드 내용을 추가하여 사용할 수 있는 기능입니다.필터에 다른 유저를 잘못 입력하는 것을 방지할 수 있는 기능 같네요. External links open in a new tabYourUserProfile &gt; Profile &gt; Preferences &gt; External links 메뉴에서외부 링크를 항상 새로운 탭에서 볼 수 있는 옵션을 제공합니다. Time tracking in bulk editTime tracking 필드의 벌크(bulk) 수정이 가능한 기능이 추가되었습니다.일괄적으로 추정 시간, 남은 시간을 변경하는 데에 좋을 것 같습니다. Jira DockerJira 서버 버전 및 데이터 센터 버전을 Docker 컨테이너로 사용할 수 있도록 공식 지원한다고 합니다.자세한 내용은 링크에서 보실 수 있습니다. https://hub.docker.com/u/atlassianJira 외에 컨플루언스, 파이프라인 등 다른 이미지들도 있어서 시스템 구성시 사용해볼 수 있을 것 같습니다. Jira Software: https://hub.docker.com/r/atlassian/jira-software Jira Core: https://hub.docker.com/r/atlassian/jira-core 마무리8.4 릴리스는 8.5 릴리스 전에 많이 개선된 느낌이 있네요.Docker 이미지가 추가된 것도 좋은 업데이트 사항이었고 향후 있을 8.5 릴리스 내용도 기대가됩니다.","link":"/blog/2019/10/09/Jira-Software-8-4-release-notes/"},{"title":"Jira Software 8.3 릴리스 노트","text":"Jira Software 8.3 릴리스 노트Jira Software 8.3.x 릴리스 노트: https://confluence.atlassian.com/jirasoftware/jira-software-8-3-x-release-notes-972326971.html 2019년 7월에 릴리스된 Jira Software 8.3 기능에 대해 살펴보는 포스트입니다.위 릴리스 노트에서 자세한 내용을 보실 수 있으며, 이 포스트는 주관적인 생각을 담고 있습니다. 하이라이트 (Highlights) Jira Server mobile app Content Delivery Network (CDN) for Jira Data Center AdoptOpenJDK JRE bundled with JIRA List of custom changes after upgrade New filters to search for custom fields Browsing projects is faster now Improvements to batching emails Cluster lock mechanism improved in Data Center Re-indexing made better Jira Server mobile app8.0 버전에서 베타로 있었던 Jira 모바일 앱이 8.3 버전에서 부터 정식 버전으로 오픈되었습니다!자세한 사항은 따로 페이지가 만들어져 있네요. (링크) Android: https://play.google.com/store/apps/details?id=com.atlassian.jira.server iOS: https://apps.apple.com/us/app/id1405353949 모바일 웹뷰보다는 잘 보이는 것들이 많습니다.저는 모바일 폰 보다 패드에서는 시원하게 보이는 것들이 많아서 편하게 사용하고 있습니다.실제로 컴퓨터로 보는게 더 편한 것들이 많은 것은 넘어가겠습니다. :) New filters to search for custom fields 시스템 설정 &gt; 이슈의 커스텀 필드를 검색하는데에 편의를 위해 필터가 생겼습니다.이 기능으로 커스텀 필드를 골라서 보는 데에 조금 더 빠르고 편리하게 수정할 수 있게되었습니다. 특정 프로젝트가 사용하는 커스텀 필드 커스텀 필드 타입 특정 스크린이 사용하는 커스텀 필드 Re-indexing made better커스텀 필드 추가나 이슈 필드 수정이 있으면 항상 따라오는 리인덱싱!이 내용은 데이터 센터 버전에 해당하는 내용이라고 하네요.리인덱싱을 진행할 때, 데이터 센터 노드 별로 진행하는 사항 등에 대한 경고로 실수를 막을 수 있도록 했다고 합니다. 마무리이번 8.3 릴리스는 데이터 센터 업데이트 스펙이 많은 것 같습니다.서버 버전 사용자 측면에서는 큰 변화는 없으나 시스템 관리자가 편해진 내용도 있었습니다.큰 스펙으로는 서버 버전의 모바일 앱을 정식으로 지원하게 되었다는 것! 다음 버전에는 어떤 기능들이 추가될지 기대하며 포스트 마치겠습니다.","link":"/blog/2019/10/06/Jira-Software-8-3-release-notes/"},{"title":"Jira Software 8.5 release note","text":"Jira Software 8.5 릴리스 노트Jira Software 8.5.x 릴리스 노트: https://confluence.atlassian.com/jirasoftware/jira-software-8-5-x-release-notes-975014654.html 2019년 10월에 릴리스된 Jira Software 8.5 기능에 대해 살펴보는 포스트입니다.위 릴리스 노트에서 자세한 내용을 보실 수 있으며, 이 포스트는 주관적인 생각을 담고 있습니다. 하이라이트 (Highlights) Distribute the Jira Server mobile app to managed devices New JVM check available Hungry for new features? API change log Enterprise releases, performance-wise Resolved issues 이번 8.5 릴리스는 하이라이트 리스트를 보면 새로운 피쳐는 없습니다.이번 릴리스에서 중요한 것은 엔터프라이즈 버전이라는 것입니다. Distribute the Jira Server mobile app to managed devicesjira server에서 모바일 기기에 따라 제한할 수 있도록 하는 기능이 추가되었네요.관련 내용은 Mobile Device Management(MDM) 문서를 참고해주세요. Enterprise release릴리스 노트에 대해서 소개하려고 했는데 특별히 소개할 내용이 없네요.앞서 말씀드렸듯이 엔터프라이즈 버전 릴리스라서 특별히 소개드릴 피쳐가 추가되지 않았습니다.8.5 버전이 엔터프라이즈 버전이라는 의미는 중요한 보안, 안정성, 데이터 무결성 및 성능 문제를 해결하기 위해 8.5의 수명이 다할 때까지 버그 수정 릴리스를 제공한다는 의미입니다. 마무리8.4 릴리스 소개 글에서는 8.5가 기대된다고 했는데 새로운 기능이 없는 릴리스였습니다.다음 8.6, 8.7에는 무엇이 추가되었는지 다음 포스트에서 정리해보겠습니다~","link":"/blog/2020/03/21/Jira-Software-8-5-release-note/"},{"title":"Jira Software 8.6 ~ 8.8 release note","text":"Jira Software 8.6 ~ 8.8 릴리스 노트Jira Software 8.6 ~ 8.8 릴리스 노트: 8.6 Release Notes: https://confluence.atlassian.com/jirasoftware/jira-software-8-6-x-release-notes-978220007.html 8.7 Release Notes: https://confluence.atlassian.com/jirasoftware/jira-software-8-7-x-release-notes-990550432.html 8.8 Release Notes: https://confluence.atlassian.com/jirasoftware/jira-software-8-8-x-release-notes-994314852.html 이번 포스트는 Jira Software 8.6 ~ 8.8 버전 릴리스들을 모아서 보겠습니다.(사실 8.6 릴리스에 추가된 기능이 많고 8.7, 8.8 릴리스에는 크게 소개할만한 내용은 없습니다.) Jira 8.62019년 12월에 릴리스한 버전입니다. 하이라이트 (Highlights) Jira copies over changes files on upgrade New JVM code cache check Replying to JIRA notifications in Outlook made way better Users and roles made better PostgreSQL 10 comes to Jira Several older platforms get deprecated Prefix and suffix search Accessible dropdown menus Configurable scheme parameters in Jira REST API for projects creation Burnup charts in Jira Software Self-protect and sleep easy with rate limiting New information in the audit log Cluster monitoring 8.6 릴리스는 앞선 8.5 엔터프라이즈 릴리스 후에 나온 버전이라 업데이트된 기능들이 많습니다.시스템 관리자가 알아야 하는 내용보다 태스크 관리 및 프로젝트 관리 측면의 기능 내용을 중점으로 살펴보겠습니다. Replying to JIRA notifications in Outlook made way better많은 사용자들의 요청에 의해 추가된 기능입니다.Outlook에서 Jira 이슈 알림 메일에 댓글을 남길 수 있도록 하는 기능을 세팅할 수 있게 되었네요.설명 상으로는 2개의 기능을 deprecate 했다고 하네요. Add a comment from the non-quoted email body Create a new issue or add a comment to an existing issue 설정과 관련한 내용은 이 링크에서 확인할 수 있습니다.참고차 설정 링크에는 기능을 어떻게 설정할 수 있는 방법보다는 개론과 같은 내용이 있습니다.(Jira 어드민이 대충 이런 느낌으로 사용하면 될 것이다의 느낌이에요.) Users and roles made better 기존에는 하나하나 role 그룹에 유저들을 추가해줘야 했다면 이제는 체크박스를 이용해서 더 간편하게 수정할 수 있도록 변경되었습니다.다만 그전에는 롤에 따라서 어떤 유저가 있는지 한분에 볼 수 있었는데 지금은 roles 메뉴를 눌러서 볼 수 있도록 변경되었습니다.(지금 상태가 조금 더 잘 정리되어 보이는 것 같긴 합니다. ㅎㅎ) Prefix and suffix search지난 8.0 릴리스에는 Prefix 검색에 대해서 지원을 시작했는데 이번 8.6부터 suffix 검색도 추가되었다고 합니다. 👏 Prefix 검색 Suffix 검색 text ~ “work*” text ~ “*box” 검색 기능이 조금씩 개선되는 것 같아 좋네요! :) Accessible dropdown menus 드롭다운 메뉴에 대해서 스크롤이 추가되었다는 내용입니다.기존에는 메인화면을 내려야 했다면 드롭메뉴 자체에 스크롤이 생겨서 편하게 메뉴를 볼 수 있게 되었네요. Burnup charts in Jira Software 번업(Burnup) 차트 기능이 Jira Server에도 추가되었습니다.앞으로 애자일 보드 -&gt; 리포트에서 새로운 번업 차트를 볼 수 있게 되었네요. More granular sprint permissions하이라이트에는 없는 내용이지만 언급이 필요해 보여서 넣었습니다.스프린트 관리 권한에 대해 몇 가지가 분리되어 추가되었습니다. 이에 따라 스프린트 관리를 사용자 권한에 맞게 부여할 수 있게 되었습니다.기존에 있던 Manage Sprint 권한은 있으나 Start/Complete sprints, Edit sprints 두 가지 권한이 추가되었네요.앞으로는 스프린트를 시작, 완료하는 사용자와 삭제도 할 수 있는 사용자 등으로 나눠서 관리할 수 있겠습니다. 그 외의 데이터 센터 내용은 스킵합니다.(관리자 기능이기도 하고 크게 소개할 내용은 없어 보여서 스킵합니다.) Jira 8.72020년 2월에 릴리스한 버전입니다. 하이라이트 (Highlights) Anonymizing users for GDPR compliance PostgreSQL 11 support OpenID Connect comes to Jira GDPR 관련 내용, DB 시스템, OpenID(데이터 센터) 등에 대한 릴리스로 일반 유저를 위한 기능 업데이트는 없네요.8.6 버전에 많이 업데이트하고 나서 안정화하는 버전이었는지 기능 추가는 없었네요.다음 8.8 버전으로 넘어가겠습니다~ Jira 8.82020년 3월에 릴리스한 버전입니다. 하이라이트 (Highlights) Revamped Audit log Dates for future sprints Jira loves accessibility Access Data Center features on Server infrastructure Revamped Audit log 데이터 센터 버전과 몇 가지 기능이 다를 수는 있겠지만 서비스 로그에 대해서 추가적으로 볼 수 있도록 기능이 개선되었습니다. 어떤 로그를 어느 기간 동안 보관할 것 인지를 설정할 수 있습니다. (you can decide which events are logged and how long you want to keep them) 로그들에 대해 더 자세히 알 수 있습니다. (you can filter the events, expand each for further details, and export the audit log if necessary) 카테고리로 정리된 로그를 통해 로그 확인이 개선되었습니다. (by getting an audit log that’s clear and categorized, you don’t need to spend time browsing through piles of events.) 나머지는 데이터 센터 내용이라서 스킵합니다. 인스턴스와 관련한 로그를 확인할 수 있다는 내용과 3rd 파티 툴 연동 등에 대한 내용이 포함되어있습니다. 위 개선 사항들은 Administration&gt; System &gt; Audit log 에서 확인하실 수 있습니다. Dates for future sprints 미래 스프린트를 위해 날짜 입력을 할 수 있도록 업데이트되었네요.기존에는 스프린트에 날짜를 입력하도록 Required(필수 입력) 설정되어있었는데 미래 스프린트 계획을 위해 추가된 기능으로 보입니다. Jira loves accessibility https://confluence.atlassian.com/jirasoftwareserver/accessibility-998878998.html개인 설정을 통해서 상태(Status)의 색/무늬를 변경할 수 있도록 할 수 있게 되었네요.관련한 자세한 내용은 위 링크에서 보실 수 있습니다. 마무리8.6 ~ 8.8 버전을 모두 살펴보았습니다.8.6 버전에는 추가/수정된 기능들이 많았네요. 8.7, 8.8 버전은 안정화 업데이트 같은 느낌을 받았습니다.한 달마다 버전 업데이트를 하고 있는데 버그 내용도 하나하나 보고 싶지만 이번 포스트에서는 스킵하고 다음 버전에서는 코멘트할 내용이 있을지 보겠습니다. 감사합니다. :)","link":"/blog/2020/05/04/Jira-Software-8-6-8-8-release-note/"},{"title":"Jira Software 8.9 release note","text":"Jira Software 8.9 릴리스 노트Jira Software 8.9 릴리스 노트: https://confluence.atlassian.com/jirasoftware/jira-software-8-9-x-release-notes-1003522922.html 이번 포스트는 Jira Software 8.9 릴리스에 대해서 보겠습니다.2020년 5월에 릴리스한 버전입니다. 이번 릴리스에도 큰 변경 사항은 없으나 그나마 멘션할 만한 내용이 있다면 속도 차트(Velocity Chart)의 업데이트가 있었습니다. 하이라이트 (Highlights) Refreshed Velocity Chart Get more from cluster monitoring Accessibility: Text spacing A tailored upgrade path Refreshed Velocity Chart 기능에 대한 자세한 설명은 이 페이지에서 볼 수 있습니다.속도 차트는 애자일 보드에서 스프린트를 사용하는 팀이 스프린트 별 처리한 작업으로 속도를 볼 수 있도록 도와주는 차트입니다.비즈니스 밸류, 이슈 수, 스토리 포인트 등으로 속도를 측정해볼 수 있습니다.Board -&gt; Reports -&gt; Velocity Chart 메뉴에서 해당 차트를 사용해보실 수 있습니다.(물론 스프린트를 사용해보아야 차트를 볼 수 있겠죠?) Accessibility: Text spacing 개인 설정에서 자간(글자 간격)을 조정할 수 있게 되었습니다. profile &gt; accessibilty 에서 설정할 수 있습니다.글씨가 다닥다닥 붙어있는 것이 불편했던 분들이라면 편리한 기능이겠네요. :) Get more from cluster monitoring 뭔가 하이라이트 항목이 앞에 있는 것과 바뀐 것 같지만, 데이터 센터 버전에서는 클러스터 모니터링과 관련한 업데이트가 있었습니다.이번 업데이트로 오래된 노드는 눈에 띄지 않도록 변경되었습니다.또, 클러스터 모니터링 페이지에 추가한 새로운 정보를 통해 오래된 노드를 신속하게 추적 및 제거하고 클러스터에서 실패한 노드를 수정할 수 있게 되었습니다. Jira Administration &gt; System &gt; Clustering 메뉴에서 보실 수 있습니다. A tailored upgrade path 업그레이드 전에 필요한 내용들을 체크할 수 있는 기능이 8.0에 추가되었었는데 그에 대한 추가 공유네요.버전 업그레이드하기 전에 최소한 어떤 내용을 확인해야하는지 알 수 있어서 좋은 기능이니 참고하시면 좋겠습니다. 마무리이번 8.9 업데이트도 큰 컨텐츠, 기능성 업데이트는 없었네요. 버그 수정은 꽤 있긴합니다.속도 차트의 경우는 Jira 개발팀에서 많이 사용하는 기능이라 리프레시 업데이트를 해보았다고 하는데, 속도 차트 사용 방법도 나중에 정리해서 공유해보면 어떨까 하는 생각이 드네요.8.9 릴리스 소개는 이만 마치겠습니다. 감사합니다.","link":"/blog/2020/05/31/Jira-Software-8-9-release-note/"},{"title":"OpenGL ES 버전 2.0과 3.0 차이","text":"OpenGL ES(Embeded System)Cocos2d-x 버전 차이에 대해서 공부하던 중에 그 기반이 되는 OpenGL ES의 버전에도큰 차이가 있지 않을까하여 공부해봤습니다. 우선 OpenGL ES란, (Wikipedia-ko) OpenGL ES (임베디드 단말을 위한 OpenGL)는 크로노스 그룹이 정의한 3차원 컴퓨터 그래픽스 API인 OpenGL의 서브셋으로, 휴대전화, PDA 등과 같은 임베디드 단말을 위한 API이다. 한글로 작성된 위키는 짧군요. 영어로 작성된 위키를 더 보겠습니다. (Wikipedia-en) OpenGL for Embedded Systems (OpenGL ES or GLES) is a subset of the OpenGL computer graphics rendering application programming interface (API) for rendering 2D and 3D computer graphics such as those used by video games, typically hardware-accelerated using a graphics processing unit (GPU). It is designed for embedded systems like smartphones, computer tablets, video game consoles and PDAs. OpenGL ES is the “most widely deployed 3D graphics API in history”. The API is cross-language and multi-platform. The libraries GLUT and GLU are not available for OpenGL ES. OpenGL ES is managed by the non-profit technology consortium Khronos Group. Vulkan, a next-generation API from Khronos, is made for simpler high performance drivers for mobile and desktop devices. 설명에 큰 차이는 없지만, API에 대한 설명에는 크로스 랭귀지, 멀티 플랫폼이 포함되어 있네요.OpenGL에서 사용할 수 있는 GLUT, GLU는 OpenGL ES에서는 사용할 수 없다는 것 정도를 추가로 알 수 있었습니다. 각 버전별 설명도 잘 나와있는 영문 위키를 보면, OpenGL ES 2.0 - (EN)OpenGL ES 2.0 was publicly released in March 2007.[6] It is based roughly on OpenGL 2.0, but it eliminates most of the fixed-function rendering pipeline in favor of a programmable one in a move similar to transition from OpenGL 3.0 to 3.1.[7] Control flow in shaders is generally limited to forward branching and to loops where the maximum number of iterations can easily be determined at compile time.[8] Almost all rendering features of the transform and lighting stage, such as the specification of materials and light parameters formerly specified by the fixed-function API, are replaced by shaders written by the graphics programmer. As a result, OpenGL ES 2.0 is not backward compatible with OpenGL ES 1.1. Some incompatibilities between the desktop version of OpenGL and OpenGL ES 2.0 persisted until OpenGL 4.1, which added the GL_ARB_ES2_compatibility extension.[9] OpenGL ES 3.0 - (EN)The OpenGL ES 3.0 specification[10] was publicly released in August 2012.[11] OpenGL ES 3.0 is backwards compatible with OpenGL ES 2.0, enabling applications to incrementally add new visual features to applications. OpenGL 4.3 provides full compatibility with OpenGL ES 3.0. Version 3.0 is also base of WebGL 2.0.[12] New functionality in the OpenGL ES 3.0 specification includes: multiple enhancements to the rendering pipeline to enable acceleration of advanced visual effects including: occlusion queries, transform feedback, instanced rendering and support for four or more rendering targets, high quality ETC2 / EAC texture compression as a standard feature, eliminating the need for a different set of textures for each platform, a new version of the GLSL ES shading language with full support for integer and 32-bit floating point operations;[13] greatly enhanced texturing functionality including guaranteed support for floating point textures, 3D textures, depth textures, vertex textures, NPOT textures, R/RG textures, immutable textures, 2D array textures, swizzles, LOD and mip level clamps, seamless cube maps and sampler objects, an extensive set of required, explicitly sized texture and render-buffer formats, reducing implementation variability and making it much easier to write portable applications. (참고, http://www.informit.com/articles/article.aspx?p=2181697&amp;seqNum=2) 음, 내용이 많아 번역한 내용으로 각각 살펴보고 정리해보겠습니다. OpenGL ES 2.0OpenGL ES 2.0는 2007년 3월에 출시되었습니다. OpenGL 2.0을 기반으로 하지만 OpenGL 3.0에서 3.1로 업데이트 될 때와 비슷하게 고정 렌더링 파이프라인을 제거하였습니다. 셰이더의 제어 흐름은 컴파일할 때에 쉽게 결정할 수 있는 순방향 분기, 루프로 제한됩니다. 이전에 고정 함수 API에 의해 지정된 재질 및 조명 매개 변수와 같은 변형 및 조명 스테이지의 거의 모든 렌더링 기능은 그래픽 프로그래머가 작성한 쉐이더로 대체되었습니다. 따라서 OpenGL ES 2.0은 OpenGL ES 1.1과 호환되지 않습니다. OpenGL과 OpenGL ES 2.0 데스크톱 버전 간의 일부 비 호환성은 GL_ARB_ES2_compatibility 확장을 추가한 OpenGL 4.1까지 지속됩니다. OpenGL ES 3.0OpenGL ES 3.0 사양은 2012년 8월에 공개되었습니다.OpenGL ES 3.0은 OpenGL ES 2.0과 하위 호환되므로 응용 프로그램이 응용 프로그램에 점진적으로 새로운 시각적 기능을 추가할 수 있습니다. OpenGL 4.3은 OpenGL ES 3.0과 완벽한 호환성을 제공합니다.OpenGL ES 3.0은 WebGL 2.0의 기반이기도합니다. 새로운 기능은 아래와 같습니다. 오클루전 쿼리, 변환 피드백, 인스턴스 렌더링 및 4개 이상의 렌더링 대상에 대한 지원을 비롯하여 고급 시각 효과를 가속화할 수 있도록 렌더링 파이프 라인에 대한 여러 가지 향상된 기능을 제공합니다. 고품질 ETC2/EAC 텍스처 압축을 표준 기능으로 지원하여 각 플랫폼에 다른 텍스처 세트가 필요하지 않습니다. 부동 소수점 텍스처, 3D 텍스처, 깊이 텍스처, 정점 텍스처, NPOT 텍스처, R/RG 텍스처, 불변 텍스처, 2D 배열 텍스처, 스위즐, LOD 및 밉(Mip) 레벨 클램프, 매끄러운 큐브 맵 및 샘플러 객체에 대한 보장된 지원을 포함하여 크게 향상된 텍스처링 기능을 포함합니다. 명시적으로 크기가 필요한 텍스처 및 렌더링 버퍼 형식의 광범위한 세트로, 구현 변동성을 줄이고 모바일 앱을 훨씬 쉽게 개발할 수 있습니다. 구글 번역기의 도움을 받아 해석해보았습니다.내용 상으로는 전반적으로 기능 추가, 성능 향상이 있어보입니다.(버전이 올라가면 늘 있는 성능 향상인 것 같지만요)2.0과 하위 호환이 된다는 것이 큰 것으로 보이며 더 깊게 봐야겠지만 렌더링 대상 지원 추가, 렌더링 파이프 라인 기능 향상 등이 눈에 띄네요.텍스쳐링 기능도 지원 범위가 넓어진 것도 큰 것 같습니다. 성능 테스트 자료가 있으면 좋겠는데.. 없네요.주로 OpenGL ES와 Vulkan 성능 분석이 많아서 OpenGL ES 2.0과 3.0은 성능 자료는 찾기 힘드네요.성능 분석에 큰 의미가 없어서 그런 것일 수도 있겠습니다.(기기에 따라 성능 차이가 많이 나서) OpenGL ES 버전 차이가 어떤가에 대해 개괄적인 내용을 살펴보았습니다.렌더링 방식, 텍스처 처리방식, 버퍼 크기등에 대한 차이가 있었네요. 그래픽 엔지니어는 아니어서 자세한 내용은 더 정리하기 힘들지만다른 좋은 레퍼런스가 있다면 추가해서 들고 오겠습니다.","link":"/blog/2019/06/30/OpenGL-ES-ver-diff-2-0-3-0/"},{"title":"Jira를 처음 사용하는 사용자에게 Jira 소개하기","text":"글을 시작하며개발 PM으로 일하면서 Jira를 사용하고 있는데 Jira를 사용해보지 못하거나 익숙하지 않은 분들이 있는 것 같아 살짝 정리해볼 겸 가볍게 소개해보려합니다. (주의) 이 글에서는 개발 방법론에 대해서는 다루지 않습니다.Jira에 대한 간단한 소개와 처음 사용하는 사용자, 도입하려는 매니저가 볼 수 있는 내용으로 구성해보았습니다. Jira 소개Jira는 간단히 소개하면 이슈 트래킹 서비스로 많은 사람들과 협업을 위한 정보 시스템입니다.플러그인과 기능들을 이용해서 이슈 트래킹 외에 많은 것들을 해볼 수 있겠지만 기본적으로 이슈의 상태와 정보를 변경하면서 우리팀이 어떻게 이슈를 처리하고 있는지 볼 수 있는 서비스입니다. 이슈 트래킹 서비스에는 Jira 외에도 요즘 많아지긴 했습니다. Redmine : https://www.redmine.org/ (오픈소스 서비스) Mantis : https://www.mantisbt.org/ (오픈소스 서비스) Monday.com : https://monday.com/ (유튜브 광고에 많이 나오는 서비스) Dooray : https://dooray.com/ 이 외에도 Trello, Asana 등 재택근무가 많아지면서 이슈 트래킹 서비스들도 많이 관심을 받고 있는 것 같습니다. Jira를 보통 어디에 사용하는가Jira를 주로 이슈 트래킹 서비스로 사용할 수 있으니 프로젝트 관리에 사용된다고 볼 수 있습니다.이슈를 트래킹하는 것이니 소프트웨어 개발 뿐만 아니라 서비스 운영 관리나 다른 프로젝트 관리에서도 사용할 수 있죠. https://www.atlassian.com/ko/software/jira/guides/getting-started/best-practices 위 링크에는 Jira에서 소개하는 베스트 프랙티스를 보면 실제 사용 사례보다는 Jira 프로젝트 설정하는 방법, 자동화 설정하는 방법 등이 있네요.이런 설정 방법을 참고해서 프로젝트에 필요한 것들을 설정하여 사용할 수 있겠습니다.(문서 모두 번역이 되어있지는 않아서 조금 번거롭긴하지만 볼 수 있는 정보는 많습니다 😂 ) Use Case: IT 서비스 개발 관리 (태스크 및 버그 관리)Jira를 IT 서비스 개발시 프로젝트 관리하는 툴로 사용한다면 어떤 기능들을 주로 사용하면 좋을지 골라보았습니다. Dashboard, Project Board Dashboard, Project Board 기능으로 나눠져있지만 기본적인 기능은 이슈 정보를 보드에서 모아서 볼 수 있는 것입니다. 두 보드의 차이점은 대시보드는 다른 위젯들을 붙여서 다양한 정보를 볼 수 있다는 점과 프로젝트 보드는 특정 프로젝트 이슈에 맞춰서 볼 수 있다는 점이 다릅니다. 대시보드 기능 소개대시보드는 Jira에 있는 이슈들이나 여러가지 정보를 한눈에 볼 수 있게 구성할 수 있는 보드입니다.여러 프로젝트의 이슈를 같이 보거나 특정 이슈들을 골라서 볼 수 있는 정보 대시보드를 만들 수도 있습니다. 내게 할당되어있는 이슈, 현재 스프린트에 있는 이슈들의 상태 등을 볼 수 있는 가젯(Gadget)을 추가하여 보드를 구성할 수 있습니다.내가 보고 싶은 정보를 한눈에 볼 수 있도록 보드를 구성하는 것은 개개인 마다의 요구사항이 다를테니 보드를 하나 만들고 구성해보시는 것을 추천합니다. 😉 대시보드 소개 참고 자료 아틀라시안 킬러 대시보드 만드는 5가지 방법(EN): https://www.atlassian.com/blog/jira-software/5-steps-to-build-a-killer-dashboard SK C&amp;C 블로그, 대시보드 설명: https://engineering-skcc.github.io/devops-tools/jiradashfilter/ https://partner.polarisofficecorp.com/atlassian/pages/viewpage.action?pageId=4522762 lesstif 블로그 대시보드: https://www.lesstif.com/jira/jira-dashboard-40435784.html 프로젝트 보드 기능 소개 (스프린트, 칸반)Jira에는 대시보드 외에도 프로젝트 내에서 사용하는 프로젝트 보드가 있습니다.프로젝트에서 프로젝트 보드를 생성하고자 하면 스크럼 보드, 칸반 보드 둘중에 어떤 보드를 만들 것인지 선택합니다. Jira에 있는 설명 그대로 가져와보겠습니다. 스크럼(Scrum): 스크럼은 스프린트라 불리는 계획, 커밋, 전달의 시간 단위의 작업 묶음에 중점을 두고 있습니다. 스크럼은 간단히 말하면 스프린트라는 묶음에 집중해서 작업하는 보드로 이해하시면됩니다. 스프린트를 어떻게 운영할 것인지에 대해 고민이 필요한 보드에요 칸반(Kanban): 칸반은 사용자의 워크플로를 가시화하는 것과 공정의 단계 개선을 위해 동시에 진행 중인 업무를 제한하는 데 중점을 두고 있습니다. 칸반은 각 컬럼에 진행할 수 있는 최대 작업 수를 제한하고 각 단계의 일을 개선하기 위한 보드로 이해하시면됩니다. 칸반은 각 컬럼의 작업 수를 어떻게 제한하고 팀이 어떻게 협업할 것인가를 고민해야하는 보드입니다. 😈 제가 일하는 곳에서는 각 조직별로 필요한 보드와 대시보드를 만들어 사용하고 있습니다. A팀은 스크럼을 위해 스크럼 보드를 사용하고 스크럼 마스터, 데일리 스크럼, 스프린트 회고 등을 진행합니다. 일반적인 업무 관리는 칸반 보드를 통해 관리합니다. 컬럼에 최대 이슈 수를 제한하는 팀은 아직 보지는 못했습니다.(각자 어떤 업무를 하고 있는지 정도를 보는 보드로 사용하는 듯 합니다.) 릴리스 버전(Release Version)릴리스 버전은 이슈들이 반영될 예정인 버전 값을 정의합니다.이슈에서 사용하는 fix version(수정 버전)에서 사용되며 해당 버전을 업데이트 완료하거나 배포가 완료되었다면 릴리스합니다. 릴리스 버전 메뉴는 프로젝트 페이지의 왼쪽 메뉴에서 🚢 배모양을 누르면 볼 수 있습니다. 엔지니어분들이라면 Github에 Releases 메뉴와 동일하다고 볼 수 있을 것 같네요. 😈 제가 일하는 곳에서는 아래와 같이 버전을 사용하고 있습니다. 각 업데이트 버전에 맞춰 릴리스 버전을 생성합니다. 업데이트 버전에 반영할 작업 이슈와 버그 이슈의 fix version 필드에 해당 버전을 입력합니다. 업데이트가 배포되면 해당 버전은 완료된 것으로 보고 버전을 릴리스(release)합니다. 사용하지 않는 버전이 생길경우 삭제하거나 아카이브(Archive) 합니다. 이슈 워크플로우(Workflow) 및 상태(Status) 이슈 관리 프로그램에서 빼놓을 수 없는 이슈 상태 관리에 대한 내용입니다.이슈 관리하는데에 있어서 이슈를 정의하고 진행, 리뷰, 완료 등 이슈의 상태를 나눠볼 수 있겠죠. Jira에서는 상태와 워크플로우를 통해 이슈 상태를 관리합니다.워크플로우는 이슈가 특정 상태로 이동하는 것에 대해 정의하고 이슈의 작업 흐름을 정의합니다.이슈 상태는 말 그대로 이슈의 상태를 정의한 것을 의미하죠. 모든 상태에서 모든 상태로 갈 수 있는 워크플로우를 만들 수도 있고 단계별로 상태가 이동하는 워크플로우를 만들 수도 있습니다.워크플로우 구성에는 정답은 없고 개발팀, 작업팀이 업무의 워크플로우를 직관적으로 이해할 수 있는 워크플로우가 좋다고 생각합니다. 😈 제가 일하는 곳에서는 워크플로우를 각 이슈 타입에 따라 분리해서 관리하고 있습니다. 크게는 에픽(Epic), 태스크(Task), 버그(Bug), 요청(Request), 제안(Suggestion)의 타입으로 분류해서 이슈, 워크플로우를 구성하고 있습니다. 워크플로우의 상태 구성은 큰 틀에서는 할일(Backlog, Todo) - 진행중(In progress) - 완료(Fixed, Closed) Use Case: IT 서비스 개발팀 IT 서비스 개발팀에서 Jira를 사용할 때에 어떻게 사용할지에 대해 간단히 정리해보겠습니다. 개발팀은 개발 프로젝트에서 작업 관리, 버그 관리를 Jira 이슈(티켓)로 관리합니다. 각 개발 담당자는 생성된 작업, 버그 이슈를 할당 받아 작업하고 작업 상태에 맞춰 이슈 상태를 변경합니다. 이슈에 작성된 내용을 기반으로 작업을 진행하면서 이슈 상태를 변경합니다. 이슈들은 fix version(수정 버전) 값을 이용해 작업이 어떤 버전에 포함되어야하는지 관리합니다. 이슈들의 진행 현황과 분포는 board 또는 dashboard를 통해 확인하고 관리합니다. 마무리Jira를 처음 사용하거나 어떻게 사용할지 가늠이 안되는 분들에게 도움이 되었으면해서 정리해보았습니다. 🙇‍♂️대시보드나 칸반 보드 등 각 보드에서 어떻게 구성해서 어떤 방식으로 일하면 좋을지는 케이스를 다루면서 이야기하면 좋을 것 같다는 생각이 드네요.지금 일하는 곳에서 어떻게 일하고 있는지를 살짝 공유해보았지만 어떤 느낌인지 사실 잘 와닿지 않았을 것 같기도 합니다. 이렇게도 사용하는구나하고 참고해서 Jira나 다른 이슈 트래킹 서비스를 사용하는데에 도움을 얻으셨으면 좋겠네요. 😸","link":"/blog/2021/11/28/Jira-first-start-user-guide/"},{"title":"P4V 소개 - 기본 개념 및 Cheat Sheet","text":"P4V, Helix Visual Client 소개전에 작성했던 P4V 가이드 글 외에도 Perforce를 참고할만한 내용이 많지 않아 가이드 문서를 번역해보고 알아보는 포스트를 작성해보고자 합니다. 전에 작성했던 기본 가이드: Perforce Client(P4V) basics 그중에 P4V, Helix(Perforce) 비주얼 클라이언트 소개 글을 정리해보고자 합니다.각 기능에 대한 번역 및 소개들도 차차 포스팅해보겠습니다.(대부분의 사람들이 주로 쓰는 프로그램이 비주얼 클라이언트일테니까요. 😸) Basic concepts (기본 개념) Helix Core 서버는 여러 버전의 매뉴얼, 웹 페이지 또는 운영 체제 관리 파일과 같은 소스 파일 및 기타 문서를 관리하는 데 사용할 수 있는 엔터프라이즈 버전 관리 도구입니다.Helix Core 서버에서 관리하는 파일은 저장소(depot)에 있습니다.파일 작업을 하려면 파일을 열고 작업 공간(workspace)에서 편집합니다.완료되면 변경 목록(changelist)을 사용하여 변경된 파일을 저장소에 제출(submit)합니다.저장소는 파일의 모든 현재 및 이전 개정을 추적합니다. 각 용어는 번역하지 않고 그대로 두겠습니다. Workspace: Helix Core server에서 관리하는 파일의 개정판을 작업하는 워크스테이션의 폴더 또는 디렉토리입니다. Helix Core app: 워크스테이션에서 실행되는 P4V (또는 명령 줄 클라이언트 또는 P4VS, Visual Studio 용 Helix 플러그인과 같은 다른 Helix Core 애플리케이션)는 Helix Core 서버로 요청하고 해당 요청의 결과 (파일, 상태 정보 등)를 제공합니다. Helix Core server or Helix server: Helix Core app의 요청에 응답하고, Depot 파일을 유지하고, Workspace의 상태를 추적하는 프로그램입니다. Depot: Helix server에서 호스팅하는 파일 저장소입니다. 여기에는 제출된 모든 파일의 모든 기존 버전이 포함됩니다. Helix server는 여러 저장소를 호스팅 할 수 있지만 이 가이드의 예에서는 단일 저장소를 보여줍니다. P4V Cheat SheetP4V 치트 시트가 있긴한데 많이 유용한지는 모르겠습니다.프린트해놓고 옆에 두고 쓰거나하면 좋을지는 모르겠네요. 😂 Cheat Sheet 원본: P4V Cheat Sheet (EN) 아이콘 모양이나 파일 상태, 스트림 타입에 대해서는 옆에두고 보면 좋을 것 같긴합니다. 😸(익숙해지기 전까지는요)치트 시트를 번역해보고 싶었는데 PDF다 보니 이미지를 추출하기도 힘들어서 나중에 기회가 된다면 번역해보겠습니다. 다음 포스트는 스트림과 관련한 내용을 쓸까 싶습니다.정리되는대로 포스팅해보겠습니다. 감사합니다. 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce Client(P4V) basics Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능","link":"/blog/2020/12/30/P4V-User-Guide/"},{"title":"Perforce Client(P4V) basics","text":"P4V 가이드 #1갑자기 PM이 Perforce 프로그램인 P4V 가이드를 작성하게 되었는데요. 사실 저는 Git, SVN 정도를 사용해본 경험만 있고 이번에 Perforce를 처음 사용하게 되었습니다. 제가 P4V를 볼 일은 많지 않지만 다른 사용자분들의 P4V 사용을 돕기 위해서 가이드 문서를 작성하다가 한국쪽 가이드 문서가 많지 않아 이렇게 블로그로 정리해보게 되었습니다. 툴 설명이라 엄청나게 큰 팁이 있다기 보다 이런 기능도 있구나, 이런 화면에 이런 기능도 있구나 하는 것을 조금씩 정리해보고 공유해보려 합니다. :) 이번 포스트에서는 접속화면 부터 메인메뉴 화면을 중심으로 다뤄보고 다음 포스트에는 P4V에서 자랑하는 기능들을 중심으로 설명해보려합니다. 시작하겠습니다! 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능 접속 화면P4V를 켜게되면 아래와 같은 화면을 볼 수 있습니다. 서버 주소, 이름, 워크스페이스를 설치하면서 설정한대로 또는 추가 설정하여 진행할 수 있습니다. 워크스페이스(Workspace)는 내가 앞으로 로컬에서 작업할 공간을 의미합니다. 특정 스트림과 맞춰 설정해두고 그 스트림에 수정사항을 제출할 수 있는 공간으로 이해하시면 됩니다. Show dialog at startup 옵션을 체크해두면 시작할 때마다 이 창을 볼 수 있습니다. 똑같은 값인데 항상 뜨는 창이 귀찮다면 해당 옵션을 끄고 시작하면됩니다. Setting처음 접속 시에 아래와 같은 화면이 나와 설정이 필요할 경우 참고하세요.(갑작스러운 윈도우 화면이지만 정보와 버튼 UI 레이아웃은 맥과 동일합니다) Trust this fingerprint 체크! → Connect p4 서버 연결시 SSL이 설정되어있을 경우, 확인 절차로 나옵니다. 아닌 경우에는 설정창이 뜨지 않습니다. 이 컴퓨터에서 보안 연결하는 것을 설정하는 작업입니다. 드롭다운을 눌러서 서버에 설정된 인코딩에 맞춰 설정합니다. CPC949 또는 UTF-8, UTF-8 (no bom) 등이 있습니다. 자신의 서버에 맞게 설정해주세요. 메인 화면 메인 화면은 처음 실행한 화면과 예시 화면이 다를 수 있습니다. 현재 히스토리(History)를 보여주는 영역을 메인 영역으로 정의하고 설명드리겠습니다. 화면 상단에 뷰(View) 메뉴를 눌러보면 많은 뷰 메뉴가 있습니다. 모든 뷰 메뉴에 대한 자세한 설명이 필요하다면 이 링크를 참고해주세요. (영어 주의) 현재 보이는 화면에서 자주보는 메뉴는 다음과 같습니다. History: 왼쪽 트리에서 선택한 디팟(Depot), 스트림, 파일의 히스토리를 볼 수 있습니다. Files: 왼쪽 트리에서 Workspace 탭으로 갔을 때, 각 폴더에 있는 파일 목록을 볼 수 있습니다. Pending: 현재 작업하고자 Checkout한 파일리스트 또는 제출(서밋, Submit)하기 위해 만든 체인지리스트(Changelist)를 관리할 수 있습니다. Submitted: 내가 제출한 체인지리스트의 목록을 볼 수 있습니다. History 왼쪽 메뉴에서 선택한 항목(디팟, 스트림, 파일)의 히스토리를 볼 수 있습니다. Revision / Date Submitted / Submitted By / Description 각 컬럼별로 정렬하여 볼 수 있습니다. 브랜치(스트림)에 상관없이 디팟의 히스토리를 보고 싶다면 stream 항목을 눌러서 히스토리를 볼 수 있습니다. 왼쪽 메뉴 상단의 필터 버튼을 통해 스트림을 타입별로 골라서 볼 수 있습니다. mainline 스트림만 보고 싶다면, 필터 버튼 &gt; Tree Restricted to Stream Type &gt; Mainline Development 스트림만 보고 싶다면, 필터 버튼 &gt; Tree Restricted to Stream Type &gt; Development Release 스트림만 보고 싶다면, 필터 버튼 &gt; Tree Restricted to Stream Type &gt; Release 필터를 사용하지 않고 모든 스트림을 보는 옵션은 No Filter 또는 All Types 입니다. 저장소의 히스토리만 보고자 한다면, 로컬에 소스를 받을 필요없이 리모트의 히스토리만 볼 수 있습니다. Files 왼쪽 메뉴에서 선택한 항목의 하위에 있는 파일들을 볼 수 있습니다. 폴더를 선택할 경우 해당 폴더안에 있는 파일들을 볼 수 있습니다. 파일을 선택하더라도 같은 폴더안에 있는 파일들도 볼 수 있습니다. 각 파일 항목 별로 마우스 오른쪽 버튼을 누르면 기능들이 많습니다. Check Out, Mark for Delete, File History 등 사용하고자하는 기능을 사용할 수 있습니다. Pending 현재 보여지는 화면과 가이드를 보고 있는 여러분의 화면은 다를 수 있습니다. 메뉴 상단에 필터가 어떻게 적용되어있냐에 따라 다릅니다. 필터를 어떻게 적용하냐에 따라 다른 사람의 Pending changelist(작업 내용)을 볼 수 있습니다. 체크아웃을 하여 작업한 내용을 넣거나 체크아웃 하기 전 미리 체인지리스트를 만들 수 있는 화면입니다. Submitted 기본 필터로는 현재 사용자가 제출한 체인지리스트를 볼 수 있습니다. 필터를 어떻게 적용하냐에 따라 다른 사용자가 제출한 내용도 볼 수 있습니다. 각 항목은 마우스 오른쪽 버튼을 클릭하면 상세 내용을 볼 수 있는 메뉴들을 볼 수 있습니다. Filter 기능 내가 원하는 조건에 따른 결과를 볼 수 있도록 하는 필터 기능입니다. 위에 메인메뉴에서 있던 Pending, Submitted 등의 메뉴에서 사용할 수 있습니다. -/+ 버튼으로 조건을 추가할 수 있습니다. User, Workspace, Files를 조건으로 검색할 수 있습니다. 필터 기능은 슬프게도 히스토리(History) 메뉴에는 없습니다. :( 각 필터 항목에 OR / AND 연산을 할 수 있는 쿼리가 지원되지 않습니다. 혹시나 해서 &amp;&amp; 나 || AND OR 등 지원되는 것이 없네요. :( 자주사용하는 필터는 저장해서 사용할 수 있습니다. 메뉴 상단 필터 버튼 &gt; Save Filter… &gt; 필터 이름입력 &gt; OK 검색(Search)각 메뉴에서 Ctrl + f (Cmd + f)를 누르면 검색할 수 있습니다. 다만 제한조건이 있습니다. 히스토리 메뉴에서는 Revision, Submitted By, Description 항목에 있는 내용으로 검색할 수 있습니다. 각 Pending, Submitted에서는 설명 메세지, 체인지리스트 값으로 검색할 수 있습니다. 다만 한계점은, 지금 리스트에 보이는 만큼에서만 검색됩니다. 퍼포스는 전체 체인지리스트를 한번에 받아오지 않게 되어있기 때문입니다. 검색 기능은 다소 불편하지만 스크롤을 쭉 내려서 검색하는 것도 방법입니다. 추가적으로 할 수 있는 방법은 HTML Tools를 사용해서 검색 툴을 만드는 것 정도가 있을 수 있겠습니다. https://www.perforce.com/.../enable-html-tools.html 예시 중에 Demo Run Queries 를 참고하면 전체 체인지리스트에서 검색할 수는 있어보입니다. 나중에 다른분들도 사용해볼 수 있도록 만든 뒤에 공유해보겠습니다. 마무리회사에서 SVN을 사용하다가 Perforce로 마이그레이션하면서 빠르고 편한 것도 있지만 여러 어려움을 겪고 있는데요. 기존에 검색되던 것들이 쉽게 검색되지 않는 것과 종종 발생하는 대규모 lock 사태 등.. 조금씩 사내 시스템에 개선해나가면 Perforce도 쓸만해지지 않을까라는 생각을 하며 다른 사용자분들도 잘 사용하고 계신지 궁금하네요. 다음 포스트에서 더 유익한 정보 가져오겠습니다. 감사합니다.","link":"/blog/2020/01/23/Perforce-basics/"},{"title":"Perforce Swarm 소개","text":"Perforce Swarm?이번 포스트에는 Perforce를 사용할 때 코드 리뷰를 하기 위해 사용하는 서비스인 Swarm을 소개해보려합니다. 공식 홈페이지: https://www.perforce.com/ko/jepum/helix-swarm 사실 Github, Gitlab, Bitbucket등 다른 소스 관리 서비스에서 기본적으로 제공하는 것을 따로 서비스로 제공하는 것이라 설치나 접근성 면에서 살짝 부족한 면은 좀 있습니다.Swarm 기능은 다른 소스 관리 서비스와 거의 동일하지만 살짝 훑어보겠습니다. Swarm 소개공식 홈페이지에 따르면 아래와 같은 기능을 소개하고 있습니다. 더 나은 코드를 위한 공동 작업 / 맞춤 알림 기본적인 리뷰 기능에 대한 소개입니다 화면이 가로로 분할되어 코드 변경 사항을 확인할 수 있고 코드에 바로 코멘트할 수 있습니다 사용자를 멘션할 수 있고 태스크를 만들어서 할당할 수 있습니다 그 외의 기능들 글로벌 리뷰 대시보드 멀티 팩터 인증 CI/CD 자동화 다양한 컨텐츠 리뷰 사실 코드 리뷰 서비스라 다른 기능에 대한 소개는 부가적인 내용들이어서 스킵했습니다 😈중요한 것은 리뷰 시스템이 얼마나 기본에 충실하냐인 것 같아요 Swarm 맛보기https://swarm.workshop.perforce.com/ Swarm workshop이라는 서비스를 Perforce에서 운영하고 있는데 Swarm 동작이 어떻게되는지 알 수 있습니다. Github 오픈소스 저장소처럼 어떻게 리뷰가 이뤄지고 코멘트가 어떻게 보이는지 알 수 있어요. https://swarm.workshop.perforce.com/explore/ 여기서 어떤 프로젝트가 있는지 볼 수 있으니 한번 개발이 활발한 프로젝트를 하나 들어가서 보겠습니다 Perforce 서버 쪽 패키지 관리 쪽 스크립트 저장소가 최근 활발했네요. 요것으로 보겠습니다.https://swarm.workshop.perforce.com/projects/perforce-software-sdp/reviews/ 작업 내역을 보니 최근 커밋, 리뷰 요청을 한 분이 열심히하고 있군요 ㅎㅎ 😸 리뷰 페이지 상단에는 브랜치, 리뷰자 유무, 검토 필요/수정 필요/승인됨 등 리뷰 현황을 필터링할 수 있는 기능이 있습니다. 리뷰 진행 상황(열림/닫힘)에 따라 볼 수 있기도 하네요. 대부분의 기능이 Github과 비슷하긴 하지만 열림/닫힘으로 표현되어있으니 리뷰가 완료되서 머지가 된 것인지 알려면 닫힘 탭으로 가서 “승인됨” 상태로 필터링해야 “이건 머지가 되지 않았을까?” 알 수 있겠네요.사실 정말 머지되었는지 알기는 어렵습니다. 승인만 되었지 실제 작업자가 머지 안했을 수 있으니까요. 참고: Github Pull requests 화면 실제 Swarm 서비스 화면 Swarm workshop 화면과 차이가 크지만 다른 소스 관리 서비스의 코드리뷰 기능과 비슷합니다.다만 회사에서 사용할때 아쉬웠던 점은 코드에 맞춰 하이라이팅되는 것이 부족하다고 느꼈었네요. Swarm 가이드 문서https://swarm.workshop.perforce.com/docs/ko/ Perforce 쪽에서 만든 가이드 문서(한국어)가 있는데 2015년 문서네요. 😂(영문 가이드 문서도 2016년 버전이라 사실상 관리가 잘 안되고 있는 것처럼 보입니다 ㅎㅎ..) 최신은 따로 Perforce쪽에 있으니 여기를 보시는게 나을 것 같습니다.https://www.perforce.com/manuals/swarm/Content/Swarm/home-swarm.html 마무리이렇게 Swarm을 짧게 살펴보았는데 그동안 다른 소스 관리 서비스에서 사용했던 코드 리뷰 시스템에 비해서 너무 날 것이 아닌가 싶기도 합니다. (뭔가 UI도 굉장히 옛날 것이고…) 최신 프론트엔드 UI 맛으로 업데이트할 계획은 없는지 궁금하지만 사실 뭐… 핵심 기능인 코드 리뷰가 잘 이뤄질 수만 있으면 된 것이겠죠 ㅎㅎ 다른 게임 개발사에서는 Swarm을 어떻게 쓰고 계신지 궁금하긴하네요.다음에는 저희는 Swarm을 어떻게 구성해서 사용하고 있는지 살펴보고 포스트할 수 있는게 있다면 남겨보겠습니다. 감사합니다~","link":"/blog/2022/02/28/Perforce-swarm/"},{"title":"Product Plan vs Release Plan 글을 보고","text":"원문https://www.aha.io/blog/the-product-plan-vs-the-release-plan Product Plan vs Release Plan?제목을 번역해보면 “제품 계획 vs 출시 계획”으로 볼 수 있겠네요처음에 이 글을 봤을 때, 두 계획이 다른 것은 이미 알고 있는데 어떻게 다른가에 대해 깊게 고민한적은 없었던 것 같습니다. 위 글에서 두 계획에 대해 정의한 것이 인상깊어 공부 겸 글 내용을 정리해보았습니다. “제품 계획은 제품의 전략적 방향을 정의하는 반면 출시 계획은 비전을 달성하는 데 필요한 작업을 정의합니다.” 두 계획 모두 중요하지만 다른 것을 정의하고 있습니다.제품 계획은 왜(Why) 이것을 만들고 있는지, 우리는 무엇(What) 을 성취하려고 하는지 답을 줍니다.출시 계획은 정확히 무엇(What) 을 빌드해야하는지, 언제(When) 만들 것인지, 제품 경험을 어떻게(How) 제공할 것인지를 정의합니다. 6하 원칙으로 정리하는게 깔끔하긴 하네요.제품 계획에는 왜 라는 프로덕트 목표 설정이 중요한 것 같고출시 계획에는 언제 어떻게 무엇을 전달 또는 배포할 수 있을지 정의하는 것이 중요하겠네요.Who, Where은 때에 따라 제품 계획에 들어갈 수 있을 것 같습니다. 😁 목표(Goal) 관점제품 계획 목표: 제품의 방향성을 전달하는 것. 전략 및 비즈니스 목표를 기반으로 제품이 비즈니스 가치를 제공하는 방법을 보여줍니다. 출시 계획 목표: 제품 팀이 수행할 작업에 대해 책임을 지도록 하는 것. 작업의 세부 사항을 분명히 하고 완료해야하는 작업 단계를 강조합니다. 목표 관점에서 각 계획이 가지는 목표는 성격이 다른 것은 누구나 알 수 있겠지만 저는 상위 방향성 vs 상위 방향성이 동작하게 하는 워크플로우, 프로세스 등의 집합체 정도로 이해했습니다.여기서 제 PM 업무를 떠올려보면 2가지 계획에 모두 기여를 해야하지만 출시 계획을 잡고 개발팀과 헉헉하느라 제품 계획에는 신경쓰지 못하는 것 같습니다. 😥 매 주기마다 개발부서들과 개발한 콘텐츠 업데이트와 라이브 이슈 대응의 연속.. 이니셔티브(initiative) 관점제품 계획: 향후 6개월에서 1년 동안 주요 테마, 초점 영역 및 기능을 나타내는 이니셔티브를 제시합니다. 출시 계획 : 전략적 이니셔티브가 존재한다고 가정하고 팀에 집중하는데 중점을 둡니다.출시 계획은 일상적인 성공을 위한 명확한 경로를 제시합니다. 출시 계획의 이니셔티브는 동기 부여, 책임에 관한 것입니다. 이 글에서 말하는 이니셔티브 개념은 목표를 달성하기 위한 액션 아이템 또는 액션 아이템들을 묶을 수 있는 계획이라고도 볼 수 있을 것 같습니다.액션 아이템과 목표를 잘 버무린 계획의 느낌이네요.OKR에서는 이니셔티브를 Key Result를 달성하기 위한 액션아이템, 어떻게 달성할지에 대한 것으로 정의하고 사용하는 케이스를 볼 수 있었습니다. 사실 사회에서 말하는 “이니셔티브”는 번역으로는 주도권, 주장이 되는 위치에서 이끌거나 지도할 수 있는 권리로 이야기하니 “권한”의 성격을 띄고 있습니다.기업에서 특정 이니셔티브 그룹에 가입하면서 이야기하는 “이니셔티브”는 계획에 더 가깝습니다. 특정 문제를 해결하기 위한 그룹 정도로 이해할 수 있을 것 같네요. 청중(Audience) 관점제품 계획: 외부 또는 내부 전략 로드맵으로 시각화할 수 있습니다. 고객을 위해 기대할 수 있는 새로운 기능 또는 개선 사항의 주요 영역을 제시합니다. 츨시 계획: 내부 제품 팀 및 기타 교차 기능 기여자를 위한 것. 향후 작업을 계획하고 해당 작업의 세부 정보를 추적하는 데 도움이 됩니다. 여기서 청중은 이 계획을 듣는 사람들을 의미하는 것 같습니다.제품 계획은 외부에 공유하는 러프한 로드맵 이런 것으로 바꿔서 사용할 수 있는 것,출시 계획은 내부 프로덕션 프로세스 문서, 업무 가이드가 될 것 같네요. 타임라인(Timeline) 관점제품 계획: 장기간에 걸친 전략적 목표와 이니셔티브를 제시합니다. 소프트웨어 회사의 경우 1년이 일반적입니다.출시 계획: 기능 배포 또는 주요 출시로 이어지는 특정 작업 단계를 추적합니다. 30, 60, 90일 단위인 경우가 많습니다. 제품 계획은 타임라인으로 보면 1년 계획 + 더 큰 차원의 계획도 있을 수 있겠다 싶습니다.예를 들면, 게임의 핵심 재미를 정의하고 어떻게 그 재미를 더 키울 수 있을까를 계획하거나 다른 맛을 곁들이거나 하는 등의 방향 설정이 있을 것 같아요. 출시 계획은 단순히 생각하면 업데이트 주기를 말할 수 있겠습니다. 그 주기에 맞춰 필요한 일들의 타임라인을 정리하고 프로세스화 한 것을 출시 계획으로 볼 수 있겠죠. 마무리글 마지막에는 “How do you use product plans and release plans in your work?” 라고 질문을 해주었는데 글을 읽다보니 저는 제품 계획이 잘 이뤄질 수 있도록 출시 계획을 관리하고 있었구나 싶었습니다. Being responsible for a product plan and a release plan challenges product managers to think about every element of delivering a Complete Product Experience. It is a good way to encourage both big and small thinking. 이런 말을 글 마지막에 크게 달아뒀는데 각 계획을 정의하고 그 정의에 맞춰 일을 정리해나가는 것이 좋은 경험이 되는 것 같습니다.어떤 게임 개발사는 패키지 형태로 한번에 빡 출시하고, 어떤 개발사는 얼리억세스부터 지속적인 업데이트를 통해 출시하고 여러 방법이 있으니 각자의 계획이 다 다르겠죠 어쨌든 각자의 계획이 다 있는 것 아니겠습니까 😁 우리는 어떤 계획을 가지고 살고 있는지, 2개의 계획을 분리해서 보자면 어떻게 정의하고 있는지 생각해볼 수 있는 시간이었어서 재미있는 글이었습니다.다른 재미있는 글들도 있으니 나중에 보고 또 공부 겸 포스트해보겠습니다.","link":"/blog/2022/07/02/Productplan-vs-releaseplan/"},{"title":"ScriptRunner: Custom Field 다루기","text":"스크립트러너에서 Jira 이슈의 커스텀 필드를 다루는 경우가 많습니다.저는 어떻게 스크립트러너에서 커스텀 필드의 값을 가져오고, 수정하고 있는지 다뤄보겠습니다. ScriptRunner란? (복습)기존에 있는 포스트를 보시면 좋을 것 같습니다.그중에 2번째 포스트에서 설명했던 Script Console에서 실습해보겠습니다. ScriptRunner 소개 1 ScriptRunner 소개 2 ScriptRunner 소개 3 ScriptRunner 소개 4 시스템 테스트 환경스크립트러너는 jira 버전에 영향을 좀 받아서 환경도 미리 알고 계셔야합니다.(버전에 따라 내부 함수들이 변경됨에 따라 실제 코드도 조금씩 변경됩니다) Jira: Jira Software 8.3.2 ScriptRunner: 5.6.1.1-jira8 커스텀 필드(Custom Field) 값 가져오기간단하게 커스텀 필드 값을 가져오는 코드를 보면서 설명하겠습니다.코드는 groovy로 작성하며 Script Console에서 테스트해보았습니다. 123456789101112131415// importimport com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.issue.MutableIssue;// functionsString getCustomFieldValue(MutableIssue issue, String cfName) { def customFieldManager = ComponentAccessor.getCustomFieldManager(); def cfObj = customFieldManager.getCustomFieldObjectsByName(cfName)[0]; String cfValue = issue.getCustomFieldValue(cfObj); return cfValue;}def issueMgr = ComponentAccessor.getIssueManager();MutableIssue issue = issueMgr.getIssueObject(&quot;PUBGTEST-169&quot;);getCustomFieldValue(issue, &quot;Translation&quot;); 복사 &amp; 붙여넣기 하시고 이슈 키, 커스텀 필드 이름만 바꿔서 입력해주시면해당 이슈의 커스텀 필드 값을 가져올 수 있는 코드입니다.코드에서 중요한 부분만 간단하게 보고 커스텀 필드 값 수정으로 넘어가겠습니다. getCustomFieldValue(issue, cfName) 함수이슈 오브젝트와 커스텀 필드 이름을 받아 커스텀 필드 값을 반환하는 함수입니다. CustomFieldManager를 사용하여 커스텀 필드 오브젝트를 가져옵니다. 배열로 가져오는 함수(getCustomFieldObjectsByName())를 사용하였습니다. getCustomFieldObjectByName()도 있지만 배열로 가져오는 함수를 권장하고 있습니다. 같은 이름의 커스텀 필드가 있을 수 있기에 배열로 가져오는 함수를 권장하는 것 같네요. issue에 있는 함수 getCustomFieldValue()로 커스텀 필드 오브젝트를 이용해 커스텀 필드 값을 가져옵니다. 커스텀 필드 값을 리턴합니다. 코드 실행 결과Script Console 실행 결과도 보여드리겠습니다. 콘솔에서는 코드 실행 후 마지막에 있는 오브젝트의 값을 보여줍니다.log에서 출력한 내용은 logs 탭에서 볼 수 있습니다. 커스텀 필드(Custom Field) 값 수정하기커스텀 필드의 값을 확인했으니 수정도 해볼 수 있어야겠죠?!값을 가져오는 것보다 코드가 조금 더 추가됩니다. 12345678910111213141516171819202122232425// importimport com.atlassian.jira.event.type.EventDispatchOptionimport com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.issue.MutableIssue;// functionsString getCustomFieldValue(MutableIssue issue, String cfName) { def customFieldManager = ComponentAccessor.getCustomFieldManager(); def cfObj = customFieldManager.getCustomFieldObjectsByName(cfName)[0]; String cfValue = issue.getCustomFieldValue(cfObj); return cfValue;}def setCustomFieldValue(MutableIssue issue, String cfName, String str) { def issueMgr = ComponentAccessor.getIssueManager(); def customFieldManager = ComponentAccessor.getCustomFieldManager(); def user = ComponentAccessor.getJiraAuthenticationContext().getLoggedInUser(); def cfObj = customFieldManager.getCustomFieldObjectsByName(cfName)[0]; issue.setCustomFieldValue(cfObj, str); issueMgr.updateIssue(user, issue, EventDispatchOption.DO_NOT_DISPATCH, false);}def issueMgr = ComponentAccessor.getIssueManager();MutableIssue issue = issueMgr.getIssueObject(&quot;PUBGTEST-169&quot;);setCustomFieldValue(issue, &quot;Translation&quot;, &quot;TEST&quot;);getCustomFieldValue(issue, &quot;Translation&quot;); 앞서 값을 가져오는 코드와 마찬가지로 “TEST”에 있는 값을 바꾸면 적용해보실 수 있습니다.다만 주의하실 점은 커스텀 필드의 타입이 텍스트 타입이어야합니다.Label, Checkbox 등 다른 타입일 경우에는 동작하지 않는 코드입니다. setCustomFieldValue(issue, cfName, str)값을 가져오는 코드와 다른 부분만 설명드리겠습니다. issueMgr: 이슈 매니저로 이슈 업데이트를 위해 함수 내에 선언합니다. usr: 이슈 업데이트를 하려면 업데이트하는 사용자 오브젝트가 필요하여 선언합니다. issue.setCustomFieldValue(cfObj, str); 이 함수를 통해 커스텀 필드 값이 변경됩니다. 이 코드만 실행할 경우, 실제 반영은 되지 않습니다. (함수 동작시에만 변경됨) issueMgr.updateIssue() 이 함수를 통해 앞에서 setCustomFieldValue()에서 변경된 내용이 반영됩니다. 커스텀 필드 수정과 관련한 질문은 Google에 검색만 하더라도 많이 나옵니다.(첫번째 글을 보시는 것을 추천합니다.) community.atlassian.com/Set-custom-field-value-Script-Runner community.atlassian.com/Basic-method-to-update-a-custom-field-with-Scriptrunner 코드 실행 결과 실제로 TEST로 변경된 것을 볼 수 있습니다. 마무리이렇게 스크립트러너로 Jira 이슈의 커스텀 필드를 다뤄보았습니다.처음에는 어려울 수 있지만 조금씩 다뤄보면 그렇게 어렵지 않습니다.쉽게 따라하고 적용해보실 수 있는 내용으로 추가 포스트해보겠습니다. 감사합니다. :)","link":"/blog/2019/10/12/ScriptRunner-Custom-Field/"},{"title":"Qingmi Smart Powerstrip timeout 문제 해결","text":"Qingmi Smart Powerstrip 연결 문제최근에 스마트 홈 구축에 계속 빠져서 이것저것 찾아보다가 스마트 플러그 제품을 구매해보았습니다구매 링크: https://smartstore.naver.com/shop360/products/611051018 여기서 제가 구매한 제품은 5구 스마트 멀티탭(Qingmi 스마트 파워스트립) 입니다앱에 연결하려다 연결이 되지 않고 연결 시간 초과 현상이 지속되는 문제가 있었는데 해결해보았습니다빠르게 문제 상황 &amp; 문제 해결방법으로 가보겠습니다 문제 해결빠르게 문제 해결만 보고 싶으신 분들을 위해 해결 방법부터 정리합니다 Mi 홈 계정 생성시 중국 계정으로 생성해야 함 샤오미 중국 계정으로 생성해야 중국 본토 지역에서 사용 가능한 기능들을 사용할 수 있음 샤오미 중국 계정의 ID는 4294967295 (32bit) 보다 작은 값으로 설정됨 샤오미 중국 계정으로 연결 성공 문제 상황문제 상황에 대해 짧게 정리해보면 아래와 같습니다 Mi 홈 앱에서 Qingmi 스마트 플러그를 찾아 연결을 시작한다 앱에서 나온 설명대로 플러그 연결을 진행한다 와이파이, 스마트 플러그, 스마트폰을 가깝게 둔다 연결 완료를 기다리지만 연결 실패가 계속 발생한다 연결시 확인했던 준비사항 Mi 홈 앱에서 지역을 중국 (본토)로 설정 와이파이 2.4GHz 인지 확인 와이파이 비밀번호 정확한지 확인 와이파이 무선 인터넷 채널 10 채널 미만인지 확인 와이파이 DNS 블로킹으로 샤오미 클라우드가 막혀있는지 확인 나중에 알게된 확인해야했던 사항샤오미 계정 중국 계정인지 확인 계정 ID 값이 4294967295 (32bit) 미만 값 인지 확인 한국 계정으로 만들었을 때는 65xxxxxxxx 값으로 32비트 값이 초과된 값이었음 https://forum.yeelight.com/t/topic/9582 참고 문제 해결 후기사고 나서 약 2주 뒤에나 해결할 수 있었던게 다행인지 아닌지 모르겠지만지금은 잘 사용하고 있습니다. :)다음 포스트는 어떻게 잘 사용하고 있는지를 올려볼 수 있으면 좋겠네요.","link":"/blog/2019/07/21/Qingmi-smart-powerstrip-timeout/"},{"title":"Sentry - Uneal Engine 4.27 integration","text":"준비 사항⚠️ 프로젝트가 C++ 클래스를 빌드할 수 있는 상태여야 합니다. (가이드 문서 내용) Currently, this method is available only for C++ UE projects. Blueprint projects can be converted to a C++ one by adding an empty class using the editor.→ 현재 이 메서드는 C++ UE 프로젝트에서만 사용할 수 있습니다. 블루프린트 프로젝트는 에디터를 사용하여 빈 클래스를 추가하여 C++ 프로젝트로 변환할 수 있습니다. C++ 클래스 빌드를 위해서는 Visual Studio 설치가 필요합니다.관련 구성요소를 설치해야하는데 설치해야하는 것은 다음과 같습니다. .Net 데스크톱 개발, C++를 사용한 데스크톱 개발, 유니버설 Windows 플랫폼 개발 설치, 설정 방법https://docs.sentry.io/platforms/unreal/https://github.com/getsentry/sentry-unreal 설치 방법은 간단합니다. Github에서 Sentry-unreal 소스를 받는다. 4.27 버전 엔진의 경우 0.5.0 버전을 받아야함. 5.0 이상 엔진의 경우 최신 버전을 사용할 수 있음 (현재는 0.7.0) 받은 소스를 프로젝트 폴더/Plugins 폴더 하위에 옮긴다. 프로젝트를 실행한다. 프로젝트 실행시 플러그인을 빌드하겠냐는 팝업이 실행되면 빌드한다 이후 문서 가이드를 참고하여 설정한다 https://docs.sentry.io/platforms/unreal/#configure 설정 상세 Project Settings &gt; 프로젝트-패키징 &gt; 패키징 &gt; 크래시 리포터 포함에 체크해줍니다. Project Settings &gt; Plugins &gt; Sentry 에서 DSN 값을 설정해줍니다. 가이드 문서에서 Text 블록에 있는 텍스트를 클릭하면 현재 생성해둔 프로젝트들의 DSN 값을 골라서 볼 수 있습니다. DSN 설정 후 하단에 있는 Crash Reporter Endpoint도 설정해줍니다. 크래시 리포터를 통해 크래시 덤프 업로드하는 곳을 설정해주는 것입니다. DSN, Crash Reporter Endpoint URL은 Sentry 웹페이지에서 프로젝트 &gt; 프로젝트 설정 &gt; SDK SETUP - Client Keys(DSN)에 있습니다 설정 후 크래시 테스트저는 크래시 테스트를 위해 기본 프로젝트 생성 후 아래와 같이 진행했습니다. 기본 프로젝트 생성 파일 &gt; 새로운 C++ 클래스 추가 &gt; Game Mode Base 선택 &gt; Game Mode 클래스(ex. MyGameModeBase class) 추가 MyGameModeBase에 콘솔 명령어 함수 작성 에디터에서 월드 세팅 &gt; Game Mode &gt; 게임 모드 오버라이드에서 MyGameModeBase 설정 컴파일 후 프로젝트 패키지하여 프로그램 실행 테스트 코드 크래시 센트리 업로드 확인프로젝트 패키지로 만들어진 바이너리 실행 후 크래시를 발생시킵니다.저는 크래시 발생시키는 명령어 이름을 crashMe로 지어두었고 콘솔 명령어로 실행하면 아래와 같이 크래시 리포터가 뜨게됩니다. “Send and Close”로 크래시 정보를 보내면 센트리에서 크래시 정보를 볼 수 있게됩니다. 마무리이번 포스트에서는 간단히 센트리-언리얼 엔진 설정을 다뤄봤는데 글은 간단했지만..실제로 크래시를 일으키기 위해 어떻게 해야할지 여러가지 난관이 있었네요.(언리얼 엔진 에디터에서 처음 빌드해보고 Visual Studio로 연결하는 것도 처음이다보니 좀 걸렸습니다. 😅)다음 포스트에는 다른 크래시 분석 툴을 설정해보고 포스트 남겨보겠습니다. 감사합니다. 🙏 설치중 에러 참고ERROR: Could not find NetFxSDK install dir; this will prevent SwarmInterface from installing. Install a version of .NET Framework SDK at 4.6.0 or higher. Visual Studio에서 빌드에 필요한 컴포넌트가 설치되어 있지 않아 발생하는 문제. .Net 데스크톱 개발, C++를 사용한 데스크톱 개발, 유니버설 Windows 플랫폼 개발 설치 Plugin build fail 플러그인이 소스코드만 포함되어있는 상태라면 Visual Studio 설치가 필요합니다. Visual Studio를 설치해주세요.","link":"/blog/2023/06/25/Sentry-UnealEngine-427-integration/"},{"title":"ScriptRunner Jira Issue Label 추가시 자동으로 watcher 추가","text":"스크립트러너에서 Jira 이슈의 Label 추가에 따라 자동으로 특정 사람들을 와쳐(watcher)에 추가하는 방법을 다뤄봅니다. 시스템 테스트 환경 Jira: Jira Software 8.3.2 ScriptRunner: 5.6.1.1-jira8 참고 포스트 Listener에 대한 내용 참고 포스트: ScriptRunner 소개 2 Label 관련 내용을 다룬 포스트: ScriptRunner Label 다루기 사용 시나리오적용하는 방법 전에 제가 사용하고 있는 시나리오를 공유드립니다.특정 이벤트에 따라 와쳐를 추가할 수 있으니 이벤트만 잘 고려해서 와쳐 추가 코드만 사용하셔도 괜찮습니다. 특정 레이블(Label)이 이슈에 추가됨 레이블이 추가된 이슈에 원하는 인원을 와쳐 필드에 입력함 와쳐 인원 입력은 복수의 인원이 가능해야함 여기서 특정 이벤트는 레이블 추가 입니다.다른 이벤트의 예시로는 컴포넌트 추가, 특정 커스텀 필드 값의 변경 등 다양하게 조건을 변경해볼 수 있을 것 같네요. 적용앞서 설명드린 시나리오대로 적용해보겠습니다.바로 적용해보고 싶으신 분들을 위해 먼저 코드와 설정 화면을 보여드리겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import com.atlassian.jira.component.ComponentAccessor;import java.util.List;def watcherManager = ComponentAccessor.getWatcherManager();def userManager = ComponentAccessor.getUserManager();// Add users to watcher fielddef watchUsers = {usernames -&gt; usernames.each { def user = userManager.getUserByKey(it.toString()); watcherManager.startWatching(user, event.issue); }}// Remove users on watcher fielddef unwatchUsers = {usernames -&gt; usernames.each { def user = userManager.getUserByKey(it.toString()); watcherManager.stopWatching(user, event.issue); }}def labelWatch = {String label, List users, String[] oldArr, String[] newArr, boolean isCaseSensitive -&gt; String[] tmpOldArr = oldArr.collect {String i -&gt; if (isCaseSensitive) return i; else return i.toLowerCase(); }; String[] tmpNewArr = newArr.collect {String i -&gt; if (isCaseSensitive) return i; else return i.toLowerCase(); } String tmpLabel = isCaseSensitive ? label : label.toLowerCase(); if (tmpOldArr.contains(tmpLabel) == false &amp;&amp; tmpNewArr.contains(tmpLabel) == true) { watchUsers(users); } if (tmpOldArr.contains(tmpLabel) == true &amp;&amp; tmpNewArr.contains(tmpLabel) == false) { unwatchUsers(users); }}def labelWatchCreated = {String label, List users, boolean isCaseSensitive -&gt; String[] labels = event.issue.labels as String[]; String[] tmpLabels = labels.collect {String i -&gt; if (isCaseSensitive) return i; else return i.toLowerCase(); } String tmpLabel = isCaseSensitive ? label : label.toLowerCase(); if (tmpLabels.contains(tmpLabel)) { watchUsers(users); }}def change = event?.getChangeLog()?.getRelated(&quot;ChildChangeItem&quot;)?.find {it.field == &quot;labels&quot;};if (change) { // Issue Updated case String[] oldArr = change.oldstring.toString().tokenize(); String[] newArr = change.newstring.toString().tokenize(); labelWatch(&quot;m&quot;, [&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;], oldArr, newArr, false); labelWatch(&quot;b&quot;, [&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;b5&quot;], oldArr, newArr, true);} else { // Issue Created case: ${event.issue} ${event.issue.labels} labelWatchCreated(&quot;m&quot;, [&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;], false); labelWatchCreated(&quot;b&quot;, [&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;b5&quot;], true);} 참고위와 같이 설정하고 Update 버튼을 눌러주시면 적용됩니다.코드가 깔끔하지는 않으나 동작하고 있는 코드입니다. (코드 개선은 향후 조금씩 진행해보겠습니다.)다만 적용 전에 각자에 맞게 설정해야하는 값은 아래와 같습니다. labelWatch()를 호출시 “m”은 레이블 이름을, []안에는 와쳐 필드에 추가하고자 하는 유저의 아이디들을 입력해주세요. labelWatchCreated()를 호출시 1번 항목과 동일하게 입력해주세요. 이 함수를 추가하는 이유는 이슈 생성시 이벤트가 다르게 처리되기 때문입니다. 이슈 생성시 이벤트를 실행시키지 않고자 한다면 해당 코드를 지워도 괜찮습니다. labelWatch(), labelWatchCreated() 함수 마지막 인자는 레이블의 대소문자를 구분할 것인지에 대한 변수입니다. 레이블 값의 대소문자를 구분하고자한다면 true, 아니라면 false 값을 넣고 호출해주세요. 코드 설명코드에 대한 설명 내용이 많지않지만 각 함수별로 짧게 설명드리겠습니다. watchUsers(usernames) / unwatchUsers(usernames)변수로 전달받은 유저들을 이벤트가 발생한 이슈의 와쳐 필드에 입력/삭제합니다. 12345678910111213141516def watcherManager = ComponentAccessor.getWatcherManager();def userManager = ComponentAccessor.getUserManager();// Add users to watcher fielddef watchUsers = {usernames -&gt; usernames.each { def user = userManager.getUserByKey(it.toString()); watcherManager.startWatching(user, event.issue); }}// Remove users on watcher fielddef unwatchUsers = {usernames -&gt; usernames.each { def user = userManager.getUserByKey(it.toString()); watcherManager.stopWatching(user, event.issue); }} 유저를 의미하는 usernames이라는 string 배열 인수를 받아 처리합니다. watcherManager에 있는 startWatching(), stopWatching() 함수로 와쳐를 추가하고 삭제합니다. labelWatch (label, users, oldArr, newArr, isCaseSensitive)레이블과 변경전 레이블 배열, 변경후 레이블 배열을 받아 레이블이 변경되었는지 확인합니다. 추가적으로 isCaseSensitive 인수를 통해 레이블의 대소문자를 구분하여 확인합니다.확인 후, 받은 유저들을 이슈의 와쳐 필드에 추가 또는 삭제합니다.(watchUsers(), unwatchUsers() 함수로)이슈가 업데이트될 경우에만 호출되는 함수입니다. 생성시에는 아래에 있는 labelWatchCreated() 함수가 호출됩니다. labelWatchCreated(label, users, isCaseSensitive)이슈 생성시에는 변경된 사항이 없기에 issue Created 이벤트를 받아 처리해야했습니다.추가 함수를 통해 이슈 생성시에도 와쳐가 추가될 수 있도록 만든 함수입니다. labelWatch() 함수처럼 레이블과 유저를 받고 받은 레이블이 값에 있을 경우 유저를 이슈의 와쳐 필드에 추가합니다. 실행 코드실행 코드는 위에서 설명한 함수를 사용하여 와쳐 추가를 실행합니다. 1234567891011121314def change = event?.getChangeLog()?.getRelated(&quot;ChildChangeItem&quot;)?.find {it.field == &quot;labels&quot;};if (change) { // Issue Updated case String[] oldArr = change.oldstring.toString().tokenize(); String[] newArr = change.newstring.toString().tokenize(); labelWatch(&quot;m&quot;, [&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;], oldArr, newArr, false); labelWatch(&quot;b&quot;, [&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;b5&quot;], oldArr, newArr, true);} else { // Issue Created case: ${event.issue} ${event.issue.labels} labelWatchCreated(&quot;m&quot;, [&quot;m1&quot;, &quot;m2&quot;, &quot;m3&quot;], false); labelWatchCreated(&quot;b&quot;, [&quot;b1&quot;, &quot;b2&quot;, &quot;b3&quot;, &quot;b4&quot;, &quot;b5&quot;], true);} 마무리실제로 빠르게 적용해보고 사용해본 코드라 깔끔하지 않을 수 있지만다른분들도 사용해볼 수 있도록 포스트해보았습니다. 업무에 도움이 될 수 있기를 바라며 다른 방법도 추후에 올려보겠습니다.감사합니다.","link":"/blog/2019/12/01/ScriptRunner-Label-autowatch/"},{"title":"베이킹(Baking)이란 무엇일까?","text":"Baking이 뭐죠? 🍞 🥖 🍩 ⚠️ 기술적으로 깊게 다루는 글이 아닌 그래픽스, 렌더링과 관련한 공부 중에 정리한 내용입니다.일부 기술적인 내용은 오류가 있을 수 있습니다. 사전적 의미의 Baking 굽다, 구워지다, 굽기 빵을 굽다 / 햇볕에 피부를 태운다는 뜻으로 쓴다(?) CG(Computer Graphics)에서의 Baking은?위키에서 설명하는 Baking을 찾아보았습니다. (번역을 돌려보겠습니다. 🤖) https://en.wikipedia.org/wiki/Texture_mapping#Baking As an optimization, it is possible to render detail from a complex, high-resolution model or expensive process (such as global illumination) into a surface texture (possibly on a low-resolution model). Baking is also known as render mapping. This technique is most commonly used for light maps, but may also be used to generate normal maps and displacement maps. Some computer games (e.g. Messiah) have used this technique. The original Quake software engine used on-the-fly baking to combine light maps and colour maps (\"surface caching\"). Baking can be used as a form of level of detail generation, where a complex scene with many different elements and materials may be approximated by a single element with a single texture, which is then algorithmically reduced for lower rendering cost and fewer drawcalls. It is also used to take high-detail models from 3D sculpting software and point cloud scanning and approximate them with meshes more suitable for realtime rendering. 베이킹은 최적화로 복잡한 고해상도 모델 또는 비싼 프로세스(예: GI, Global Illumination)의 세부 정보를 표면 텍스처(저해상도 모델에서 가능)로 렌더링하는 것이 가능합니다. 베이킹은 렌더 매핑이라고도 합니다. 이 기술은 라이트 맵에 가장 일반적으로 사용되지만 노멀 맵과 변위 맵을 생성하는 데에도 사용할 수 있습니다. 일부 컴퓨터 게임(예: Messiah)은 이 기술을 사용했습니다. 원래 Quake 소프트웨어 엔진은 즉석 베이킹을 사용하여 라이트 맵과 컬러 맵(“표면 캐싱”)을 결합했습니다. 베이킹은 LOD(Level Of Detail) 생성의 한 형태로 사용할 수 있습니다. 여기에서 다양한 요소와 재질이 포함된 복잡한 장면은 단일 텍스처가 있는 단일 요소로 근사화될 수 있으며, 그런 다음 알고리즘을 통해 렌더링 비용을 낮추고 드로콜을 줄일 수 있습니다. 또한 3D 조각 소프트웨어 및 포인트 클라우드 스캐닝에서 세부 모델을 가져와 실시간 렌더링에 더 적합한 메시로 근사하는 데 사용됩니다. https://en.m.wikipedia.org/wiki/Glossary_of_computer_graphics#baking Performing an expensive calculation offline, and caching the results in a Texture map or Vertex attributes. Typically used for generating lightmaps, normal maps, or low level of detail models. 오프라인에서 값비싼 계산을 수행하고 결과를 텍스처 맵 또는 버텍스(Vertex) 속성으로 캐싱합니다.일반적으로 라이트맵, 노말 맵 또는 낮은 수준의 LOD(Level of Detail)을 생성하는 데 사용됩니다. Texture baking, Light baking 등이 있으며 텍스쳐나 빛을 렌더링할 때 미리 만들어둔 결과물로 빠르게 효율적으로(저렴한 비용으로) 렌더링할 수 있도록 미리 만들어두는 것으로 굳이 비유하자면.. 빵을 먹을때 밀가루 반죽하고 휴지하고 틀에 넣고 굽고 먹는 것이 아니라미리 반죽 준비해두고 오븐도 예열해두고 바로 구워먹을 수 있게 준비해두는 것(혹은 다 구워두고 먹기만하는 것) 정도로 비유할 수 있겠네요. 왜 Baking 하나요?오브젝트를 렌더링하기 전에 미리 준비할 수 있는 것들을 준비해서 실제 렌더링할 때 가져다가 효율적으로 렌더링하는 것이 좋잖아요.왜 효율적으로 렌더링해야하죠? 더 많은 오브젝트를 부드럽고 높은 품질로(이쁘게) 렌더링할 수 있으니까요. 미션임파서블 - 고스트 프로토콜 복도씬 https://youtu.be/k9HGylRFS-U?t=27 조금 다른 예시지만 미리 만들어두고 다른 것을 할 수도 있죠. 😈 빛과 텍스쳐 변화에 맞춰 실시간 연산 처리가 가능한 하드웨어 스펙과 기술이 늘어나고 있지만베이킹된 텍스쳐 맵, 노멀 맵, 라이트 맵 등을 사용하면 렌더링할 때 비용을 크게 절약할 수 있습니다. 맵(Map)? 매핑(Mapping)?텍스쳐를 이쁘고 효율적으로 렌더링하기 위해서 많은 기술들이 들어갑니다.실제로 오브젝트의 매시(mesh)를 상세하게 만들어서 렌더링할 수 있겠지만 매시를 상세하게 만들수록 렌더링 비용이 증가하게 됩니다. 렌더링시 실제로 보이는 결과물이 거의 동일하지만 매시는 덜 자세하게 만들고 매핑 기술들을 적용하여 렌더링 비용을 줄일 수 있죠. 주로 언급되는 매핑 기술들은 범프 매핑, 법선 매핑(노말 매핑), 시차 매핑(Parallax Mapping), 변위 매핑(Displacement Mapping), 라이트 매핑(Light Mapping, Lightmap), 쉐도우 매핑(Shadow Mapping) 등이 있고 이외에도 많은 기술들이 있습니다. 사실 매핑과 관련한 내용들이 많아서 그래픽스 엔지니어, TA나 아티스트가 아니라면 다 상세하게 알기는 쉽지 않을 것 같네요.이런 기술들이 우리가 렌더링된 영상을 볼때 적용되어있다 정도만 알아주세요. 😸 https://ko.m.wikipedia.org/wiki/텍스처_매핑 https://en.m.wikipedia.org/wiki/Bump_mapping https://en.m.wikipedia.org/wiki/Normal_mapping https://en.m.wikipedia.org/wiki/Parallax_mapping https://en.m.wikipedia.org/wiki/Displacement_mapping https://en.m.wikipedia.org/wiki/Lightmap 언리얼 엔진에서는 텍스쳐를 이런식으로 데이터들을 연결해서 머터리얼 + 매시로 물체들을 렌더링합니다.언리얼 엔진뿐만 아니라 최신 게임 엔진에서는 위와 같은 PBR(Physically Based Rendering)을 이용하여 렌더링합니다. (표면의 재질에 따른 빛의 반사가 물리적으로 어떻게 이루어지는지를 시뮬레이션해서 그래픽을 표현하는 기법으로 https://namu.wiki/w/물리 기반 렌더링 자세한 내용은 나무위키를 참고해보세요.) Baking할 때 주로 어떤 것을 굽나요?앞서 살펴보았던 내용을 다시 가져왔습니다. https://en.m.wikipedia.org/wiki/Glossary_of_computer_graphics#baking Performing an expensive calculation offline, and caching the results in a Texture map or Vertex attributes. Typically used for generating lightmaps, normal maps, or low level of detail models. 오프라인에서 값비싼 계산을 수행하고 결과를 텍스처 맵 또는 버텍스(Vertex) 속성으로 캐싱합니다.일반적으로 라이트맵, 노말 맵 또는 낮은 수준의 LOD(Level of Detail)을 생성하는 데 사용됩니다. 여기서 오프라인의 의미는 실제 렌더링이 이뤄지지 않는 환경을 의미합니다.실시간으로 렌더링하기에 비용이 큰 라이트맵, 노말 맵, LOD를 미리 만들어두는 것이죠.앞서 위키 링크를 첨부해두었지만 각각 항목에 대해 살펴보겠습니다. 라이트맵(LightMap)https://en.m.wikipedia.org/wiki/Lightmap 위와 같은 화면(Scene)에 설정되어있는 빛(해, 조명 등 빛 오브젝트)에 따라 보이는 빛나는 부분과 어두운 부분에 대해 맵을 만든 것을 라이트맵(LightMap)이라고 합니다. 간단하게 라이트맵은 빛에 따라 보이는 것을 텍스처로 만들었다고 볼 수 있습니다.실시간으로 빛을 계산해서 보여줄 필요없이 텍스처를 보여주어 렌더링시 비용을 절약합니다. 다만 라이트맵은 정적인 물체, 환경에 대해 생성할 수 있다는 제한이 있습니다.물론 최신 게임 엔진에서 지원하는 기능 중에는 움직이는 물체에 대해 라이트맵을 생성 및 적용할 수 있는 기능을 지원할 수도 있습니다만.. 아마 빛 자체를 실시간 렌더링하는 기술이지 않을까 싶습니다. Unity에서는 Light Prove(라이트 프로브)를 이용해서 빛의 실시간 렌더링을 일부 지원하고 있고,Unreal Engine 5에서는 루멘(Lumen) 시스템을 이용해서 빛의 실시간 렌더링을 모두 지원한다고 하네요. (강력하다..) 잠시 딴길로 갔지만 정리해보면,라이트맵은 빛에 따라 표현되는 것을 텍스처(이미지)로 만들어서 렌더링할 때 비용을 줄일 수 있는 친구입니다. 노말 맵(Normal Map)https://en.m.wikipedia.org/wiki/Normal_mapping 링크는 노말 매핑이지만 노말 매핑에 사용되는 것이 노말 맵이니 참고할 수 있겠습니다.노말 매핑은 튀어나온 곳, 움푹 들어간 곳의 빛을 왜곡하는 기법입니다. 노말 매핑을 사용하면 많은 폴리곤을 사용하지 않고 세세한 부분을 표현할 수 있습니다. 위와 같이 매시의 폴리곤 수를 줄이고 노말 매핑을 적용하면 폴리곤이 많은 매시의 효과를 볼 수 있습니다. 왼쪽 이미지: 평평한 텍스처 이미지입니다. 중간 이미지: 노말 맵으로 빛의 XYZ를 RGB로 표현한 맵 이미지입니다. 오른쪽 이미지: 왼쪽 이미지에 중간 이미지의 노말 맵을 노말 매핑한 최종 렌더링된 모습입니다. 정리해보면 노말 맵은 오브젝트의 굴곡을 표현할 수 있는 빛의 벡터 정보를 갖는 데이터입니다. LOD(Level Of Detail)https://en.m.wikipedia.org/wiki/Level_of_detail_(computer_graphics) 직역하면 세부 수준(…)이지만 오브젝트의 세부 표현을 레벨(또는 거리)에 따라 표현한다 정도로 이해하면될 것 같습니다. LOD를 적용하면 아래와 같은 장점이 있습니다. 멀리있는 오브젝트를 자세하게 표현하지 않아 비용을 줄일 수 있습니다. 멀리있는 오브젝트를 덜 자세하게 표현하여 자연스럽게 표현할 수 있습니다.(실제 멀리 있는 물체를 보았을 때 작고 흐릿하게 보이는 것처럼 표현되어야 자연스럽기 때문이죠.) 언리얼 엔진에서는 LOD 0가 가장 자세하게 표현하고 LOD 1, LOD 2 이렇게 점차 덜 자세하게 표현합니다. 위 이미지는 각 플랫폼 별로 표현할 LOD 기준을 정하고 상황에 맞춰 렌더링 될 수 있도록 설정한 것을 보여주고 있네요. LOD는 밉맵(MipMap)을 이용하여 적용할 수도 있고 언리얼 엔진처럼 LOD 레벨별로 매시&amp;텍스쳐를 설정할 수도 있습니다.여기서 밉맵은 렌더링 속도를 향상시키기 위한 목적으로 기본 텍스처와 이를 연속적으로 미리 축소시킨 텍스처들로 이루어진 비트맵 이미지의 집합입니다. (자세한 내용은 위키를 참고해주세요.) 정리해보면 LOD는 가까울수록 자세하게 보이게하는 방식입니다.(구현에 따라 다르게 보이게 설정할 수도 있지만 일반적인 정의로 이해해주세요) Baking 결과물로 뭘하죠?베이킹 결과물인 라이트 맵, 노말 맵, LOD로 오브젝트들을 렌더링할 때에 사용합니다.매시의 상세(디테일)를 줄이고 여러 매핑 기술을 적용해서 렌더링 비용을 줄이고 빠르게 표현할 수 있죠. 마무리: 이제 Baking이 뭔지 대략 이해했나요?저는 처음에는 Bake, Baking이 그냥 빵을 굽는 정도의 뭔가 미리 컴파일 같은 것을 해두고 사용한 것인가 싶었는데요.이번에 정리하면서 베이킹을 하고 반영하기 위해 많은 기술들이 들어간 것을 공부할 수 있었습니다. 주로 위키를 통해서 베이킹이나 그래픽스와 관련한 내용들을 알아볼 수 있었는데 조금 더 깊게 그래픽스 엔지니어링과 관련한 일반적인 지식도 공부하고 싶어졌네요. https://gabrielgambetta.com/computer-graphics-from-scratch/ 컴퓨터 그래픽스를 한번 쓱 훑어보기 좋을 것 같아 한번 읽어보고 포스트 남겨보겠습니다. 😄","link":"/blog/2021/09/19/What-is-Baking/"},{"title":"ScriptRunner Label 다루기","text":"스크립트러너에서 Jira 이슈의 Label 값을 수정하는 경우가 종종 있는데 어떻게 추가/수정하는지이번 포스트에서 다뤄보겠습니다. 이번에도 Script Console에서 코드를 실행시켜보고 저는 어떤 케이스에서 사용하는지 설명드리겠습니다. 시스템 테스트 환경스크립트러너는 Jira 버전에 영향을 좀 받아서 환경도 미리 알고 계셔야합니다.(버전에 따라 내부 함수들이 변경됨에 따라 실제 코드도 조금씩 변경됩니다) Jira: Jira Software 8.3.2 ScriptRunner: 5.6.1.1-jira8 Label 값 가져오기Label 값을 가져오는 것은 쉽습니다.이슈에서 기본적으로 사용하는 필드라서 다루기 쉬운 것이 장점입니다. 123456789import com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.issue.label.LabelManager;import com.atlassian.jira.issue.MutableIssue;LabelManager labelManager = ComponentAccessor.getComponent(LabelManager);def issueMgr = ComponentAccessor.getIssueManager();MutableIssue issue = issueMgr.getIssueObject(&quot;PUBGTEST-169&quot;);labelManager.getLabels(issue.getId()); getLabels(Long issueId)getLabels() 함수는 issueId 값을 받아 이슈의 label 값을 가져옵니다.함수의 리턴 값은 label들을 포함한 배열로 리턴합니다.(아래 결과 값은 이슈에 테스트로 Label 값을 입력한 것을 기반으로 스크립트 결과가 나온 것입니다.) Result [Promotion, art] Label 값 추가하기Label 값을 가져오는 것보다는 한가지 더 고려가 필요한 추가 입니다.Label 값을 추가할 때에는 어떤 사용자가 값을 추가할 것인지 결정이 필요합니다.먼저 코드를 보면서 설명을 드리겠습니다. 1234567891011import com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.issue.label.LabelManager;import com.atlassian.jira.issue.MutableIssue; def user = ComponentAccessor.getUserManager().getUserByKey(&quot;pubg-helper&quot;);LabelManager labelManager = ComponentAccessor.getComponent(LabelManager);def issueMgr = ComponentAccessor.getIssueManager();MutableIssue issue = issueMgr.getIssueObject(&quot;PUBGTEST-169&quot;);labelManager.addLabel(user, issue.getId(), 'test', false);labelManager.getLabels(issue.getId()); 코드 설명앞서 Label 값을 가져오는 것과 비교해서 달라진 것은 아래 코드와 addLabel() 함수 입니다.def user = ComponentAccessor.getUserManager().getUserByKey(&quot;pubg-helper&quot;);위 코드는 Label을 추가할 사용자를 결정하기 위해 사용자 객체를 아이디로 가져온 것입니다. ScriptRunner의 Listener 기능에서 Label 수정/추가 기능을 사용할 때,위 코드를 통해 업데이트하는 사용자를 동적으로 변경할 수 있습니다. addLabel(User remoteUser, Long issueId, String label, boolean sendNotification) 함수는 이슈에 Label을 하나 추가할 수 있는 함수입니다.함수 레퍼런스: docs.atlassian.com/…/LabelManager/addLabel Result [Promotion, art, test] Label 값 변경앞서 Label 추가의 경우 하나씩 추가했던 것에 비해 Label 값을 변경하는 것은 LabelManager의 setLabels() 함수를 사용합니다. 1234567891011import com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.issue.label.LabelManager;import com.atlassian.jira.issue.MutableIssue; def user = ComponentAccessor.getUserManager().getUserByKey(&quot;pubg-helper&quot;);LabelManager labelManager = ComponentAccessor.getComponent(LabelManager);def issueMgr = ComponentAccessor.getIssueManager();MutableIssue issue = issueMgr.getIssueObject(&quot;PUBGTEST-169&quot;);labelManager.setLabels(user, issue.getId(), ['test'] as Set, false, true);labelManager.getLabels(issue.getId()); labelManager.setLabels()labelManager.setLabels() 함수는 Label 값을 추가, 삭제한다기보다는새로운 값으로 재설정한다는 것으로 이해하시면 될 것 같습니다. public Set&lt;Label&gt; setLabels (User remoteUser, Long issueId, Set&lt;String&gt; labels, boolean sendNotification, boolean causeChangeNotification) 여기서 중간에 labels 값에 Set으로 되어있는데 그냥 [] 배열로 넣을 경우 List 객체로 인식하는 문제가 생깁니다.그래서 as Set으로 변경해준 것으로 이해해주시면 됩니다. (혹은 변수를 따로 Set으로 두고 입력하면 됩니다) labelManager.setLabels() 함수 레퍼런스: docs.atlassian.com/…/LabelManager/setLabels Result [test] 마무리Label 값을 가져오고 추가/설정하는 것은 어렵지 않은 것 같습니다. (커스텀 필드 수정에 비해서요)다만 골라서 삭제하는 기능은 없어 setLabels와 기존에 있는 값을 비교해서 삭제하는 것으로 삭제할 수는 있어 보이네요. (그렇게 어려워 보이지는 않을 것 같긴 하네요.) 저는 특정 이벤트가 발생할 경우 Label을 추가하는 정도로만 Listener에 Custom Listener를 추가하여 사용하고 있습니다. 이 Label을 사용하여 보드를 만들어 사용하시는 분이 있는데 잘 사용하고 있다고 하네요. :) 다음에 다른 기능을 소개하는 포스트로 찾아뵙겠습니다.감사합니다!","link":"/blog/2019/10/27/ScriptRunner-Label/"},{"title":"What is Dev PM","text":"개발 PM(Project Manager) 리서치이직하는데에 필요한 정보와 커리어 전환이 괜찮은가에 대해 조사해보았습니다재작년 말에 개발자에서 PM으로 이직을 준비하면서 작성한 문서를 조금 다듬어 포스트합니다 전에는 개발 PM이라고 했을 때, 개발 = Tech로 생각했었는데 지금 다시 생각해보면개발이 잘 이뤄질 수 있도록 하는 Dev(Development)가 맞는 것 같아 당시 작성했던 내용을 정정했습니다(사실 기술 PM도 어떤 일을 하는지, 어떤 일을 해야하는지 나중에 정리해보겠습니다) 리서치한 내용 개발 PM(Development Project Manager)이란 무엇인가 현재 개발 PM을 뽑는 곳이 있는가 향후 5, 10년 내에 개발 PM의 이력을 살려서 이직을 할 수 있는가 개발 PM이 미래가 있는가 개발 경력이 있는 주니어 개발자가 개발 PM이 되는 것에 대한 의문 개발 PM이 되려면 필요한 능력 개발 PM(Development Project Manager) 이란 무엇인가우선 프로젝트 매니저의 정의는 아래와 같습니다 한시적인 일을 수행하는 데 있어서 관리 방법론(통합, 범위, 시간, 원가, 품질, 인력, 의사소통, 위험, 조달관리)에 따라 가장 효율적으로 추진하는 것으로 프로젝트의 계획과 실행에 있어서 종합적인 책임을 가진 직책 또는 직무 여기에 개발(Development) 속성을 추가해서 찾아보면 핵심 역량(Key Responsibilities)은 아래와 같습니다.(EA Korea, Development Manager 직군 채용 정보) Development Director, Technical Director, Producer를 도와 서비스 개발 일정을 맞춤 Development Director를 도와 프로젝트 위험 요소를 파악하고 대응 서비스 개발 일정을 확인하고 현재 상황을 알림 서비스 개발 이슈를 발견하여 해결하거나 보고 팀 외부 관계자와 커뮤니케이션을 담당 회의를 주관하고, 결론 및 추적해야 할 사항을 정리 게임 개발 PM 과 서비스 개발 PM 과는 차이가 있겠지만 대략 위와 같다고 볼 수 있습니다국내에는 서비스 개발 PM의 개념을 찾기 힘듭니다 (Product Manager + Project Manager가 합쳐진 형태) 현재 국내/국외 개발 PM을 뽑는 곳이 있는가(Product Manager 개념과 혼동되는 곳은 제외) 라인 Plus - Technical Project Manager 넥슨 - 분석팀 2개 블리자드 - 상하이 EA Korea - Development Manager | Associate Development Manager 라는 분야가 있음 PUBG Corp - 개발 Project Manager 스타트업(10개 이상 존재, 주로 CTO 업무와 많이 겹침) 향후 5, 10년 내에 개발 PM의 이력을 살려서 이직을 할 수 있는가이직을 할 수 있는가에 False에 대한 케이스를 보면될 것 같습니다. 개발 PM이라는 직군이 사라지거나 굉장히 적어져서 이직을 하기 힘듬 내 경력이 부족해서 이직을 하기 힘듬 개발 PM이라는 직군이 사라지거나 굉장히 적어져서 이직을 하기 힘듬개발 PM이라는 직군이 미래에도 존재할지 찾아보았지만몇몇의 필요성이 있다는 글을 보았지만 없어지지 않을 것이라는 글은 모르겠습니다(어떤 직군, 직업이든 없어질 수는 있다고 생각합니다) http://www.blog.greenprojectmanagement.org/index.php/2016/07/12/the-future-of-project-management/이 글에서의 결론만 본다면 아래와 같습니다. (글 중간에 이야기한 내용은 잘 모르겠습니다) 우리는 프로젝트 및 프로젝트 관리자의 필요성에 대한 성장을 논의했습니다. 우리는 프로젝트 관리자가 현재 시스템에 집중하지 않는 고유한 역량 및 기술 세트를 보여줘야 함을 입증했습니다. 추세는 프로젝트 관리가 예측 가능한 미래를 위한 실행 가능하고 인기있는 직업임을 나타냅니다! - (Google Translation) 프로젝트는 분명히 있을 것이고 그에 따른 프로젝트 매니저는 프로젝트의 효율성 등을 감안했을 때프로젝트 매니저가 필요없을 일은 없겠구나 하는 생각이 드네요(다만 프로젝트 매니저가 잡다한 일을 할 수도 있겠구나하는 생각도 동시에 듭니다) 내 경력이 부족해서 이직을 하기 힘듬경력이 부족해서 이직을 하기 힘들다 라는 가정은 이 정도가 될 것 같습니다 경력을 제대로 가꾸지 않았다 중간에 잘려서 경력이 끊겼다 어중간한 경력으로 이직을 하기 힘들다 사실 위의 3가지 모두 개인의 성장력과 연관이 있다고 생각합니다만약 PM으로 전환한다면 어떻게 경력을 쌓아갈 것 인가에 대해 고민하는게 맞는 것 같습니다 개발 PM이 미래가 있는가앞에서 개발 PM 직군의 향후 미래에 대해서 조사를 했는데 미래가 없어 보이지는 않았습니다미래 개발자 수나 프로젝트 수를 알 수 없듯이 먼 미래를 알 수는 없지만 프로젝트는 진행될 것이며 PM은 존재할 것이라고 생각합니다우려되는 점은 개발 방법론, 기술의 발전으로 개발 PM의 필요성이 줄어들고 있다는 우려도 볼 수 있었는데 어쩌면 프로젝트 관리, 인력 관리 등 관리에 대한 직무가 흔들릴 수 있다고는 생각이 드네요 개발 경력이 있는 주니어 개발자가 개발 PM이 되는 것에 대한 의문서비스 개발 경력이 있고 컴퓨터 공학(컴퓨터 과학)을 전공한 PM이 경쟁력이 있다는 조언은 들었습니다여기서 의문점은 개발 경력을 3년 또는 5년까지 쌓고 PM으로 전환하는게 좋지 않나? 라는 의문이 있습니다 저는 현재 약 2년의 개발자 경력을 가지고 있는데 아래와 같은 의문들이 있습니다 개발자로 경력을 더 쌓고 후에 전환을 한다면 더 좋은 PM을 할 수 있지 않을까? 이 경력으로 개발 PM으로써 충분히 퍼포먼스를 낼 수 있을까? 문서화나 업무의 경우는 같이 일하는 분들과 일하면서 충분히 배울 수 있지만, 개발자라 더 어려운 점이 있을듯? 경력이 부족함에 있어서 같이 개발하는 분들이 PM을 신뢰하기 힘든 상황이 있지 않을까? 1번 고민을 제외하고는 전환 후에 일하면서 배울 수 있는 부분이라고 생각합니다 (1번은 근본적인 고민) PM으로 전환한다면 개발을 할 수 없는 것은 아니지만 개발자 커리어로 연속적인 커리어 관리가 힘들다는 점하지만 3~5년 뒤에는 PM을 하고 싶었다는 점. 지금 도전해보는 것도 나쁘지 않을 것 같다는 점 경력, 개인의 성장은 회사 업무와 개인의 적성이 정렬되었을 때 성장이 폭발한다고 생각합니다그리고 이 성장은 회사가 챙겨주지 않고 개인이 챙겨야 하는 것으로 생각합니다 1번에 대한 고민은 전환을 하거나 하지 않더라도 계속 있을 고민인 것 같습니다현재 전환이 확정되지 않은 상태에서 고민하기보다 전환을 도전해보는 것이 좋지 않을까 합니다 개발 PM이 되려면 필요한 능력개발 PM이 되려면 필요한 능력은 위에서 적어둔 그대로 보면되지 않을까 합니다 원활한 커뮤니케이션 능력 도메인 지식이 많아야 함 (프로젝트에 대한 도메인 지식) 개발 프로세스, 개발 방법론에 대한 이해도 컴퓨터 전공 지식이 있으면 좋음 개발 우선순위, 일정 관리, 스펙 관리, 리소스 관리에 있어 최적의 효율성을 달성할 수 있는 역량 조직 내 발생할 수 있는 다양한 상황에 대한 대처 및 해결 능력뿐만 아니라, 개발 과정에서 발생할 수 있는 문제에 침착하게 대응 할 수 있는 역량 (위의 항목은 PUBG Development Project Manager 자격 조건을 몇가지 가져왔습니다) 리서치 후기당시 PUBG Dev PM으로 이직하기 위해 리서치했던 문서를 정리해보았습니다막연하게 생각해왔던 것들을 정리해보는 좋은 시간이었습니다 같이 개발하는 팀원들이 힘들지만 즐겁고 효율적으로 같이 성장할 수 있도록 돕고 싶다! 지금도 같은 생각으로 PM 업무를 하고 있고 더 좋은 개발환경, 프로세스를 만들고자 합니다 최근 들은 개발 PM 이야기 중 가장 깔끔했던 발표 공유를 마지막으로 포스트 마무리하겠습니다 이해봄님 2019 NDC 발표, 개발 PM-전지적 참견시점 자료: http://ndcreplay.nexon.com/NDC2019/sessions/NDC2019_0055.html#c=NDC2019&amp;t%5B%5D=%ED%94%84%EB%A1%9C%EB%8D%95%EC%85%98%26%EC%9A%B4%EC%98%81 기사: https://www.thisisgame.com/webzine/gameevent/nboard/227/?n=93530","link":"/blog/2019/07/20/What-is-Dev-PM/"},{"title":"Jira Field &amp; Screen 살펴보기","text":"Intro - Jira에서 필드(Field)와 스크린(Screen)지난 포스트에서 Jira에서 스킴(Scheme)을 이야기해보았는데요. (Jira Schemes은 무엇일까? (1))이때 필드 스킴, 스크린 스킴에 대해서 이야기를 하다가 필드와 스크린도 따로 이야기해보는 것이 좋을 것 같아 정리해보려고 합니다! 지난번에도 보았던 스크린과 스킴, 필드에 대한 구조도Project screens, schemes and fields (EN) 지난 포스트에서도 한번 보았던 다이어그램입니다.다이어그램을 보면 대략 알 수 있지만 정리해보면 다음과 같을 수 있겠네요. 필드 구조 특징 필드는 스크린에 들어갑니다. 필드 설정에 따라 필드를 안보이게 하거나, 필수 입력 값으로 설정할 수 있습니다. 특정 필드가 필요하지 않다면 Hide 설정하여 보이지 않게 할 수 있습니다. 특정 필드가 입력이 필요하다면 Required 설정하여 입력을 강제할 수 있습니다. 필드 설정은 필드 설정 스킴에서 이슈 타입에 따라 맵핑하여 사용할 수 있습니다. 이슈 타입에 따라 필드 설정을 각각 다르게 설정할 수 있습니다. 모든 이슈 타입에 대해 같은 필드 설정을 할 수 있습니다. 필드 설정 스킴은 프로젝트에 종속적입니다. 스크린 구조 특징 스크린은 필드를 가집니다. 스크린 스킴은 이슈의 조작(Operation)에 맞춰 설정할 수 있습니다. 이슈 생성(Create)/수정(Edit)/보기(View)에 따라 각각의 스크린을 만들어 적용할 수 있습니다. 각각의 스크린에 다른 필드들을 설정 가능하다는 것을 의미합니다. 스크린 스킴은 이슈 타입 스크린 스킴에서 이슈 타입에 따라 맵핑하여 사용할 수 있습니다. 이슈 타입에 따라 스크린 스킴을 각각 다르게 설정할 수 있습니다. 이슈 타입 스크린 스킴은 프로젝트에 종속적입니다. 워크플로우(Workflow, 흐름) 구조 특징필드와 스크린 내용에는 설명할 예정은 없었지만 구조도에 있기에 정리해봅니다. 워크플로우에서 상태 간의 트랜지션(이동)에 스크린을 맵핑할 수 있습니다. 상태 변경 중에 스크린이 나타나고 특정 값을 변경하는 방식으로 설정이 가능합니다. 워크플로우는 워크플로우 스킴에서 이슈 타입에 따라 맵핑하여 사용할 수 있습니다. 이슈 타입에 따라 워크플로우를 각각 다르게 설정할 수 있습니다. 워크플로우 스킴은 프로젝트에 종속적입니다. 구조도에 나온 내용은 이쯤에서 마무리하고 필드와 스크린 설명으로 넘어가겠습니다. :) 필드 (Field)Jira에서 필드란 무엇일까요?간단하게 생각해보면 이슈에서 필요한 정보를 담기 위한 변수라고 볼 수 있을 것 같습니다.Jira 시스템 상에는 기본적으로 있는 시스템 필드가 있고 사용자가 필요시 만들어서 사용할 수 있는 커스텀 필드가 있습니다. 시스템 필드 (System Field)Jira에서 기본적으로 제공하는 필드를 의미합니다. 어떻게 보면 시스템 필드라고 부르는게 정확한지는 모르겠네요.필드들을 볼 수 있는 곳은 Jira 소프트웨어 서포트 페이지 링크로 Advanced searching - fields reference 여기서 볼 수 있습니다.약 38개쯤 되는데요, 하나하나 보기 보다는 위 링크에서 보시면 좋을 것 같습니다. 우리가 주로 보는 필드 몇개만 소개를 해볼게요. Affected version: 반영된 버전의 의미로 사용할 수 있는 필드입니다. 프로젝트의 Releases에 있는 버전들을 입력할 수 있습니다. Assignee: 이슈의 담당자를 입력할 수 있는 필드입니다. Component: 프로젝트에 있는 컴포넌트를 입력할 수 있는 필드입니다. Summary: 이슈의 제목 필드입니다. Jira의 텍스트 검색 신텍스를 사용하여 검색할 수 있습니다. Description: 이슈의 설명 필드입니다. 이 외에도 많은 필드들이 있는데 각 필드마다 사용할 수 있는 기능(operation) 다릅니다.예를 들면, Assignee 같은 경우 WAS WAS NOT CHANGED 등을 JQL에서 사용할 수 있습니다.내가 담당했던 이슈를 찾을때는 WAS를 이용해서 찾아볼 수 있겠죠.CHANGED는 변경이 언제 이뤄졌는지, 누가 변경했는지에 대해 쿼리해볼 수 있습니다. 자세한 내용은 Advanced searching - fields reference 이 페이지에서 참고하시면 좋을 것 같습니다. :) 커스텀 필드 (Custom Field)커스텀 필드는 말그대로 사용자가 커스텀하게 만들 수 있는 필드를 뜻합니다.만들 수 있는 필드의 타입은 여러가지가 있겠죠? 텍스트 형식부터 시작해서 사용자를 입력할 수 있거나, 텍스트 박스 등 여러 타입이 있습니다. 기본 타입(Standard type) Checkboxes: 체크박스 필드 Date Picker: 날짜 설정 필드 Date Time Picker: 날짜 + 시간 필드 Labels: 레이블 필드 (입력시 자동완성 기능이 있음) Number Field: 숫자 입력 필드 Radio Buttons: 라디오 버튼 필드 (하나만 선택 가능한 필드) Select List (cascading): 2개로 나눠진 드롭다운 선택 리스트 필드 Select List (multiple choices): 여러개를 선택할 수 있는 드롭다운 선택 리스트 필드 Select List (single choices): 한개만 선택할 수 있는 드롭다운 선택 리스트 필드 Text Field (multi-line): 여러줄 입력할 수 있는 텍스트 필드 Text Field (single line): 한줄 입력할 수 있는 텍스트 필드 URL Field: URL을 입력할 수 있는 필드 (URL 클릭 가능) User Picker (single user): 사용자를 입력할 수 있는 필드 기본 타입 외에도 그룹을 입력할 수 있는 picker, 버전을 입력할 수 있는 picker, 읽을 수만 있는 read only text 필드도 있습니다.필요한 커스텀 필드를 생성하여 필드 설정(Field Configuration)에 반영한다면 사용할 수 있겠죠? 주의(Warning)!커스텀 필드는 기본적으로 생성될 때 모든 프로젝트의 필드 설정에 추가됩니다.다른 프로젝트에서는 사용하지 않고 현재 관리하고 있는 프로젝트에서만 사용하고자할 경우 추가 설정해주셔야 합니다.커스텀 필드 설정 -&gt; Edit Configuration -&gt; Choose applicable context -&gt; Apply to issue under selected projects 옵션으로생성한 커스텀 필드가 필요한 프로젝트에 반영될 수 있습니다. (다른 프로젝트에 의도하지 않게 필드가 추가되면 프로젝트에 영향을 주기 때문입니다.) 스크린 (Screen)Jira에서 스크린은 이슈를 생성, 수정, 조회하는 모든 화면들을 이야기합니다.Jira 서포트 문서(Defining a screen)에서는 아래와 같이 표현하고 있습니다. Screens group all available fields (or a subset of all available fields) defined in Jira applications, and organize them for presentation to a user. 스크린은 Jira에 정의된 사용 가능한 모든 필드(또는 사용 가능한 모든 필드의 하위 집합)를 그룹화하고 사용자에게 보여주기 위해 이를 구성한다. 위 내용 정도로 정리해볼 수 있겠네요.스크린은 앞서 말씀드렸던 이슈 생성/수정/조회에서 사용할 수 있을 뿐만 아니라 워크플로우에서 상태 변경시에도 사용할 수 있도록 설정할 수 있습니다.추가로 스크린에 탭으로 입력하고자하는 정보들을 정리해서 입력할 수 있도록 설정할 수 있죠. 이슈와 스크린앞서 스크린을 설명할 때에 이슈 생성/수정/조회에서 사용할 수 있다고 말씀드렸었습니다.스크린 스킴에서 각 동작에 따라 스크린을 설정하는 화면을 보시면 이해가 빠를 것 같습니다. 위 화면 처럼 이슈 마다, 각 Create issue / Edit issue / View issue에 따라 스크린을 따로 만들어서 적용한 것을 볼 수 있습니다.각 스크린은 다르게 설정할 수도 있고 다를 필요가 없다면 따로 설정할 필요 없이 같은 스크린을 사용해도 됩니다. 필드의 순서 설정도 가능하고, 탭을 추가해서 탭마다 입력하고자 하는 필드를 나눠서 둘 수도 있습니다. 워크플로우와 스크린워크플로우에서도 스크린을 사용할 수 있다고 말씀드렸었습니다. 참고 jira 서포트 페이지:Map a screen to a workflow transition in Jira server아래 그림처럼 상태 변경시에 스크린이 나올 수 있도록 설정할 수 있습니다. 자세한 내용은 위 서포트 페이지에 가보시면 Solution에 더 자세하게 나와있으니 참고해보세요! 마무리Jira에서 빼놓을 수 없는 필드와 스크린을 알아보았습니다.지금 작성해놓고 보니까 스크린의 내용이 약간 부족해보인다는 느낌이 있지만 어느 부분을 추가해야할지 모르겠네요. 향후 추가할 내용이 생긴다면 따로 포스트 추가해보겠습니다.추후에 현재 프로젝트에서는 어떤 필드를 사용하고 있고 어떻게 스크린을 구성해서 사용하고 있는지 보여드리겠습니다.긴 글 읽어주셔서 감사합니다. :)","link":"/blog/2019/12/28/What-is-Jira-Field-Screen/"},{"title":"What is Buildbot","text":"빌드봇(Buildbot)https://buildbot.net/“The Continuous Integration Framework”“Python-based continuous integration testing framework”Jenkins, Circle CI와 같은 CI 프레임워크로 지속적인 통합을 위한 프로그램입니다. 빌드봇 기본 설명기본적으로 Buildbot은 작업 예약 시스템입니다. 작업을 대기하고 필요한 리소스를 사용할 수 있을 때 작업을 실행하며 결과를 보고합니다.소스 저장소에서 소스를 받아 마스터(master)가 워커(worker)에게 빌드를 요청합니다. 사실 다른 CI 서비스들과 크게 다른 점은 없지만 현재 사용하고 있는 CI 서비스라서 공부 및 소개하는 차원에서 정리해봅니다. 다른 자료들을 보면서 어떤 장, 단점이 있는지 참고하면서 공부하려고 했는데 자료가 거의 없네요. 😂빌드봇 공식 문서를 보면서 정리해보고자 합니다. :) 빌드봇 가이드 문서 살펴보기Introductionshttps://docs.buildbot.net/current/manual/introduction.html 빌드봇 소개는 기능 소개로 시작되네요. run builds on a variety of worker platforms arbitrary build process: handles projects using C, Python, whatever minimal host requirements: Python and Twisted workers can be behind a firewall if they can still do checkout status delivery through web page, email, IRC, other protocols track builds in progress, provide estimated completion time flexible configuration by subclassing generic build process classes debug tools to force a new build, submit fake Changes, query worker status released under the GPL 정리해보면 다음과 같습니다. 다양한 워커 플랫폼으로 빌드할 수 있고, 다양한 언어 프로젝트를 빌드 가능 Python, Twisted로 설치 요구사항이 적음 빌드 상태 추적 및 예상 완료 시간 제공 빌드 프로세스 설정과 관련하여 유연하게 설정 가능 현재 빌드봇을 사용하는 이유가 빌드 프로세스 설정을 커스텀하게 할 수 있어서이긴 합니다. 사실 젠킨스도 커스텀하게 설정할 수는 있겠지만 현재 사용하는 시스템을 대체하려면 여러가지 커스텀하게 변경해야하는게 많아서 어렵다고는 생각합니다. 😂 https://stackshare.io/buildbotStackshare 서비스에서 투표된 내용을 기반으로 보면, 장점으로 “Highly configurable builds”가 1순위네요.추가로는 “Beautiful waterfall(이쁜 워터폴)”, “Hosted internally(내부 설치)”가 있었습니다. 앞서 첨부했던 이미지에 있는 내용과 동일한 이미지를 시작으로 시스템 아키텍쳐(구조)에 대한 이야기가 나옵니다.소스코드 저장소에서 변경사항이 있을 경우 빌드마스터가 이벤트를 받아 워커에 빌드를 요청하고 빌드 상황을 이메일, 웹, 등에서 볼 수 있다는 기본적인 구조를 설명합니다. 워커는 빌드마스터에게 명령을 받고 빌드를 진행하며, 빌드마스터가 코드를 제공하지는 않고 저장소에서 코드를 받아 빌드를 진행합니다. Buildmaster Architecture 빌드마스터 구조라고 소개해두었지만, 빌드마스터가 어떻게 워커에게 일을 주는 지에 대해 알 수 있는 그림이네요.문서 상에 설명되어있는 내용을 기준으로 정리해보겠습니다. Change Sources(변경사항들)VCS 저장소 내에서 무엇인가 수정될 때마다 변경사항 오브젝트를 생성합니다.대부분의 ChangeSource는 어떤 종류의 후크 스크립트에서 메시지를 받습니다.일부 소스들은 정기적으로 저장소를 적극적으로 폴링합니다. 모든 변경사항은 스케줄러에게 제공됩니다. Schedulers(스케쥴러)빌드 수행 시기를 결정합니다.스케쥴러는 BuildRequest에 대한 변경사항을 수집하고, 이 변경사항은 워커를 사용할 수 있을 때까지 빌더들에 전달하기 위해 대기열에 있습니다. Builders(빌더)각 빌드의 수행 방법을 정확하게 제어합니다(BuildFactory에서 구성된 일련의 BuildSteps). 각 빌드는 단일 워커에서 실행됩니다. Status plugins(상태 플러그인)HTTP, 메일 및 IRC와 같은 프로토콜을 통해 빌드 결과에 대한 정보를 제공합니다. Each Builder is configured with a list of Workers that it will use for its builds. These workers are expected to behave identically: the only reason to use multiple Workers for a single Builder is to provide a measure of load-balancing. 각 빌더는 빌드에 사용할 워커들의 목록으로 구성됩니다.이 워커들은 동일하게 작동해야합니다: 단일 빌더에 여러 워커들을 사용하는 유일한 이유는 로드 밸런싱을 제공하는 것 때문입니다. Status Delivery Architecture(상태 전달 아키텍쳐) 가이드 문서상에 있는 내용을 그대로 번역하면서 정리해보겠습니다. The buildmaster maintains a central Status object, to which various status plugins are connected. Through this Status object, a full hierarchy of build status objects can be obtained. 빌드 마스터는 다양한 상태 플러그인이 연결된 중앙 상태(Status) 객체를 유지합니다. 이 상태 객체를 통해 빌드 상태 객체의 전체 계층을 얻을 수 있습니다. configuration(구성, 설정) 파일은 활성화된 상태 플러그인을 제어합니다. 각 상태 플러그인은 최상위 상태 객체에 대한 참조를 가져옵니다. 여기에서 각 빌더, 빌드, 단계 및 로그 파일에 대한 정보를 요청할 수 있습니다.이 on-demand 쿼리 인터페이스는 html.Waterfall 플러그인에서 웹 브라우저가 기본 URL에 도달 할 때마다 기본 상태 페이지를 작성하는 데 사용됩니다. 상태 플러그인은 또한 새로운 빌드가 발생할 때 이 상태를 확인(hear)하기 위해 구독(subscribe)할 수 있습니다.MailNotifier는 이를 사용하여 최근에 완료된 각 빌드에 대해 새 이메일 메시지를 작성합니다. 상태 객체는 빌드 마스터의 기본 디렉토리에 있는 디스크의 기존 빌드 상태를 기록합니다. 이를 통해 히스토리 빌드에 대한 정보를 리턴할 수 있습니다. 스케줄러 및 빌더에 해당하는 상태 객체도 있습니다. 이를 통해 상태 플러그인은 예정된 빌드 및 각 워커의 온라인 / 오프라인 상태에 대한 정보를 보고 할 수 있습니다. 이미지를 보면서 정리해보면, 상태 객체 - 빌더 상태 - 빌드 상태 - 단계(step) 상태 - 로그 파일 구조로 상태를 볼 수 있게 구조화되어있습니다.최상위 상태 객체는 상태 플러그인이 메일로 상태를 알릴 것인지, IRC로 상태를 알릴 것인지 등 정보를 제공합니다. Control Flow가이드 문서에는 “빌드봇에서의 하루” 느낌으로 플로우를 설명합니다. 개발자는 일부 소스 코드 변경 사항을 저장소에 커밋합니다. 일종의 훅(hook) 스크립트 또는 커밋 트리거는 구성된 변경 소스 중 하나를 통해 이 변경에 대한 정보를 빌드 마스터에게 보냅니다. 이 알림은 이메일 또는 네트워크 연결을 통해 도착할 수 있습니다 (빌드마스터가 변경 사항을 구독 할 때 시작되거나 커밋 트리거가 변경 사항을 빌드마스터에게 푸시 할 때 시작됨). 변경 사항에는 변경한 사람, 수정된 파일, 변경 사항이 포함된 리비전\u001d 및 체크인 코멘트(주석)에 대한 정보가 포함됩니다. 빌드마스터는 이 변경 사항을 구성된 모든 스케줄러에 분배합니다. 중요한 변경 사항으로 인해 “tree-stable-timer”가 시작되고 변경 사항이 새 빌드로 들어갈 목록에 추가됩니다. 타이머가 만료되면 구성된 각 빌더 세트에서 빌드가 시작되어 모두 동일한 소스 코드를 컴파일 / 테스트합니다. 달리 구성하지 않는 한, 모든 빌드는 여러 워커에서 병렬로 실행됩니다. 빌드는 일련의 단계로 구성됩니다. 각 단계는 해당 빌더와 연관된 원격 워커에서 몇 개의 명령을 호출하게합니다. 첫 번째 단계는 거의 항상 변경사항을 생성한 같은 VC 시스템에서 적절한 리비전을 체크아웃하는 것입니다. 나머지는 일반적인 컴파일 및 실행 단위 테스트를 수행합니다. 각 단계가 실행될 때 워커는 명령 결과 값을 보고(리포트)하고 상태를 빌드마스터에게 반환합니다. 빌드가 실행되면 “빌드 시작”, “단계 시작”, “빌드 완료”등과 같은 상태 메시지가 상태 대상 모음에 게시됩니다. 이러한 대상 중 하나는 일반적으로 이벤트 목록을 표시하는 HTML Waterfall 표시이며 각 열의 맨 위에 있는 최신 빌드 결과를 요약합니다. 개발자는 이 페이지를 주기적으로 확인하여 변경사항이 어떻게 되었는지 확인할 수 있습니다. 빨간색으로 표시되면 실수를 한 것이므로 문제를 해결해야합니다. 녹색으로 표시되면, 그들은 자신의 의무를 다했다는 것을 알 수 있고 그들의 변경사항이 무엇을 깨뜨린 것은 아닌지에 대해 걱정할 필요가 없습니다. MailNotifier 상태 대상이 활성화된 경우, 빌드가 완료되면 빌드에 변경사항을 기여(참여)한 모든 개발자에게 이메일이 발송됩니다. MailNotifier는 실패한 빌드 또는 전달에서 실패로 전환된 빌드에 대해서만 메일을 보내도록 구성할 수 있습니다. 다른 상태 대상은 IRC와 같은 다른 통신 채널을 통해 유사한 실시간 알림을 제공할 수 있습니다. 빌드봇 살펴보기 마무리사실 다른 CI 서비스를 많이 아는 상태에서 빌드봇을 둘러보아서 차이점이나 장점을 자세히 소개하지는 못했던 것 같습니다.다음 포스트에서는 빌드봇 설치, CI 환경 구축까지 해서 테스트가 잘되는지 한번 해봐야겠습니다. 😀그 후에 젠킨스나 다른 설치형 CI 서비스도 한번 둘러보고 포스트 남겨보겠습니다. 이번 글이 가이드 문서의 번역글로 작성된 것 같기는 합니다.나중에 빌드봇을 설치하고 설정해보면서 알게되는 내용도 같이 정리해보겠습니다.그때는 이 글에 #1, #2 이렇게 붙을 수도 있겠네요. 😀","link":"/blog/2020/07/12/What-is-Buildbot/"},{"title":"What is Clumsy","text":"Clumsy 소개https://jagt.github.io/clumsy/index.html 네트워크 환경, 상태를 컨트롤할 수 있는 툴 입니다.Windows 환경에서만 동작하는 툴이어서 맥(Mac), 리눅스(Linux)에서는 사용할 수 없는 툴입니다.(Windows의 WinDivert라는 네트워크 관련 패키지를 사용해서 컨트롤하는 프로그램이기 때문입니다.) 다운로드 https://jagt.github.io/clumsy/download.html 사용 방법https://jagt.github.io/clumsy/manual.html General Filtering: 패킷은 이 필터를 조건으로 캡처됩니다. 필터링에 있는 내용을 조건으로 패킷을 잡아 아래 함수들이 동작합니다. Presets 메뉴: 선택할 수 있는 내장 프리셋 목록이 있습니다. 어떤 필터들이 있는지 드롭다운을 눌러서 볼 수 있습니다. config.txt 에 실행파일과 함께 번들로 필터를 추가할 수도 있습니다. Start 버튼: 패킷 캡쳐를 시작합니다. 필터의 구문이 맞지 않거나, 다른 이슈로 인해 시작이 안될수도 있습니다. 캡쳐가 시작되면 버튼은 “Stop”으로 변경되고, 버튼 왼쪽 작은 아이콘에 녹색으로 표시됩니다. 캡쳐에 실패하면 아이콘은 적색으로 표시됩니다. Function control: 캡쳐된 패킷에 대해 원하는 기능을 사용할 수 있습니다. Lag - 패킷 전송을 지연시킵니다. Lag time 만큼 지연시킵니다. Drop - 패킷을 전송하지 않고 떨어뜨립니다.(드롭합니다) Chance 값에 따라 떨어뜨립니다. Throttle - 특정 시간 동안 트래픽을 차단하고 나중에 일괄적으로 보냅니다. Out of order - 순서를 뒤섞습니다. Duplicate - 패킷을 중복으로 보냅니다. Tamper - 패킷 내용을 변경(변조)합니다. Parameters control Inbound - 밖에서 안으로 들어오는 패킷에 대해 적용합니다. Outbound - 안에서 밖으로 나가는 패킷에 대해 적용합니다. Lag time / Chance - 적용하고자하는 확률, 지연 값을 설정할 수 있습니다. Status: 현재 상태에 대한 메세지를 보여줍니다. Client Packet Loss Test 모든 패킷에 대해서 10% 확률로 패킷을 드롭시키는 설정입니다. 정리이 틀을 네트워크 테스트를 하다가 알게되었는데 가이드 문서가 없어서 블로그에 한번 정리해보았습니다.툴 자체는 간단하고 네트워크 지식(UDP, TCP, 인바운드, 아웃바운드 정도) 알면 사용하는데에는 무리가 없어보이는 툴입니다.네트워크 상태 테스트에서 일반적으로 발생하는 문제 케이스에 대한 테스트 케이스도 한번 정리해두면 좋을 것 같습니다.","link":"/blog/2020/03/21/What-is-Clumsy/"},{"title":"Jira Schemes은 무엇일까? (1)","text":"Jira Scheme 시리즈 Jira Schemes은 무엇일까? (1) Jira Schemes은 무엇일까? (2) Jira에서 프로젝트를 생성한 뒤에 이슈, 워크플로우, 권한 등을 설정하는데많이 들어보셨으리라 예상하는 스킴(Scheme)에 대해 이야기해보자 합니다. 설정할 때, 기존에 사용하던 스킴을 사용할 수도 있고 내 입맛대로 변경한 스킴을 사용할 수도 있어요.이번 포스트에서는 스킴이란 무엇인지, 어떤 스킴들이 있는지만 짚어보겠습니다. 참고 이 포스트는 Jira 언어 설정을 영어로 해두어서 한국어로 설정하신 분들의 화면과는 다를 수 있습니다) 스킴에 대한 설정은 프로젝트 어드민이 아닌 시스템 어드민 권한이 있어야 가능합니다. Jira Scheme(스킴)Jira에는 여러 스킴이 있는데 대부분 프로젝트를 기준으로 설정 가능합니다.스킴 하나를 여러가지 프로젝트에 적용할 수도 있고 프로젝트마다 따로 스킴을 만들어 적용할 수도 있습니다.(스킴 하나를 공유하는 프로젝트의 경우 스킴 변경을 신중하게 해야합니다. 다른 프로젝트에 영향을 주기 때문이죠) 이슈 타입, 워크플로우, 필드, 우선순위(Priority), 권한(Permission) 등을 설정할 수 있습니다.먼저 Jira에서 설명하는 내용을 보고난 뒤에 하나하나 살펴보겠습니다. (좋은 그래프가 있어서 첨부해봅니다.) Jira Docs 설명Project screens, schemes and fields (EN) 원문 Information for each issue is held in the fields that are associated with that issue. You can tailor these fields to suit your organization’s needs. The diagram below is a representation of how these fields are associated with an issue, via screens and schemes. A screen is the user’s view of an issue, and the screen is mapped to a specific issue operation (such as creating an issue, or editing an issue) via a screen scheme. The screen scheme is then mapped to an issue type via the issue type screen scheme. This configuration is associated with the project, and is applicable to all issues within the project. 번역문각 이슈에 대한 정보는 해당 이슈와 관련된 필드에 있습니다. 조직의 요구에 맞게 이 필드를 조정할 수 있습니다. 아래 다이어그램은 스크린(화면) 및 스킴(구성표)을 통해 이러한 필드가 이슈와 연결되는 방식을 나타냅니다. 스크린은 사용자가 이슈를 볼 수 있는 화면이며 스크린 스킴을 통해 특정 이슈 작업 (예 : 이슈 생성 또는 이슈 편집)에 맵핑됩니다. 그런 다음 스크린 스킴은 이슈 타입 스크린 스킴을 통해 이슈 타입에 맵핑됩니다. 이 구성은 프로젝트와 관련이 있으며 프로젝트 내의 모든 이슈에 적용됩니다. 설명을 대략 구글 번역기로 돌렸는데 깔끔하게 번역된 것 같습니다. (의미로 번역하지 않고 되도록 음차로 두고 정리해두었습니다.)위 그림 및 설명대로 스킴, 설정들이 묶여 동작하고 있는 것을 아래에서 설명드리겠습니다. 가보시죠! Issue types Scheme(이슈 타입 스킴)이슈 타입 스킴은 이슈 타입에 대한 것을 정의합니다.이 스킴은 프로젝트 -&gt; Project settings(프로젝트 설정) -&gt; issue types(이슈 타입)에서 볼 수 있습니다. 위 화면에서 볼 수 있듯이,현재 프로젝트에서 사용하고 있는 이슈 타입들을 설정할 수 있습니다.설정은 위에 Actions 버튼을 누르면 Edit issue types가 나옵니다. 해당 프로젝트에서 사용할 이슈 타입을 스킴 수정을 통해 추가/삭제할 수 있습니다.변경하고자하는 이슈 타입을 드래그&amp;드롭으로 옮겨서 설정합니다.프로젝트에서 기본적으로 생성되는 이슈 타입도 설정할 수 있습니다. (Default issue type) 관련 컨플루언스 링크 Adding, editing, and deleting an issue type scheme(EN) Issue type schemes(EN) Workflow Scheme(워크플로우 스킴)이슈 타입 스킴과 같이 프로젝트 설정 -&gt; Workflows(워크플로우) 메뉴에서 볼 수 있습니다.눌러보면 프로젝트에서 사용하는 각 이슈 타입에 할당되어있는 워크플로우를 볼 수 있습니다.(현재 세팅되어있는 이슈 타입, 워크플로우 스킴 세팅에 따라 화면은 다르게 보일 수 있습니다.) 위 화면에서 스킴을 수정할 수는 없고 스킴을 변경하는 Switch Scheme 버튼으로 다른 스킴으로 변경할 수 있습니다.현재 있는 스킴들 중 하나를 골라서 변경할 수 있습니다. 다만 미리 만들어두고 설정해야겠죠. 화면에서 볼 수 있듯 현재 워크플로우 스킴은 지금 프로젝트 외에 다른 2개의 프로젝트에도 적용되어있습니다.This workflow scheme is being used by multiple projects 라는 문구가 있는데,다른 프로젝트도 사용하고 있는 스킴을 변경하려면 워크플로우 스킴 페이지로 가서 변경해야한다는 이야기입니다. Workflow Schemes를 누르면, 워크플로우 스킴을 변경할 수 있는 페이지가 나옵니다.페이지로 가보면 이슈 타입에 워크플로우를 추가하거나 수정, 삭제할 수 있습니다.설정되어있는 워크플로우 내용을 Text, Diagram 타입으로 볼 수 있습니다. 첫 항목의 All Unassigned issue Types는 아래에 할당되어있는 이슈 타입 외에모든 이슈 타입에 대해 PUBG Workflow가 적용된다는 것 입니다.지금 사용하는 프로젝트는 Epic, Task, Sub-Task 이슈 타입이 PUBG Workflow(기본 워크플로우)를 사용하고 있습니다. Screen Scheme(스크린 스킴)프로젝트 설정 -&gt; Screens 메뉴에서 볼 수 있습니다.어떤 스크린 스킴들이 설정되어있는지 볼 수 있고, 설정은 어드민 페이지에 가서 수정할 수 있습니다. 여기서는 각 이슈가 Create/Edit/View(생성/수정/조회) 시 볼 수 있는 스크린을 각각 설정할 수 있습니다.처음 스크린 스킴 생성시에는 Default로 한가지 스크린이 생성되어있으며 각각의 경우에 맞게 스크린을 생성하여 설정할 수 있습니다.(위 화면에서 볼 수 있듯 Task, Epic, Sub-task의 각각의 경우에 맞게 스크린을 설정해두었습니다.) 각 이슈에 맞게 스크린 스킴이 설정되어있는 것을 보실 수 있을 겁니다.상위에 이슈 타입 스크린 스킴(Issue type screen schemes)에 따라 설정되어있는 것인데 다음 순서에 설명하겠습니다. 여기서 스크린이란? 이슈의 생성/수정/조회 시 보여지는 필드를 정의한 것을 의미합니다. 이슈 생성시 필요한 스크린의 경우 Summary, Description, Assignee, priority 등이 필요할 수 있겠죠? 이슈 화면에서 입력이 필요하거나 보여줘야하는 내용이 있다면 설정할 수 있습니다. 위에 Field Tab의 기능을 이용하면 탭을 이용하여 입력해야하는 필드를 나눠서 보여줄 수도 있습니다. Issue type screen schemes(이슈 타입 스크린 스킴)이슈 타입 스크린 스킴은 각 이슈 타입에 따라 스크린 스킴을 설정할 수 있는 스킴입니다.어떻게 보면 스크린 스킴과 이슈 타입 스킴을 연결해주는 스킴이라고 볼 수 있겠네요.위 스크린 스킴 메뉴 화면에서 오른쪽 상단의 Actions -&gt; Edit screens를 통해 수정할 수 있습니다. 설정 페이지 오른쪽 상단의 Associate an issue type with a screen scheme 메뉴 버튼을 통해 이슈 타입과 스크린 스킴을 연결할 수 있습니다.기존에 있던 항목의 Edit버튼을 누를 경우, 다른 스크린 스킴으로 변경하는 설정화면이 나옵니다. Field Scheme(필드 스킴)필드 스킴은 프로젝트에서 사용하는 이슈 타입 들의 필드 항목을 정의하는 스킴입니다.필드 스킴에서는 각 이슈 타입에 사용할 필드를 정의한 Field configuration(필드 설정)을 설정합니다.프로젝트 설정 화면에서 오른쪽 상단의 Actions -&gt; Edit screens를 통해 수정할 수 있습니다. 설정 페이지 오른쪽 상단의 Associate an issue type with a field scheme 메뉴 버튼을 통해 이슈 타입과 필드 설정을 연결할 수 있습니다.현재는 Bug 이슈 타입 외에 몇가지 커스텀한 설정이 되어있지만 Epic, Task, Sub-task 타입은 Default 필드 설정을 사용하고 있습니다.각 항목의 Edit 버튼을 누를 경우, 다른 필드 설정으로 변경하는 설정화면이 나옵니다. 필드 설정(Field configuration)이란? 이슈에 입력할 수 있는 필드를 설정합니다. 입력 필드의 옵션도 설정할 수 있습니다. 필수 입력(Required), 보여지지 않게 할지 등 필요하지 않은 필드는 숨김(Hide) 처리할 수 있습니다. Priority Scheme(우선순위 스킴)프로젝트 설정에 이슈와 직접적인 관계가 있는 스킴 중 마지막 스킴이라고 할 수 있겠습니다.이슈의 우선순위 값을 어떤 값을 입력할 수 있게할지 설정하는 스킴입니다.주로 Blocker, Critical, Major, Minor, Trivial(Nonessential) 정도로 설정하는 것으로 알고 있습니다. 다른 스킴들과 다른 것은 우선순위 값이 시스템에 묶여 있어 순서를 변경하기 힘들다는 것입니다.그래서 이슈 검색 시, 우선순위 정렬이 종종 안맞는 경우가 있어 확인해보면 우선순위 정렬이 안맞는 경우가 있습니다.스킴에 묶여 있는 순서가 아닌 시스템 우선순위 값 정렬에 따라 정렬되니 참고하세요! 나중에 우선순위 정렬에 대한 것이 스킴에 맞게 정렬될 수 있으면 좋겠네요.다만 생각해보면, 다른 우선순위 스킴을 가지고 있는 여러 프로젝트의 이슈들의 우선순위를 정렬하려면 그렇게 하기 힘들 수 있겠다는 생각도 드네요. 마무리스킴에 대한 것이 아직 몇개 남았지만 프로젝트의 이슈와 연관이 큰 스킴을 중심으로 다루어 보았습니다.남은 스킴들은 이슈 보안, 노티피케이션, 퍼미션 정도가 남았는데 다음 포스트를 통해 소개하겠습니다.긴 글 읽어주셔서 감사합니다.","link":"/blog/2019/12/15/What-is-Jira-Schemes1/"},{"title":"Jira Schemes은 무엇일까? (2)","text":"Jira Scheme 시리즈 Jira Schemes은 무엇일까? (1) Jira Schemes은 무엇일까? (2) 앞선 1편의 내용 뒤로 남은 스킴들에 대해 알아보는 포스트입니다.1편에서는 Jira 프로젝트에서 주로 이슈와 관련하여 설정하곤하는 스킴에 대해 이야기해보았습니다. 2편에서는 프로젝트에서는 많이 변경하지 않지만 알아두면 프로젝트 관리에 도움이 될만한 스킴을 이야기해보겠습니다. 남은 스킴은 뭐가 남았나요? Issue Security Scheme(이슈 보안 스킴) Project Permission Scheme(프로젝트 권한 스킴) Notification Scheme(노티피케이션/알림 스킴) 남은 스킴은 이렇게 3개 정도가 되겠습니다.(더 봐야하는 스킴이 남아있을 수 있지만 제가 알고 있는 스킴을 중심으로 정리해보았습니다.)프로젝트 이슈에 대한 내용보다는 프로젝트 외적인 부분에 대한 내용으로 생각하고 보시면 될 것 같습니다. Issue Security Scheme(이슈 보안 스킴)이슈 보안 스킴은 이슈들에 대해 특정 인원에게 보여주거나 할당할 수 있도록 제한할 수 있는 스킴입니다.스킴에 있는 보안 레벨(Security level)을 통해 사용자를 제한할 수 있습니다. 프로젝트에 설정되어있는 보안 레벨 스킴은 아래 경로에서 확인할 수 있습니다.프로젝트 설정 -&gt; Issue Security대부분은 스킴이 설정되어있지 않을 겁니다. 프로젝트 안에서 특정 티켓들을 안보이게 하거나 할당되지 않게할 수 있는 설정이어서외부인과 협업 또는 보안상 특별한 이슈가 없다면 사용할 일이 많지 않은 스킴이긴 합니다. 참고 문서: JIRA Security Level 설정하기 (Reporter와 Assignee만 해당 이슈 보기)위 참고 문서에 잘 설명되어있네요. :) Project Permission Scheme(프로젝트 권한 스킴)프로젝트에서 프로젝트 역할(project role)이나 사용자에 따라 권한을 설정할 수 있는 스킴입니다. 위 페이지 화면 처럼, 퍼미션이 있고 각 권한을 프로젝트 역할, 그룹, 특정 사용자 등으로 설정할 수 있습니다.설정에 따라 권한을 가지고 있는 사용자만 프로젝트를 접근하거나 댓글을 달 수 있도록 할 수 있습니다.설정 가능한 옵션을 좀 더 본다면 아래와 같습니다. 위 화면에서도 보실 수 있겠지만 한번 정리해봅니다. 프로젝트 역할 (Project Role): 현재 Jira에 있는 프로젝트 역할 리스트를 추가할 수 있습니다. 응용프로그램 엑세스(Application access): 로그인한 사용자 또는 Jira 소프트웨어 사용자 그룹으로 추가할 수 있습니다. 그룹(Group): Jira에 있는 그룹으로 추가할 수 있습니다. 보고자(Reporter): 이슈를 생성한 사용자를 추가합니다. 단일 사용자(Single user): 특정 사용자를 추가합니다. 프로젝트 책임자(Project lead): 프로젝트 책임자를 추가합니다. 현재 담당자(Current assignee): 이슈의 담당자를 추가합니다. 사용자 정의 필드 값(User custom field value): 사용자 타입의 커스텀 필드에 있는 사용자를 추가합니다. 그룹 사용자 정의 필드 값(Group custom field value): 그룹 사용자 타입의 커스텀 필드에 있는 사용자를 추가합니다. 권한을 추가할 수 있는 사용자 옵션도 많고, 권한 종류도 많습니다.수정할 수 있는 권한 카테고리는 아래와 같이 정리해볼 수 있을 것 같네요. 프로젝트 권한 이슈 권한 투표자(Vote), 지켜보기(Watch) 권한 댓글(Comment) 권한 첨부파일(Attachments) 권한 시간 추적(Worklog) 권한 Notification Scheme(노티피케이션/알림 스킴)알림 스킴은 이슈에서 발생하는 이벤트에 대한 알림 중 어떤 것을 누구에게 보낼 것인지를 설정할 수 있는 스킴입니다.이슈가 생성되고 변경되었을 때 알림 메일을 받을 것인지 등을 설정할 수 있습니다. 각 이벤트에 따라 알림을 받을 사용자, 사용자 그룹을 설정할 수 있습니다.프로젝트 권한 스킴 설정과 비슷하게 알림을 받을 사용자들을 추가할 수 있습니다.각 알림 항목에 알림을 받을 사용자를 추가할 수 있는 옵션은 다음과 같습니다. Current Assignee Reporter Current User Project Lead Component Lead Single User Group Project Role All Watchers User Custom Field Value Group Custom Field Value 알림 이벤트는 이슈 생성, 이슈 수정, 이슈 할당, 이슈 해결 부터 댓글 추가, 댓글 업데이트 등이 있어서필요한 이벤트에 대해 알림이 필요한 사용자들을 추가할 수 있습니다. 마무리스킴 관련한 내용은 2개의 포스트로 마무리할 수 있었네요.저도 이번에 정리하면서 Jira에 있는 스킴들을 공부할 수 있었어서 좋았고 나중에 활용할 수 있는 방법을 고민할 수 있게된 계기가 되어 좋았습니다. 긴 글 읽어주셔서 감사합니다. :)","link":"/blog/2019/12/28/What-is-Jira-Schemes2/"},{"title":"What is Tech PM","text":"Tech PM(Project Manager)이란 무엇일까?지금까지 약 2년 동안 개발 PM으로 일해왔는데, 내가 상상하고 생각했던 개발 PM이 지금 하는 일과 같은가? 하는 내안의 질문이 있었다. 개발자(엔지니어)로 앱 개발하다가 개발 PM으로 전직하고나서 전직 전에 내가 생각했던 일을 하고 있는지, 내가 잘알고 있었던 것인지 되짚어보고 싶어졌다. 내가 생각했던 Tech PM부터 한번 알아보고, 내가 왔던 길과 가야할 길을 정리해보고자 한다. Tech PM 구글에 찾아보면…구글에 Tech PM이라고 검색해보면 그렇게 많은 내용은 나오지 않는다. 아래 링크를 보면 대략적인 기술 PM의 역할을 볼 수 있지만.. 내가 알고 있는 개발 PM의 일반적인 내용을 담고 있어서 “기술 PM이 그래서 뭐가 다른 것이지?” 하는 의문이 있었다. https://www.wrike.com/project-management-guide/faq/what-is-technical-project-management/ 링크에 있는 내용을 정리해보면 3줄 정도로 요약해볼 수 있다. IT 프로젝트에서 기술 지식 기반으로 프로젝트를 관리할 수 있음. 기본적인 프로젝트 매니저가 하는 일을 함. 큰 그림도 볼 줄 알아야하며 전반적인 기술 지식도 있어야 함. 결론, 소프트웨어 개발 PM으로 일하는 데에 어려움이 없을 정도로 지식이 있는 PM이면 된다.(너무 일반적인 내용이라서 자세하게 안본 탓도 있는 것 같지만, 뭔가 딱 이거야! 하는 내용이 없었다.)이 정도 내용으로는 내가 생각하는 기술 PM이 설명되지 않은 것 같아 더 찾아보기로 했다. Technical PM 업무 소개서(Job Description) 보기다른 회사의 기술 PM 업무 소개서를 보면 알 수 있지 않을까?로 시작된 조사! https://www.indeed.com/m/jobs?q=Technical+Project+Manager 몇 가지 JD를 보면서 각 회사마다 원하는 바가 많이 다르다는 것을 알 수 있었다. Oracle, IBM 등 IT 솔루션을 판매하는 회사의 경우 내부 기술 PM이라기보다 기술 영업 PM의 느낌이 강하다. 기술을 이해하며 해당 솔루션을 영업하는 업무 기술적인 부분에 대해 고객과 커뮤니케이션하는 TAM(Technical Account Manager) IT 회사가 아니지만 기술 PM이 필요한 경우에는 내가 지금하고 있는 개발 PM과 다를 것이 없는 듯 하다. 일반적인 IT 서비스 개발 PM (일반적이라는 말이 모호하긴하지만 더 좋은 표현은 못찾겠다.) TAM(Technical Account Manager)은 또 뭐지?그러던 중 TAM과 관련한 내용도 계속해서 나오길래, 한번 찾아보게 되었다.https://www.buzzvil.com/ko/2018/12/26/buzzvil-people-jen-yoon-technical-account-manager/ 버즈빌에서 TAM 업무를 하고 있는 분의 인터뷰 글. 연동 문서 관리 / 내외부 이슈 해결 / 프로세스 세팅 및 개선 업무를 하고 있다고 한다. https://cloud.google.com/tam/?hl=ko 구글 클라우드에서 TAM 팀은 약간 컨설턴트 느낌이다. 다른 TAM도 마찬가지이긴 한데 구글은 B2B 관련 일이 많아 그런 것 같다. https://aws.amazon.com/ko/careers/support/employee3/ AWS의 TAM 업무 소개 페이지. TAM이 하는 업무에 대해 소개하고 지원 버튼이 밑에 있다. Technical Program Manager도 있네?https://www.amazon.jobs/en/jobs/990061/technical-program-manager 찾다보니 내가 하고자했던 것이 기술 프로그램 매니저였을까 하는 물음표가 생겼다. 처음에 내가 하고싶었던 일이 프로젝트 매니저였는지 프로그램 매니저였는지 모호한 상태이고, 회사마다 PM의 정의가 다르기 때문에 이 용어를 분리해서 이야기하는게 큰 의미는 없을 수 있다.(참고 링크: “프로덕트, 프로그램, 프로젝트 매니저? 뭐가 다른가요?” ) 다만 내가 원했던 일은 엔지니어 경험을 활용해서 개발팀의 전체적인 프로세스가 잘 진행될 수 있도록 돕고 싶었고, 일이 효율적으로 진행될 수 있도록하고 싶었다. 위 참고 링크에서는 프로그램 매니저, 프로젝트 매니저를 이렇게 설명한다. 프로그램 매니저는 제품을 어떻게 에 모든 열정을 쏟는 역할 어떻게 제품을 만들지, How에 집중하는 역할로 이해했다. 프로젝트 매니저는 제품을 언제 에 관심이 있는 역할 제품을 언제까지 만들 수 있을지, 언제 내보낼 수 있을지 When에 집중하는 역할로 이해했다. 정리해보면 전직 전에는 “어떻게 개발을 잘할 수 있을까” 같은 고민을 하면서 일하겠지? 했지만, 지금하고 있는 일은 언제 출시할 수 있을지 관리하는 프로젝트 매니저일을 하고 있는 것 같다.(물론 전체 조직의 개발 생산성에 관심이 많아 생산성을 올릴 수 있는 도구들도 도입해보고 개발해보는 등 프로그램 매니저일도 약간은 하고 있다는 생각도 든다.) Tech PM, 프로젝트 매니저든 프로그램 매니저든맨처음으로 돌아가서.. 내가 하고싶어하는 Tech PM의 정의는 무엇일까 정리해보자.이 글을 쓰기 전에 페이스북에 “여러분들이 생각하는 Tech PM(Technical Project Manager)는 어떤 모습인가요?” 질문을 올렸었는데, 회사 동료분의 말이 와닿아서 같이 정리해본다. PM도 포함해서 사람들이 모호하게 정의한다고 생각해요. 프로그래머에게 바라는게 무엇인가요? 하는 느낌같은…? 상황, 경험과 역량에 따라 천차만별이 아닐까요? 회사마다 PM을 정의하는게 다르고 팀마다 다르고 경험과 역량에 따라 다 달라진다는 것을 한번 더 확인받은 기분이었다. 정리하다보니 더 심플해지는 것 같지만, “어떤 역량과 경험을 가지고 일하는지에 따라 PM 역할은 달라질 수 있다. Tech PM이라는 역할에 갇히지말고 역량을 키우자” 정도로 내 생각을 마무리해본다. 위에 있는 정리된 내용으로 기본적인 Tech PM 정의는 된 것 같지만, 아직 한국에서는 PM의 명칭, 역할이 명확하게 구분되어 있지 않아 딱 이거다하는 정의는 어려운 것 같다. 이정도로 생각을 마무리해본다.다음 글에서 더 성장한 생각의 글을 쓸 수 있기를!","link":"/blog/2020/01/12/What-is-Tech-PM/"},{"title":"FileOpenLog, FileOpenOrder란?","text":"FileOpenLog, FileOpenOrder참고 문서: https://docs.unrealengine.com/4.27/ko/Basics/Projects/Packaging/ 언리얼 엔진에서 패키지 생성 및 로딩하는 것과 연관이 있는 내용입니다. 참고 문서에서 언급한 내용으로는 아래와 같습니다. “로드 시간 단축을 위해서는 .pak 파일 순서를 잘 지정하는 것이 중요합니다. .pak 파일 최적의 순서를 지정하는 데 도움을 드리기 위해, UE4 에서는 데이터 애셋의 필요 순서를 알아내어 더욱 빠른 로딩 패키지를 제작하기 위한 툴 세트가 제공됩니다. 개념적으로, 이 프로세스는 프로파일 주도형 최적화와 비슷합니다.” 언리얼 서밋 세션도 있어서 참고해보면,https://youtu.be/KJUVH_KzLj8?si=QRG7h2Mim5f0KGOD&amp;t=2135 테스트 빌드를 실행할 때에 -fileopenlog 파라미터를 적용해서 실행하고 로그 파일을 빌드시 사용하는 것 입니다. (파일은 {project}/Build/WindowsNoEditor/FileOpenOrder/ 에 위치함) 이 최적화는 Disk보다는 Flash Drive에서 효과적이라고 하네요.(예시: Disk=HDD, Flash Drive=SSD, USB 드라이브) 언리얼 서밋 세션에서 공유한 예시 수치로는 5.9s → 4.6s, 약 23%가 감소한 수치를 보여줬습니다.로그를 얻기 위해 실제 유저가 플레이하는 것 처럼 플레이하더라도 많은 게임 데이터를 포함해서 플레이를 하기는 어렵기에 어느정도 감안하고 최적화한다고 봐야할 것 같네요. 마무리FileOpenLog라는 용어가 일반적인 용어일 줄 알았는데 실제로 사용하는 곳은 언리얼엔진 정도인 것 같습니다.파일오픈로그(오더) 용어 그대로 파일이 열리는 순서를 최적화해서 로딩 시간을 개선하는 방법, 방법을 위한 파일 정도로 이해하면 좋을 것 같네요.","link":"/blog/2023/10/02/What-is-fileopenlog/"},{"title":"PM article 읽기-&#39;뛰어난 제품 관리자가 되는 법&#39;","text":"“뛰어난 제품 관리자(Product Manager)가 되는 법” 글 소개원문: https://www.ravi-mehta.com/product-manager-skills/ 국문 번역글: https://brunch.co.kr/@verashin/12 뛰어난 PM(Product Manager)이 되기 위한 12가지의 핵심역량에 대해 다룬 글입니다.PM은 어떤 능력을 가져야할지, 어떻게 성장해야할지 로드맵 기준을 세워볼 수 있도록 잘 정리된 글이었어요.(이걸 다 잘하면 정말 엄청난 시니어 PM이지 않을까 하는 생각도 들었습니다. 다 잘하기는 쉽지 않겠지만요. 😂) PM의 역할, 핵심역량을 보고이 글에서는 핵심역량을 4개의 카테고리를 나눠서 각각 3개씩 총 12개의 역량 내용을 정의했습니다.제품 실행력 / 고객 통찰력 / 제품 전략 수립 능력 / 인사 관리 능력 이렇게 나누고각 항목에 대해 설명하는데 하나하나 제가 PM으로 하는 업무에서 어떤 것들이 부족한지, 어떤 것을 앞으로 더 해야할지 고민해보게 되었습니다. 주니어 때는 제품의 릴리스 업무 중심(릴리스 스펙 취합, 패치노트 작성 등)으로 일을 하면서 **”제품 실행력”**에 집중했었고 나머지 항목에 대해서는 신경써보지 못했던 것 같네요.PM 업무를 3년 정도한 지금은 조금씩 큰 그림, 다른 역량을 성장시켜보려 하고 있습니다. 그동안 제품 실행력에 집중했다면 고객 통찰력, 제품 전략 수립 능력에 조금씩 업무를 넓혀보고 있는데요.제품 실행력 측면을 다 내려두었다기 보다 다양한 측면을 바라볼 수 있는 PM이 되고자 하고 있습니다. 프로덕트의 프로덕션이 잘 이뤄질 수 있도록 팀 목표, 프로덕트 로드맵을 설정하고 - 제품 전략 수립 능력, 인사 관리 능력 프로덕트가 안정적으로, 재미있는 컨텐츠가 유저에게 안착할 수 있도록 - 고객 통찰력, 제품 실행력 프로덕션, 개발 과정 중에 개선점을 발견하면 개선할 수 있도록 - 인사 관리 능력 적어두니까 다 하면 좋을 것들이긴한데 글에 있는 핵심 역량에 이것저것 연결되어있다는 생각은 드네요.당연히 이 모든 일은 혼자는 못하고 팀과 함께, 개발 부서분들과 함께 이뤄나가야겠죠. 글에서 얻을 수 있던 것글 마지막에 핵심역량을 스스로 평가해보고 강점을 찾고 부족한 부분을 이해하고 성장을 위한 계획을 세우라는 이야기가 있었습니다.일반적으로 2-3개 역량에서 매우 잘하고 있음으로 평가될 수 있다고 하는데 요즘 저는 제 자신에게 자신이 없어서 그런지 잘모르겠더라구요. 😂 최근에 팀장님과 리드 업무란 어떻게 해야하는가, 현재 내가 하고 있는 일이 잘하고 있는 것인가 1:1 미팅을 했었는데지금까지 해온 것 처럼 잘할 것이라 믿어주셔서 큰 에너지를 얻고 부스트를 해보고 있습니다.사실 이제 팀장 업무를 한지 1개월 정도 되었는데요.팀장 업무를 안하고 실무를 많이하게되면 어쩌지하는 두려움과 여기서 뭘 더해야할까 하는 모호함이 있는데이런 어려움을 조금씩 해결해나갈 수 있게 이정표가 될 수 있는 시야를 글에서 얻을 수 있게된 것 같습니다. 다른 분들도 이 글을 보고 좋은 이정표를 하나 얻어 가셨으면 좋겠네요 💪","link":"/blog/2021/05/14/article-how-to-become-a-peak-product-manager/"},{"title":"인풋랙(Input Lag)? 그게 뭔데?","text":"인풋랙(Input lag)? https://en.wikipedia.org/wiki/Input_lag 인풋랙은 말 그대로 인풋(마우스, 키보드 등) → 연산장치(컴퓨터) → 디스플레이(모니터)까지 사용자의 인풋에 따른 디스플레이까지의 지연을 의미합니다.인풋랙이라고 부르긴하지만 시스템 지연 시간으로 볼 수 있어요. 이번 포스트에서는 게임에서 주로 느끼는 인풋랙에 대해서만 다뤄보겠습니다.(주로 인풋랙에 민감하게 반응하는 영역이 게임이기 때문에) 중간에 인풋랙을 찾다가 디스플레이 랙(Display Lag)으로 잘못 빠졌었는데 Latency(지연 시간, 응답 속도) 측면에서 완전히 분리할 수는 없지만 인풋랙과는 다른 영역이었네요.디스플레이 랙 = 디스플레이 장치(예: 모니터, TV)에서 입력 신호를 받아 처리하여 화면에 표시되는 시간참고: https://en.wikipedia.org/wiki/Display_lag 인풋랙 깊게 살펴보기 엔비디아에서 좋은 글, 좋은 영상이 있어서 들고왔습니다.(엔비디아 Reflex에 대한 소개가 있긴하지만요 😅) https://www.youtube.com/watch?v=h69JR51pZbU https://www.nvidia.com/en-us/geforce/guides/system-latency-optimization-guide/ 게임에서 인풋랙은 많은 요소들이 영향을 준다고 볼 수 있습니다. 적당히 풀어서 정리해볼게요. 주변기기 지연 - 인풋 기기의 폴링 레이트(Polling Rate)에 맞춰 컴퓨터에서 신호 처리가 되는데 그 처리에서 지연 시간이 있습니다. (USB 신호 처리, CPU 처리 등) PC 지연 - 입력을 받고 PC에서 처리되는 동안 발생하는 지연 CPU - 게임 내에서 일어나는 애니메이션, 물리 엔진 연산 등에 사용되는 시간 Render Queue - CPU 연산 뒤 렌더링을 위해 렌더링 명령들을 Queue에 적재하고 대기하는 시간 GPU - Render Queue에 있는 명령들을 렌더링하는 시간 디스플레이 지연 - PC로 부터 받은 신호들을 보이도록 처리하는 시간 우리가 게임에서 말하는 인풋랙은 이렇게 크게 3가지 지연 시간을 합해서 계산해볼 수 있습니다.물론 네트워크를 이용한 멀티플레이 게임의 경우, 네트워크 레이턴시도 포함해서 봐야하지만 그건 PC 지연에 포함한다고 가정하고 넘어가겠습니다 게임과 인풋랙주로 인풋랙에 영향을 많이 받는 게임은 FPS(Shooter), 격투 게임, 리듬 게임이 작은 지연에도 큰 영향을 받는 게임 장르로 볼 수 있습니다. FPS, Shooter: 인풋랙에 따라 상대방을 조준, 사격하는데에 있어서 인풋랙의 영향을 받습니다. 추가로 네트워크 레이턴시도 추가되어 흔히 이야기하는 핑(ping) 차이가 발생하기도 합니다 핑이 높으면 피커스 어드벤티지(Peeker’s advantage) 현상이 더 크게 발생할 수 있습니다 피커스 어드벤티지: 네트워크 지연, 차이 등에 따른 공격자가 상대를 먼저 인지할 수 있는 이득을 보는 것 (참고) 피커스 어드벤티지, 발로란트 포스트 격투 게임: 인풋랙에 따라 콤보를 넣을 수 있느냐, 상대의 공격을 인식해서 방어, 회피할 수 있냐가 달라지기에 크게 영향을 받는다고 볼 수 있습니다. 한 사례로 콘솔 기기와 PC 설정 환경 차이로 인해 인풋렉의 차이가 발생해서 PC로 대회를 열 수 밖에 없었다는 사례도 있었네요. (스트리트파이터5 참고 사례, 참고 사례 링크2) 리듬 게임: 인풋랙에 따라 노트를 정확하게 맞출 수 있냐 없냐가 달라지니 크게 영향을 받는다고 볼 수 있습니다. 게임이 얼마나 세세하게 판정하냐에 따라 영향도는 달라질 수는 있지만 게임 자체 이슈, 모니터, 컨트롤러의 지연 요소에 따라 인풋랙이 크게 발생할 수 있습니다 인풋랙 측정 방법 퀘이사존: 모니터 인풋랙은 무엇이고, 어떻게 측정할까? https://quasarzone.com/bbs/qn_report/views/113059 상세한 내용은 퀘이사존에서 자세히 설명해주고 있어서 위 글을 참고해보시면 좋을 것 같습니다. 요약해보면 마우스 입력 → 화면 반응까지 시간을 LDAT(Latency Display Analysis Tool)이라는 장치를 이용해서 측정합니다.LDAT이 없을때는 화면 반응을 카메라를 이용해서 촬영, 측정했다고 하네요. 🤩 인풋랙 개선 방법엔비디아 글에서 여러가지 인풋랙 개선 방법들이 있어 간단히 남겨보겠습니다. https://www.nvidia.com/en-us/geforce/guides/system-latency-optimization-guide/ Turn on NVIDIA Reflex (게임 설정): 게임에서 Reflex 기능 On Turn on Ultra Low Latency Mode (엔비디아 설정): Low Latency를 Ultra로 설정 Turn on Exclusive Fullscreen (게임 설정): 게임에서 “전체화면” 설정 Turn off VSYNC (엔비디아 설정): Vsync 기능 off Turn on “Game Mode” in Windows(OS 설정) 설정 &gt; 게임 &gt; 게임 모드 &gt;게임모드 On 설정 Overclocking (PC 하드웨어 설정): CPU, GPU, Ram 오버클럭 Consider Faster Hardware: 하드웨어 업그레이드 😂 Reduce settings (게임 설정): 하위 옵션으로 반응성을 올려라 Enable your maximum refresh rate: 디스플레이의 주사율을 최대로 설정 Turn on G-SYNC Esports mode (엔비디아 설정) Turn on some overdrive: 모니터에서 오버드라이드 모드 설정 마무리요렇게 인풋랙에 대해서 짧게 알아보았는데요. 정리해보고나니 일상적으로 게임에서 이야기하는 인풋랙은 시스템 레이턴시(시스템 지연 시간) 정도로 볼 수 있을 것 같습니다. 인풋랙은 워낙 많은 요소들이 영향을 주는 것이다 보니 하나만으로는 개선이 어렵고 이것저것 다 최적화해야하는 느낌이네요. 개인의 입장에서는 하드웨어 업그레이드, 게임 설정으로 개선할 수 있고게임 입장에서는 게임 최적화, 하드웨어 기능 호환 등을 지원하는 것이 개선 방법이 될 수 있겠습니다. 참고 https://quasarzone.com/bbs/qn_hardware/views/474933 원문: https://videocardz.com/newz/nvidia-reviewer-kit-ldatpcat-will-make-gpu-testing-more-accurate Nvidia What is System Latency: https://www.youtube.com/watch?v=h69JR51pZbU https://www.nvidia.com/en-us/geforce/guides/system-latency-optimization-guide/","link":"/blog/2023/06/06/What-is-inputlag/"},{"title":"Atlassian Chartio 인수 소식","text":"소식Announcing our acquisition of Chartio 최근 2/26에 아틀라시안에서 새로운 인수 소식을 공유했는데 Chartio라는 회사를 인수했다고 합니다.Chartio는 클라우드 기반의 데이터 시각화(Data Visualization), 분석 서비스를 운영하던 곳이라고 하네요. Chartiohttps://chartio.com/blog/atlassian/ Chartio는 쓱 훑어보니 Tableau와 비슷한 시각화 서비스로 보였습니다.기능을 훑어보려 신규 설정 해보려고 했으나 2022년 3월에는 서비스를 종료할 예정이라 가이드 문서만 참고할 수 있는 상태네요. 대시보드도 구성할 수 있고 SQL을 통해 데이터를 어떻게 보여줄지 등 여러 기능이 많은 서비스 같습니다. 기대 🤔이번에 Chartio를 Atlassian에서 인수하면서 Jira나 Confluence 등에서 사용되고 있는 데이터 시각화 플러그인, 기능들이 이쁘게 변화하지 않을까 기대를 해봅니다.저는 업무에서 Jira 서버 설치 버전을 사용하고 있어서 클라우드 버전에 리포트가 이쁘게 나오는지는 정확하게 알지못하지만..서버 버전 보다는 클라우드 버전이 더 이쁘게 나온다는 것은 next-gen 프로젝트를 통해 약간은 알 것 같아요. 아래 차이만 봐도 아실 수 있겠죠? 😈 Next-gen cumulative flow chart Server cumulative flow chart Next-gen cumulative flow chart docs Server cumulative flow chart 지난번 아틀라시안 서비스들의 클라우드 전환하는 것(Post not found: atlassian-chartio-accquisition)에 대한 공지 이후의 소식과 같이 보면 클라우드 기반을 다지기 위한 행보로 보입니다.(제 실제 업무에서는 Jira 서버 버전을 사용하고 있어서 클라우드 버전을 미리 좀 더 깊게 써봐야하나 하는 고민이 더 들기도 하네요) 아틀라시안의 클라우드 행보는 계속 지켜봐야할 것 같네요.다른 소식이 있다면 또 포스팅해보겠습니다. 감사합니다. 😈","link":"/blog/2021/03/01/atlassian-chartio-acquisition/"},{"title":"Blender 2.93 버전 Mac OS 시작시 크래시 이슈","text":"Blender 2.93 Mac OS에서 시작시 크래시이번에 컴퓨터 그래픽스를 공부하면서 렌더링이나 그래픽 애셋 작업이 어떤 것인지 알아보려고 Blender를 설치해보았습니다. https://www.blender.org/ Mac OS에 설치하고 실행해보았는데 크래시가 발생하는 겁니다. 어떤 크래시인가?크래시 발생에 대한 세부사항은 다음과 같았습니다. 12345678910111213141516171819202122232425262728293031323334Process: Blender [39427]Path: /Applications/Blender.app/Contents/MacOS/BlenderIdentifier: org.blenderfoundation.blenderVersion: 2.93.4 (2.93.4 2021-09-01)Code Type: X86-64 (Native)Parent Process: ??? [1]Responsible: Blender [39427]User ID: 501Date/Time: 2021-09-20 18:36:26.898 +0900OS Version: macOS 11.6 (20G165)Report Version: 12Bridge OS Version: 5.5 (18P4759a)Anonymous UUID: xxxSleep/Wake UUID: xxxTime Awake Since Boot: 44000 secondsTime Since Wake: 2400 secondsSystem Integrity Protection: enabledCrashed Thread: 0 Dispatch queue: com.apple.main-threadException Type: EXC_CRASH (SIGABRT)Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYApplication Specific Information:abort() calledterminating with uncaught exception of type boost::locale::conv::conversion_error: Conversion failedThread 0 Crashed:: Dispatch queue: com.apple.main-thread... 크래시 내용만 골라서 확인해보겠습니다. 1terminating with uncaught exception of type boost::locale::conv::conversion_error: Conversion failed 보니까 locale과 관련한 에러같기도한데 검색해보았더니 LOCALE 쪽 이슈라고 합니다. 해결방법?Mac 언어 설정을 한국어/중국어/일본어로 했을 경우 발생할 수 있다고합니다. 시스템 환경설정 실행 언어 및 지역 선택 선호하는 언어 English 첫번째로 설정 (시스템 언어 English로 설정) Blender 실행 문제 해결! 향후 업데이트에는 수정될 수 있겠지만 당분간은 언어 설정 변경을 통해서 문제를 우회해서 사용해야겠네요.Blender를 사용하는데 크래시가 발생한다면 참고하여 사용해보세요.(실행한 뒤에는 언어 변경을 하더라도 잘 동작합니다.)","link":"/blog/2021/09/20/blender-2-93-crash-on-start/"},{"title":"BugSplat - Uneal Engine 4.27 integration","text":"BugSplat 홈페이지: https://www.bugsplat.com/가이드 문서: https://docs.bugsplat.com/introduction/getting-started/integrations/game-development/unreal-engine 설치, 설정 방법가이드 문서: https://docs.bugsplat.com/introduction/getting-started/integrations/game-development/unreal-engine 설정 방법은 간단합니다. 에디터에서 프로젝트 설정에 “크래시 리포터 포함” &amp; “디버그 파일 포함” 설정해주기 DefaultEngine.ini 에 크래시 덤프를 보낼 주소를 입력해주기 DataRouterUrl=”https://{database}.bugsplat.com/post/ue4/{appName}/{appVersion}” 4.26 이후 버전에는 DefaultEngine.ini 파일을 아래 경로에 복사해줘야 함(폴더가 없으면 다 만들어서 넣어줘야 함) 패키지 빌드 폴더\\Engine\\Restricted\\NoRedist\\Programs\\CrashReportClient\\Config 패키지 빌드 폴더에서 심볼 파일 업로드(.pdb) sendpdbs 커맨드라인 프로그램을 이용해서 심볼 파일 업로드 (가이드 문서 참고) SendPdbs.exe /u {username} /p {password} /b {database} /a {appName} /v {appVersion} /s /f “.pdb;.dll;*.exe” 패키지 빌드에서 크래시 발생시키면 대시보드에서 바로 볼 수 있음 설정 상세 DefaultEngine.ini에 DataRouterUrl에는 {} 값을 실제 사용할 값으로 바꿔서 입력해야합니다 {database} 는 BugSplat에 설정에서 데이터베이스를 만들어서 사용할 수 있습니다 언리얼엔진 4.27.2 버전은 가이드 문서에 있는 아래 내용을 참고하여 추가 설정해줘야합니다 “For capturing crashes in packaged games in Unreal Engine 4.26 and newer, copyDefaultEngine.ini to {output directory}\\Engine\\Restricted\\NoRedist\\Programs\\CrashReportClient\\Config making sure to create folders that don’t exist (where{output directory} is the location of your packaged build).” 이 폴더에 DefaultEngine.ini 파일이 없는 경우 BugSplat에서 크래시를 확인할 수 없었습니다 크래시 업로드 확인프로젝트 패키지로 만들어진 바이너리 실행 후 크래시를 발생시킵니다.저는 크래시 발생시키는 명령어 이름을 crashMe로 지어두었고 콘솔 명령어로 실행하면 아래와 같이 크래시 리포터가 뜨게됩니다. “Send and Close”로 크래시 정보를 보내면 센트리에서 크래시 정보를 볼 수 있게됩니다. 마무리Sentry에 이어서 BugSplat이라는 서비스에서 크래시 업로드, 크래시 대시보드 확인을 한번 해보았습니다.BugSplat은 Sentry에 비해서 투박한 느낌이 있습니다.Overview / Other Threads / Registers / Modules 등 각 항목별로 나눠서 보여주고 있지만 Sentry를 보고 BugSplat을 보니 뭔가 필요한 정보는 알아서 찾아서 보세요의 느낌이 강했네요.두 서비스 모두 크래시 분석을 위한 정보들을 잘 보여주고 있는 것 같았습니다.(엔지니어분과 같이 이런 뷰 형태는 어떤지 확인은 해봐야겠지만요 😂) 다른 크래시 분석 서비스도 다음 포스트에서 다뤄보겠습니다. 참고: Sentry - UnrealSentry - Uneal Engine 4.27 integration","link":"/blog/2023/07/10/bugsplat-UnealEngine-427-integration/"},{"title":"fisheye webhook error (with node.js)","text":"Fisheye Webhook 에러 수정SVN, Git과 같은 버전관리 프로그램에 기록되는 커밋(리비전) 내역을 트래킹해주는Fisheye를 회사에서 사용 중에 Webhook 기능이 있어 사용하다 에러를 만나게 되어 해결 방법을 남겨봅니다.저는 Node.js + Express로 웹훅을 받아 처리할 때 문제가 있었습니다. Fisheye에 대한 자세한 내용은 추후 다른 포스트에서 남겨보겠습니다. :) Webhook 기본 설정Fisheye에서 웹훅을 설정하는 방법은 간단합니다.아래 링크를 참고하여 웹훅을 설정합니다.https://confluence.atlassian.com/fisheye/configuring-web-hooks-960155631.html Webhook을 받기 위한 Node.js + Express 서버 구성간단한 서버 어플리케이션을 만들어서 웹훅을 받아봅니다.POST 요청을 받을 수 있도록 만들고 Test 기능으로 웹훅을 보내 보았습니다. 그랬더니 아래와 같은 에러가 생겼습니다. 123456789101112POST /test/webhook 415 4.796 ms - 1426UnsupportedMediaTypeError: unsupported content encoding &quot;utf-8&quot; at contentstream (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\body-parser\\lib\\read.js:174:13) at read (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\body-parser\\lib\\read.js:54:14) at jsonParser (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\body-parser\\lib\\types\\json.js:134:5) at Layer.handle [as handle_request] (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\express\\lib\\router\\layer.js:95:5) at trim_prefix (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\express\\lib\\router\\index.js:317:13) at C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\express\\lib\\router\\index.js:284:7 at Function.process_params (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\express\\lib\\router\\index.js:335:12) at next (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\express\\lib\\router\\index.js:275:10) at logger (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\morgan\\index.js:144:5) at Layer.handle [as handle_request] (C:\\Users\\pineoc\\Desktop\\private\\pino-bot\\node_modules\\express\\lib\\router\\layer.js:95:5) 이런 에러는 또 처음이라 좀 더 확인해보았습니다.(제 코드 상에 문제라기 보다 웹훅에서 보내주는 데이터 쪽과 맞춰야하는 문제로 보였기 때문입니다.) UnsupportedMediaTypeError 에러 확인 및 해결 시도에러 내용은 저에게는 생소해서 구글에서 관련 에러를 검색해보았습니다.UnsupportedMediaTypeError: unsupported content encoding &quot;utf-8&quot;를 검색해보니아래와 같은 글들이 나왔습니다. Content-Encoding issue: https://github.com/expressjs/body-parser/issues/100 unsupported content encoding “utf-8”: https://github.com/Strider-CD/strider/issues/1021 몇 가지 글을 보았을 때는 Body-parser 쪽에 문제가 있어서 안되는 것으로 예상하여 아래와 같이 해결해보려 했습니다만,첫 번째 글을 보면 Request Header 값 중 &quot;Content-Encoding: UTF-8&quot;를 빼면 해결되지 않을까? 하는 질문이 있습니다. 바로 아래에는 헤더 값을 제거하는 코드가 답변으로 달렸죠. 123456789//...app.use(function (req, res, next) { // remove invalid header delete req.headers['content-encoding']; next();});app.use(express.json());app.use(express.urlencoded({ extended: false }));// ... 이렇게 app.js 코드를 수정하고 웹훅 데이터를 받아보았더니 해결되었습니다. Content-Encoding: UTF-8?Content-Encoding: UTF-8 는 뭐길래 에러가 났을까 확인해보았습니다.우선 Content-Encoding이라는 헤더는 미디어 타입을 압축하기 위해 사용되는 값입니다.참고: https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Content-Encoding Content-Encoding은 주로 아래와 같이 사용되죠. 12345Content-Encoding: gzipContent-Encoding: compressContent-Encoding: deflateContent-Encoding: identityContent-Encoding: br 위 사용 방법에 따르면 UTF-8 값은 유효하지 않은 값입니다. (Invalid)UTF-8 인코딩 혹은 문자 인코딩을 요청에 표현하고 싶다면 아래와 같이 표현해야합니다.참고: https://www.w3.org/International/questions/qa-headers-charset.ko 1Content-Type: text/html; charset=utf-8 문제 해결해결 방법은 그렇게 어렵지 않았지만 해결하면서 다양한 내용을 알게되어서 좋았습니다.+문제 없이 웹훅도 사용할 수 있게되어서 더 좋았죠. :) Request Header 유효성 문제 Content-Encoding 헤더 값 사용 방법 Content-Type 헤더 값 사용 방법 다른 웹훅을 등록하거나, 웹훅 시스템을 만들 때 고려해야하는 내용이었습니다.","link":"/blog/2019/04/20/fisheye-webhook-error/"},{"title":"Windows에서 전체화면(Fullscreen) 최적화의 이해 on Microsoft Blog","text":"원본DirectX Dev Blog: Demystifying Fullscreen Optimizations 요약: 전체화면 모드(FullScreen Mode) vs 창 모드(Windowed Mode) Windows 10 출시와 함께 전체화면 전용 게임을 전체 화면을 차지하는 고도로 최적화된 전체 창 모드(Borderless) 형식으로 실행하는 전체화면 최적화가 추가되었음 이 최적화로 전체 창 모드로 프로그램(게임)을 실행해도 시각 경험과 성능이 전체화면 모드와 거의 동일하게 개선되었음 다만 전체화면 모드와 창 모드의 이점을 갖는 대신 진짜 전체화면 모드와 비교했을 때 성능 부하가 있기에 완전히 성능이 동일하다고 볼 수는 없음 (참고) 전체화면 모드 + 다른 프로그램의 오버레이 케이스에서는 전체화면 모드에서도 성능 저하가 있을 수 있음 전체화면 최적화 기능을 끄고 싶다면 (전체화면, Fullscreen Exclusive) 아래처럼 설정 프로그램 파일(.exe 파일) 오른쪽 클릭 &gt; 속성(Properties) 선택 호환성(Compatibility) 탭 선택 전체 화면 최적화 사용 중지 선택 &gt; 적용 마무리원본 글을 보시면 알 수 있지만 저희가 게임에서 전체화면 모드라고 생각했지만 실제로 OS단에서 전체 창 모드로 보여주고 있을 가능성이 있네요.실제 게임에서 전체화면 모드를 지원하더라도 OS에서 최적화를 통해 창모드로 실행되고 있을 수 있겠습니다. 😂최근 게임 성능 테스트하면서 전체화면 모드 vs 전체 창 모드를 테스트해보았었는데 FPS가 비슷했어서 의아했는데 이제 알게되었습니다.이 최적화는 Windows 10 특정 업데이트부터 적용된 것 같긴하네요. (2019년 글이니 그 전에 반영되었다고 볼 수 있겠습니다.)","link":"/blog/2023/09/02/fullscreen-opt-windows/"},{"title":"GitLab CI 해보기 - Cordova","text":"이 글은 2018년 1월 기준으로 작성된 글입니다. 현재 Gitlab 설정, Cordova 환경과는 다를 수 있습니다. GitLab CI소개: https://about.gitlab.com/product/continuous-integration/GitLab에서 CI를 지원한다는 것을 듣고 당시 진행하던 프로젝트를 설정해보고자 했습니다.CI는 Continuous Integration의 약자로 지속적인 통합으로 부릅니다. CI는 “지속적으로 퀄리티 컨트롤을 적용하는 프로세스를 실행하는 것이다. (Wiki)으로 설명할 수 있고 이 글에서는 CI에서 자세히 다룰 예정은 아니기에 다른 좋은 문서를 참고해주세요. :) GitLab 소개문서에는 CD(Continuous Delivery OR Continuous Deployment-지속적인 배포)도다루고 있으니 참고하시면 좋을 것 같습니다. 저는 CI까지만 설정해보겠습니다. (나중에 CD까지 해볼 수 있겠죠.) CI 설정 시나리오 빌드 환경 설정 .gitlab-ci.yml 설정 GitLab Repo에 push! 빌드! 빌드 환경 설정여기서 어려울 것으로 예상한 것은 빌드 환경을 설정하는 것이라고 생각했습니다.freecodecamp 미디엄 글에서는 도커 이미지를 사용하여 어렵지 않게 풀어낸 것 같습니다. 빌드 환경 설정에 필요한 Cordova 환경설정이 무엇인지 살펴보았습니다.Cordova 7.x 기준의 안드로이드 빌드 환경은 아래와 같습니다. (참고) JDK 8 이상 Android SDK, Android SDK Packages Node.js 8.9.4 (NPM) Cordova 7.x (옵션) 환경 변수 설정 iOS 빌드 환경은 macOS 이미지가 없어서 설정해보지 못했습니다. ;(안드로이드 설정만 해봐야겠네요. 앞서 freecodecamp 미디엄 글에서는 docker 이미지를 사용해서 CI를 설정을 했습니다.Cordova 관련한 docker 이미지가 있는지 확인해보았고 적당한 것을 찾았습니다.https://hub.docker.com/r/beevelop/cordova/ 이 이미지를 사용하여 만들어본 저장소는 아래와 같습니다. (저장소는 기본적인 프로젝트 생성한 상태입니다.)https://gitlab.com/pineoc/cordova-ci-demo .gitlab-ci.yml 설정123456789101112image: beevelop/cordova:v7.1.0before_script: - cordova platform add androidstages: - buildbuild: stage: build script: - cordova build android GitLab Repo에 Push위에서 설정한 .gitlab-ci.yml 파일을 프로젝트 최상단 경로에 두면 GitLab에서 파일을 인식하여설정한 내용대로 빌드를 진행합니다. 진행된 내역은 아래 링크에서 확인할 수 있습니다.https://gitlab.com/pineoc/cordova-ci-demo/pipelines 이제 커밋할 때마다 빌드가 돌아가고 빌드의 실패/성공을 확인할 수 있습니다.커밋에 [ci skip] 이라고 명시하면 빌드는 스킵됩니다.(중간에 빌드 환경이 달라져서 실패한 내용이 생겼네요.) 기본 프로젝트는 어렵지 않게 설정해보았지만추가적인 플러그인 추가나 설정이 들어가면 어려워질 수 있을 것 같습니다.iOS 빌드 시스템을 사용하려면 다른 것도 필요하겠구요. 기본적인 설정이라도 도움이 되었으면 좋겠습니다. :) 참고 문서 Medium: https://medium.freecodecamp.org/how-to-setup-ci-on-gitlab-using-docker-66e1e04dcdc2 GitLab CI quick start: https://gitlab.com/help/ci/quick_start/README GitLab CI Demo: https://gitlab.com/ykyuen/gitlab-ci-demo","link":"/blog/2019/06/30/gitlab-CI-Cordova/"},{"title":"Jira 8.0 &amp; ScriptRunner로 JQL issue 가져오기","text":"Jira 8.0 &amp; ScriptRunner로 JQL issue 가져오기최근에 ScriptRunner로 JQL 결과 이슈 가져오기 스크립트를 찾아보고 실행해보려 했는데 잘 안되서 포스트를 작성해보았습니다.(다른분들도 같은 문제를 겪을 것 같아서..!) 스크립트러너 문서에서의 코드는 링크에서 확인하시면 좋을 것 같습니다.ScriptRunner Doc: running-a-jql-query 위 링크에 있는 코드에서 몇몇 Deprecated 코드를 수정하면 다음과 같은 코드로 정리해볼 수 있습니다. 1234567891011121314151617181920212223242526import com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.issue.search.SearchProvider;import com.atlassian.jira.jql.parser.JqlQueryParser;import com.atlassian.jira.web.bean.PagerFilter;def jqlQueryParser = ComponentAccessor.getComponent(JqlQueryParser);def searchProvider = ComponentAccessor.getComponent(SearchProvider);def issueManager = ComponentAccessor.getIssueManager();def user = ComponentAccessor.getJiraAuthenticationContext().getLoggedInUser();// edit this query to suitdef query = jqlQueryParser.parseQuery(&quot;project = JRA and assignee = currentUser()&quot;);def results = searchProvider.search(query, user, PagerFilter.getUnlimitedFilter());log.debug(&quot;Total issues: ${results.total}&quot;);results.getIssues().each {documentIssue -&gt; log.debug(documentIssue.key); // if you need a mutable issue you can do: def issue = issueManager.getIssueObject(documentIssue.id); // do something to the issue... log.debug(issue.summary);} 문제의 시작그런데..이 코드를 Script Console에서 실행해보면 아래와 같은 에러가 발생합니다. 123groovy.lang.MissingMethodException: No signature of method: com.atlassian.jira.issue.search.providers.LuceneSearchProvider.search() is applicable for argument types: (com.atlassian.query.QueryImpl, com.atlassian.jira.user.DelegatingApplicationUser, com.atlassian.jira.web.bean.PagerFilter) values: [{project = &quot;JRA&quot;} AND {assignee = currentUser()}, pineoc(pineoc), ...]Possible solutions: search(com.atlassian.jira.issue.search.SearchQuery, com.atlassian.jira.web.bean.PagerFilter), search(com.atlassian.jira.issue.search.SearchQuery, com.atlassian.jira.web.bean.PagerFilter, java.util.Set), search(com.atlassian.jira.issue.search.SearchQuery, org.apache.lucene.search.Collector), each(groovy.lang.Closure) at Script1071.run(Script1071.groovy:14) 에러를 요약해보자면.. LuceneSearchProvider에 그런 메서드가 없다. search(.issue.search.SearchQuery, .web.bean.PagerFilter) 요런 형식이어야하는데 search(.query.QueryImpl, .user.DelegatingApplicationUser, .web.bean.PagerFilter) 요렇게 부르고 있어서 안되는거다. 파라미터 형식이 너무 길어서 생략하겠습니다. (com.atlassian.jira 등이 앞에 붙어있었습니다.) 에러 내용만 봤을 때는 잘못된 파라미터로 인해 함수를 호출하지 못한다고 합니다.공식 가이드 문서로 보고 진행했는데 에러가 나서 잠시 당황했지만 파라미터를 확인해보았습니다. 문제 파악searchProvider의 search() 함수에는 다음과 같은 파라미터가 들어가야한다고 합니다.JIRA API docs(8.0.2)-LuceneSearchProvider com.atlassian.jira.issue.search.SearchQuery com.atlassian.jira.web.bean.PagerFilter 근데 가이드 문서에서 사용했던 함수에는 아래와 같은 파라미터를 사용했습니다.JIRA API docs(7.0.5)-LuceneSearchProvider Query query ApplicationUser searcher PagerFilter pager 위 처럼 찾아보는 과정에서 LuceneSearch 쪽 업데이트가 있어 함수 변경이 있었습니다.그 업데이트가 Jira 8.0 버전으로 올라가면서 반영된 것 같습니다.ScriptRunner는 Jira 8.0을 지원한다고 했지만 문서는 아직 지원하지 않는 것 같네요. (…) 참고 https://confluence.atlassian.com/adminjira/lucene-upgrade-955171970.html https://confluence.atlassian.com/adminjira/preparing-for-jira-8-0-955171967.html#PreparingforJira8.0-m06 문제 해결 시도그래도 결과를 찾아봐야하니까 문제를 해결해봅니다. 아래와 같이 코드를 수정하여 스크립트 콘솔에 적용해보았습니다.변경된 내용 및 이유도 함께 적어둡니다.(바로 적용해볼 수 있는 코드는 아래에 있으니 바로 사용해보시면 될 것 같습니다.) searchProvider.search() 함수도 앞서 설명한 것 처럼 메서드를 확인하여 변경했다. results.getIssues() 함수는 Jira 8.0.x에 더 이상 존재하지 않았다. SearchResults에 함수에는 getResults() 함수가 존재한다. getResults() 함수는 List를 반환하는데 DocumentWithId List를 반환한다. (참고 링크 - search 함수) DocumentWithId 클래스에는 getDocument() 함수가 있는데 이 함수로 Document에 접근할 수 있다. Document 오브젝트는 org.apache.lucene.document.Document 메서드를 사용하여 데이터를 접근할 수 있다. (참고 링크 - Document 메서드) Document.getField(“key”) 로 접근하여 이슈의 키를 얻을 수 있다. (ex: JRA-1) 123456789101112131415161718192021222324252627import com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.jql.parser.JqlQueryParser;import com.atlassian.jira.issue.search.SearchProvider;import com.atlassian.jira.web.bean.PagerFilter;import com.atlassian.jira.component.ComponentAccessor;import com.atlassian.jira.issue.search.SearchQuery;def findIssues(String jqlQuery) { def issueManager = ComponentAccessor.issueManager; def user = ComponentAccessor.getJiraAuthenticationContext().getLoggedInUser(); def jqlQueryParser = ComponentAccessor.getComponent(JqlQueryParser); def searchProvider = ComponentAccessor.getComponent(SearchProvider); def query = jqlQueryParser.parseQuery(jqlQuery); def searchQuery = SearchQuery.create(query, user); // search 함수를 type 에 맞게 수정해주었다. def results = searchProvider.search(searchQuery, PagerFilter.getUnlimitedFilter()); log.warn &quot;issue cnt: ${results.getTotal()}&quot;; // query로 얻은 이슈의 수를 확인한다. results.getResults().collect { res -&gt; def doc = res.getDocument(); def key = doc.get(&quot;key&quot;); def issue = ComponentAccessor.getIssueManager().getIssueObject(key); return issue; }}def jqlQuery = &quot;project=JRA AND issuetype=Bug&quot;;def issues = findIssues(jqlQuery); 참고 Document 클래스 설명 문서: https://lucene.apache.org/core/7_2_0/core/index.html?org/apache/lucene/document/Document.html Document.getFields() 참고: https://www.programcreek.com/java-api-examples/?class=org.apache.lucene.document.Document&amp;method=getFields groovy Collection 다루기http://docs.groovy-lang.org/next/html/documentation/working-with-collections.html 정리다소 문제 해결에 애를 먹기는 했지만 해결은 했습니다.이 글을 쓰고나서 ScriptRunner 쪽에 문서 최신화좀 해달라고 요청해야겠네요.문서 최신화가 어려운 것은 알지만 다들 삽질할 것 같은데 피드백 얼른 남겨야겠네요. 종종 스크립트러너로 할 수 있는 기능들을 포스팅 해보겠습니다. :)","link":"/blog/2019/06/24/jira-8-0-scriptRunner/"},{"title":"Flutter 2.0 업데이트 소식","text":"Flutter?EN: https://flutter.dev/KO: https://flutter-ko.dev/ Flutter(플러터)는 구글에서 만든 개발 프레임워크로 기존에는 모바일 앱을 개발할 수 있었으나 2.0으로 업데이트되면서 데스크탑 앱(Windows, Mac, Linux), 웹 앱까지 stable로 지원하는 개발 프레임워크가 되었습니다. 홈페이지에는 플러터를 아래와 같이 설명하고 있네요. Flutter(플러터)는 하나의 코드베이스로 모바일, 웹, 데스크톱에서 네이티브로 컴파일 되는 구글의 아름다운 UI 툴킷입니다. 플러터는 Dart라는 언어를 사용하여 앱을 개발할 수 있으며 이 언어도 구글에서 만들었습니다.앱을 개발할 때는 Android Studio, IntelliJ, VS Code, Emacs에 플러그인을 설치하고 가능하다고 합니다.(iOS, Android, 데스크탑 앱 모두를 개발하고자 한다면 VS Code로 하는게 좋겠네요 😈) 2.0 업데이트 소식 https://medium.com/flutter/whats-new-in-flutter-2-0-fe8e95ecc65 이번에 업데이트된 내용을 살짝 요약해보면 Mobile Framework -&gt; Portable Framework 데스크탑 앱(Mac OS, Windows, Linux), Web(beta to stable) 지원! Dart Null Safety 자세한 내용은 Dart 2.12 업데이트를 참조하세요 :) Flutter Fix를 통해 2.0 업데이트 이후 deprecated된 것 수정 가능 DevTool 업데이트 평균 FPS, 메모리 뷰 차트, 디버거 업데이트 등 자세한 내용은 DevTools 2.0 짧은 정찰 마무리Flutter를 이용한 앱 개발은 해보지 않아서 이번에 업데이트 소식을 들은 김에 튜토리얼해보면서 앱을 한번 빌드해보는 것도 재미있을 것 같네요.(Dart 언어도 한번 찍어먹어볼겸..) 앱 개발 강의에서도 요즘 심심치 않게 등장하고 있는 프레임워크인데 조만간 튜토리얼 돌려보고 내용 정리해봐야겠습니다. 😈","link":"/blog/2021/03/07/flutter-2-0/"},{"title":"Jira 스토리 포인트(Story points) 설정하기","text":"Jira 이슈 스토리 포인트 설정이 포스트에는 스토리 포인트에 대한 개념적인 내용은 다루지 않고 Jira에서 이슈에 스토리 포인트를 설정하는 방법에 대해서만 다룹니다.스토리 포인트와 관련한 이야기는 구글링해도 많이 나오니 참고해주세요. 😀 스토리 포인트 설정단계별로 빠르게 설정해봅시다! (단, Admin 계정만 가능합니다) Jira settings &gt; issues 이동 Fields &gt; Custom Fields 이동 Story Points를 찾아 Configure &gt; Edit Configuration Choose applicable issue type에서 story points를 사용하고자 하는 이슈 타입을 선택 후 설정 사용하는 프로젝트로 가서 프로젝트 설정 &gt; Screens에 스토리 포인트를 사용하고자하는 이슈 타입의 스크린 접근 스크린에 스토리 포인트 필드 추가 6에서 설정한 이슈 생성/수정/기본 스크린에 스토리 포인트 확인 마무리이 글을 빠르게 정리해보게된 이유는 어드민 설정 &gt; 이슈 &gt; 커스텀 필드 &gt;스토리 포인트를 일부 이슈 타입에 설정한 경우가 있기 때문입니다.이 경우 시스템 관리자(어드민)이 스토리 포인트 필드의 이슈 타입을 설정해주어야 해당 이슈 타입에서 스토리 포인트를 사용할 수 있기에 종종 저도 까먹어서 정리해보게 되었습니다.(사실 그냥 제일 좋은 것은 스토리 포인트 필드를 그냥 any issue type으로 제한을 풀어버리면 모든 문제는 쉽게 해결됩니다. ㅎㅎ)","link":"/blog/2020/11/27/jira-set-story-points/"},{"title":"식기세척기 구매 고민","text":"식기세척기 고민하기코로나 시대에 살면서 집에서 밥을 해먹거나 시켜먹어도 설거지할 일이 많아졌습니다.아무래도 재택근무하면서 편하고 안전해진 비용이 설거지 비용으로 간게 아닐까라는 생각을 잠시하면서..이참에 적당한 식기세척기를 한번 사보자 싶어 이것저것 고민한 흔적입니다. 식기세척기(a.k.a 식세기) 고민에 도움이 될 만한 영상이나 링크들은 널려있어서 참고하시면 좋을 것 같네요. 귀곰: https://www.youtube.com/channel/UCiTGSmGgJtKTcjEvDk_zRhw 노써치: https://nosearch.com/recommendation/pick/kitchen/dish_washer/3-6%EC%9D%B8%EC%9A%A9 식세기를 구매하기 전에 고민했던 것들은 아래와 같습니다.공간 효율 / 비용 / 물 사용량(친환경) / 세척력 / 무설치 집 구조상 설치형은 어려우니 무설치로 사이즈도 확정된 상태였고 나머지는 비용 효율 고민을 많이 했네요. 식기세척기 후보 이름 링크 사이즈 용량 가격 쉐프본 워시폴8 https://smartstore.naver.com/kelivi/products/4993426240 55 x 50 x 45 6인 식기 379,000 SK매직 DWA-2800P https://smartstore.naver.com/themagic/products/5458807947 42 x 43.5 x 46.5 (20cm 상단 여유) 3인 식기 310,000 쿠쿠 3인용 https://brand.naver.com/cuckoo/products/4478502087 42 x 43.5 x 43.5 (50cm 상단 여유) 3인 식기 214,000 후보는 그냥 무설치 식기세척기 검색했을 때 나오는 것들을 중심으로 보았습니다.다만 3인 식기 용량 식기세척기는 프라이팬은 못 넣으니 6인용 이상으로 사야겠다고 보고 쉐프본 위시폴8을 1순위로 보고 고민했고 구매했어요. 식기세척기 고려사항세제 비용기존에 손설거지 할 때는 생각하지 않았던 것이 세제 비용이었습니다.식기세척기용 세제를 사용해야하고 식기세척기 한번 돌릴때마다 들어가니 횟수 계산도 슬쩍 해보았어요. 프로쉬 60개 타블렛 : 22,900 → 60개를 반씩 나누면 120회 → 회당 200원 다른 곳 60개 - 21,000 살림백서 세재 분말형 1kg+1kg: 16,900 → 6인용 5g 1kg 200회 → 회당 84원 할인가 2kg 400회 → 회당 42원 액상형은 1000ml, 6인용 10ml 사용 → 1000ml 100회 → 회당 169원 린스 살림백서 식기세척기 린스 1L: 9,900 → 물 1L당 1.5ml 사용 한번 설거지(물 10L)에 15ml 사용 → 66회 → 회당 150원 프로쉬 식기세척기 세척 세제 3개 세트: 19,900 1개월에 한번씩 사용해서 세척 12인용이라 6회 사용 가능. (6개 사면 1년 사용) 1년 사용 비용 39,800원 1년 총 운용 비용은 아래 정리된 내용으로 확인하실 수 있고, 린스까지 고려하면 가격은 프로쉬가 적절하다고 보았습니다.린스도 고려하면 비용이 더 많아지는게 함정인데 린스 제외하면 할인하는 세제들은 많았습니다.세제의 친환경 성격은 요즘 다 친환경이라 더 신경쓸 필요는 없었어요.추가로 식기세척기도 관리 차원에서 한달에 한번 세척해줘야하는 것 까지 고려하면 추가 비용이 있었습니다. 한 달 집에서 모든 끼니 먹고 설거지한다고 했을 때 비용 하루 2끼 31일 → 62끼 → 62번 설거지 살림백서 분말형 세재 + 린스: 62회x(84원+150원) = 14,508원 프로쉬 타블렛 세재: 62회 x 200원 = 12,400원 식기세척기 세척 한번: 39,800원/12 = 3,316원 한달 총 비용: 12,400원 + 3,316원 = 15,716원 1년 총 비용: 15,716원 x 12 = 188,592원 (약 20만원) 하루에 2번 식기세척기를 돌리고 한달하면 62번으로 봤는데 구매하고 사용해보니 하루에 한번 저녁에 돌리면 되네요.실제 생활하면서 계산 조정해보니 한달 총 비용은 6,200원 + 3,316원 = 9,516원1년 총 비용은 114,192원 10만원 초반대로 식기세척기를 돌려볼 수 있었습니다. 물 사용량 쉐프본 워시폴8 기준 평균 10리터 정도 사용한다고합니다. 집에서 손 설거지해보니 약 22리터 이상 사용하네요. (물은 받아놓고 사용하는 편) 싱크대 물 최대로 틀어놓고 사용하면 1초당 0.1L 사용 → 분당 6L → 20분 120L 대부분 싱크대 물 나오는 양은 비슷하니 식기세척기 물 사용량이 더 적다고 이야기하는 것 같네요. 이번에 정리하면서 손 설거지시 물 사용량이 생각보다 많은 것을 체감했습니다.물을 막 틀어놓고 설거지하면 60L는 거뜬하게 쓰더라구요.물을 약하게 틀어도 20분이면 60L고 약하게 틀면 잘 안닦여서 문제가 있긴하지만..물 사용량에 따른 비용도 계산해보려 했는데 생각보다 어려웠습니다.맑은물 사업소 상하수도요금 계산 Link1m^3 = 1000L, 20000L 사용시 27,840원 정도라는데…이건 그냥 마케팅 문구로 확인하렵니다 😂 총 정리식기세척기 구매시 필요한 세제 비용 및 여러가지를 고려했을 때 손 설거지보다 비용이 더 들어가는게 사실입니다.그 외에도 전력 사용 비용도 있긴한데 그 부분까지는 자세하게 정리하지는 않았어요. 구매 비용(약 38만원) + 1년 유지 비용(약 20만원)을 계산해보았을때 계산 결과는→ 1년 동안 58만원 정도 비용 발생 “1년 동안의 설거지 노동 비용이 58만원의 가치가 있는가” 생각해보았을때 식기세척기를 사는게 좋을까?→ YES / NO 이 글을 쓰고 있는 지금은 식기세척기를 구매해서 사용하고 있는데 삶의 질이 나아진 것 같은 기분은 듭니다. 😈하루에 한번 정도 점심, 저녁 먹고 난 식기들을 세척하고있어서 식기세척기 구매 전에 계산했던 것보다는 운용 비용이 크지 않은 것을 확인할 수 있었어요. (약 20만원 → 약 11만원)식기세척기에 그릇을 쌓는 것 요령, 세척 소음, 건조 소음 등등 사용하면서 몇가지 불편 요소는 있지만 구매 가치는 있었네요. 😃 나중에 이사하게되면 지금 사용하는 식기세척기를 계속 사용하게 될지 모르겠지만지금은 만족하고 있습니다. 👍","link":"/blog/2022/04/11/life-log1-dishwasher/"},{"title":"Hello Hexo Blog","text":"Hexo Blog기존에는 구글에 blogger를 사용했었는데 에디터 기능이 워낙 좋지 않아 다른 블로그를 고민하게 되었습니다.기존 블로그 주소는 https://pineoc.blogspot.com/ 에 지금까지 약 260개 가량의 포스트를 작성했습니다. 각종 서비스 소개, 기술 정보, 튜토리얼 등을 작성해왔고 요즘은 JIRA 관련한 포스트들을 작성해보고 있습니다. JIRA Plugin - ScriptRunner 소개 #1 JIRA Plugin - ScriptRunner 소개 #2 Hexo를 블로그 공간으로 사용하게된 이유전에도 한번 시험삼아 Jekyll로 github 주소로 해보고 잘 안되서 Hexo도 시도해봤었습니다.다만 진행하다가 설정도 잘 안되고 마음대로 테마 변경하는 것이 쉽지 않아 포기했었지요.크게 사용하고자하는 니즈도 없었습니다. blogger 에디터로도 쓰기 힘든 글이 별로 없었어서요. 최근 에디터에서 글쓰면서 텍스트를 붙여넣는데 HTML이 의도하지 않게 따라들어와서 매우 불편했습니다.그래서, 아, 그냥 마크다운으로 글 쓰는게 제일 편하긴 한데.. 이번에 넘어가 볼까? 하고 이렇게 글을 작성해보고 있습니다. Hexo도 글을 쓰는데 어려움이 또 있긴합니다만.. 텍스트 에디터를 사용할 경우 이미지는 어떻게 넣을지 표를 넣거나 레이아웃을 고민할 때, 시각적인 피드백이 바로오기 힘든점 이 부분은 로컬에 서버를 돌리고 문서를 저장할때마다 리로드(Reload)하게끔 하면되긴합니다만 블로그를 좀 더 운영하기 쉽게하기위한 설정 등 새로운 블로그 시작!어쨌든 새로운 공간에서 블로그를 시작하는데 이쁘게 잘 가꿔보겠습니다. :)","link":"/blog/2022/01/16/hello-hexo-blog/"},{"title":"Monday post, The best project management software for 2021","text":"Monday 포스트, 2021년 프로젝트 관리 소프트웨어https://monday.com/blog/project-management/the-complete-project-management-software-list/ 원격 근무나 근무형태가 다양해짐에 따라 프로젝트 관리도 중요해져 프로젝트 관리 툴도 많이 생겼습니다.기존에도 있던 툴도 많지만 프로젝트 관리 툴을 서비스하는 Monday에서 포스팅한 글에 많은 내용들이 있어서 한번 쓱 훑어보게되었어요. 이참에 Monday도 어떤 서비스인지 보았는데 가볍게 써보기에 좋은 것 같습니다. 포스트 내용을 좀 훑어볼게요.훑어볼 때 저는 프로젝트 관리에 Jira를 주로 사용하고 있어서 Jira와 비교해서 볼 예정입니다. ###목차 Editor’s picks: the most complete proejct management software for 2021 Best for startups Best for SMBs … 목차는 팀 사이즈나 목적에 맞는 툴을 소개하는 방식으로 정리되어있고 소개하는 툴이 많습니다. 그리고 역시나 에디터 픽으로 monday가 맨 처음에 있네요 😂 에디터 픽 Monday - https://monday.com/ 알록달록 이쁘게 관리할 수 있는 툴로 보이네요. (Asana 같은 느낌도 들고요) 기본적인 프로젝트 관리 툴 기능으로 태스크 보드, 로드맵, 간트 차트 등을 사용할 수 있고 여러가지 프로그램을 연동할 수 있다는 것도 보여주고 있네요. 좋았던건 관리하려는 프로젝트 뷰를 생성 전에 어떤 것을 관리할지, 어떤 직군인지 물어보고 맞춰서 설정해주는 것이 좋았습니다. Google Tables - https://tables.area120.google.com/about 구글 Suite를 사용하면 사용할 수 있는 툴로 보이는데 한국에서는 사용할 수 없다고 하네요 (US에서만.. 😢) 베타여서 작은 그룹에서 테스트하고 있는 프로젝트 관리 툴로 보입니다. 프로젝트, 태스크 뿐만 아니라 CRM 등 기능이 있어보이는데, 체험을 할 수 없어 뭔지 알기 어렵네요 Microsoft Lists - https://www.microsoft.com/en-us/microsoft-365/microsoft-lists MS office에 있는 todo list에 가까운 툴입니다. Office 기능들과 연동해서 자동화하고 공유하는데에 강력할 것 같은데 요즘 나오는 프로젝트 관리 툴과는 기능상 태스크 관리에 특화된 툴로 보여요. Notion - https://www.notion.so/ Notion은 다들 잘 아시는 툴 같은데 사실 프로젝트 관리 툴이라기 보다 정보를 유연하게 관리할 수 있어서 프로젝트 관리 툴로도 사용할 수 있는 것 같습니다. 프로젝트 관리 + 문서 관리도 같이 할 수 있으니 작은 팀에서 프로젝트 관리를 위해 잘 사용할 수 있을 것 같긴합니다. 다만 태스크 관리 + 개발된 내용을 연결하는 방법은 어려울 것 같은데.. 누군가 또 개발한 엔지니어가 있을까 싶긴하네요. 😈 Quickbase - https://www.quickbase.com/ 서비스 설명으로는 코드 없이 자동화하는 뭔가 RAS(로보틱 오토메이션 시스템) 같은 느낌이 드는 툴이네요 공사 현장이나 산업 현장에서의 자동화와 프로젝트 관리를 잘 엮은 서비스 같습니다. 공급, 비용 등을 함께 볼 수 있는 것을 보니 소프트웨어 프로젝트보다는 현장 프로젝트 관련 관리 서비스로 보입니다. (영 다른 영역의 관리 서비스다 보니 신기하네요 😸) 다른 툴, 서비스들에디터 픽만 설명했는데 사실 다른 툴 내용들을 다 다루기에는 거의 300개에 가까운 서비스들을 소개하고 있어서 이런 소개글도 있다고 소개하고 싶었습니다. 프로젝트 관리툴이 이만큼이나 많구나! 하고 알 수 있었긴한데 사실 툴은 툴이고 어떻게 동료들과 잘 사용할 수 있을지 연구하는게 더 중요하겠죠. 지금 사용하는 Jira, Confluence를 어떻게 잘 사용하고 프로젝트를 잘 관리할 수 있을지 고민을 더 해야겠다는 생각도 들었습니다. 다른 서비스 내용들도 더 궁금하시다면 포스트를 둘러보세요!","link":"/blog/2021/05/28/monday-post/"},{"title":"NDC22 프로덕션 발표 리뷰 - 피파 온라인4 라이브 서비스","text":"NDC22 발표 리뷰 6월에 여러 컨퍼런스가 있었는데 게임 업계 프로덕션 직군에서 일하는 사람이니 NDC 프로덕션 내용들은 잘 챙겨서 봐야겠다 싶어서 보면서 슬쩍 정리해보았습니다. 리뷰라고 말하긴했지만 배울 것과 우리 조직, 프로덕션 상황을 같이 보면서 되돌아볼 수 있는 것들이 있어 흥미롭게 발표를 보았어요. ㅎㅎ Youtube linkhttps://www.youtube.com/watch?v=rK83XrOU5Bg 리뷰처음에는 피파 온라인 서비스를 오래 운영한 팀의 이야기가 궁금해서 들어보았는데 외부에 공유할 수 있는 만큼 잘 정제(?)해서 공유해주셨구나 싶었습니다. 조직 구조, 업무 방식을 외부에 공유한다는게 긍정적인 것 보다 우려가 많을 수 있는데 적당히 추상화해서 공유해서 가능했던 걸까 싶었네요. 서비스 기간 피파 온라인4는 2018년 부터 서비스한 게임이지만 피파 온라인 시리즈는 발표에서 말하길 16년차된 서비스로 소개해주셨습니다. 히스토리를 좀 확인해보았더니 피파 온라인1은 2006년에 런칭했었네요. 1부터 보면 16년차 맞습니다. ㅎㅎ 게임을 개발하고 서비스하면서 어떤 어려움들이 있었을까, 어떤 그림자들이 있었을까 궁금하기도 했네요. 조직 구조 - 약 150명 정도 조직 구조는 기능 조직으로 구성하고 모든 기능 조직들을 묶는 Line 조직에 PD를 두는 것으로 보이네요. PD 중심으로 기능적으로 조직을 구성하고 조직에 시니어들은 매니저 부담을 덜고 개인과 주니어의 커리어와 제작의 퀄리티를 담당하게 한 것에 대해 매니저(DD)와 시니어를 분리해서 평가 체계를 가져간 것이 신기했습니다 2개의 개발팀(Meta/Core) 로테이션 라이브팀 운영을 해보려했지만 개발자들은 콘텐츠를 만들고 싶어하는 경향과 라이브팀 운영 특성상 노령화가 될 수 밖에 없고 해보았으나 조직 운영에 어려움이 있었던 것 같았습니다. 3, 6개월 단위의 업데이트도 시도해보았지만 라이브 대응이 어려웠다고 합니다. (이슈 대응과 업데이트는 다른 카테고리의 이슈인데 왜 그 단위만큼 늘어지는 구조를 사용했었을까하는 의문이 있었네요. 🤔) 의사결정 앞에서 조직 구조 이야기하면서 PD 중심의 조직이 있고 그 조직에는 모든 직군팀이 있다고 했었습니다. 이에 따라 기능 조직을 모았지만 목적 조직 아래에 기능 조직이 모인 형태로 이해했어요. 이런 목적 조직 구조의 특성상 의사결정 속도는 빠르게 이뤄질 수 있겠다 싶었습니다. 프로덕션 프로세스 각 프로세스 단계의 정의와 결과물의 정의를 깔끔하게 했다는 인상을 받았습니다. 라이브 서비스를 오래했던 만큼 프로세스가 잘 닦여있다는 인상을 받았어요. 각 프로세스에서 진행되는 일에 대해 다이어그램으로 표현한 것을 보면서 우리도 저런게 잘 정리되면 좋겠다 싶었습니다. Hardening 이라는 표현은 생소했는데 피파 온라인팀에서는 퍼블리셔와 함께 빌드가 단단한지 확인하고 문제가 있다면 수정하는 단계 정도로 정의한게 신기했습니다. (우리는 릴리스 준비 정도로 간략히 정리해볼 수 있겠다 싶었네요) 라이브 이슈 대응 우선순위 가이드 문서에서 기억에 남는 것은 이슈 우선순위에 따라 대응을 며칠 전까지 해야하는가에 대해 정의되어있었다는 점이네요. 추가로 연락 방법도! (전화, 메일, Jira 이런식으로 나눠짐) 라이브 이슈 대응 우선순위 가이드라인 내용이 우리도 필요하겠다 싶었습니다 라이브 서비스 플랜 롱텀 플랜을 만들고 명확한 기준으로 개발, 출시하고 있는데 피파 온라인 게임 콘텐츠 특성상 현실세계 시즈널 이벤트들이 있고 그에 맞춰 계획, 개발하고 있다고 합니다. 개인적인 생각으로는 코로나 영향으로 축구 경기도 연기되고 하느라 이벤트 대응에 이슈가 있었지 않았을까 싶긴했네요. 😂 발표 내용 노트개발팀 구조 22년 조직 변경 방향성: 직능적 구조(직군 모임)로 바꾸고 매니저 역할(목표 관리), 시니어 역할(업무 관리, 퀄리티 관리) 나눠서 결정을 빠르게하고 대응함 Core, Meta, Codev 등 직군별로 팀을 나누고 PD 중심 기능적으로 조직을 변경 2개의 프로덕션팀 - Core, Meta Core: Fun, Competitive Gaming, Core Ex 등 UI/UX 개발 Meta: 프로그레션, 라이브 서비스, 유료화, 개인화 경험 개발 2개의 프로덕션팀은 2개월 로테이션으로 콘텐츠 개발, 라이브 서비스를 돌아가면서 대응함 버그 대응: 본인의 팀에서 개발한 콘텐츠 버그는 콘텐츠 개발팀에서 수정한다 스페셜팀(DET): 개발환경 개선, 인프라 개선 등 긴 호흡으로 스페셜한 영역의 일을 함 Art, CODEV 등 팀이 있음 우리와 비슷한 이슈 버그 수정하더라도 1-2달 뒤에나 수정한 것을 배포할 수 있었음 Work Process High-level Roadmap 로드맵을 만들 때 PD는 어떤 것을 개발할지 결정 GD는 콘텐츠 목표, 방향성을 정의 Pre-Planning 피쳐에 대한 상세 정의 결과물: IDD, PDD, FDD 등 디자인 문서 Planning Pre Planning 하면서 이미 유관부서는 컨텍스트를 알고 있기에 안정적인 계획을 할 수 있음 결과물: FDD 기준으로 만들어진 TDB(기술 문서), 로그 설계 문서, 테스트 설계 문서 Development 진짜 개발, 프로덕션 시작 개발하면서 사전 테스트 프로세스를 진행하여 안정성을 올림 Debugging 테스트 문서를 기반으로 디버깅 진행 QA팀은 빌드 내에서 전체 기능 테스트 진행. 목표는 퍼블리셔 스테이징 환경에서 진행할 QA를 위해 빌드를 준비하는 것 Hardening 퍼블리셔 시스템, 모바일 플랫폼 확인 등 빌드 유효성 검증 테스트 결과물: 최종 빌드, 빌드 노트, 점검 노트 Release / Live Support 릴리스 모니터링 및 피쳐 분석 버그 모니터링 후 핫픽스, 다음 패치 목표를 결정하기도 함 결과물: 피쳐 분석 리포트, 유저 피드백들 피파온라인은 16년 동안 서비스한 게임으로 지금의 조직 구조가 탄탄하다고 평가하고 있음2022년 목표로 피파온라인을 완성해보려하고 있음 마무리NDC에서 소중한 프로덕션 사례를 발표해주신 EA Korea, 피파 온라인팀에 감사한 마음으로 보았습니다.사실 프로덕션, 내부 조직 구조 내용은 발표나 자료들을 찾아보기 쉽지 않은데요.이렇게라도 다른 개발 조직은 어떻게 살아가고 있는지 알 수 있어서 좋았습니다. 👍이 포스트 이후에 팀 내부에 우리 조직과의 차이점, 배울점을 고민해보면 좋을 것 같다는 생각이 들었네요.이만 포스트를 마치겠습니다. 🙏","link":"/blog/2022/06/18/ndc22-review-production/"},{"title":"꺼지지 않는 백그라운드 ngrok 실행기","text":"ngrok?https://ngrok.com/ 간단하게 설명하면 로컬에서 실행중인 서비스를 터널링(포워딩)해주는 서비스입니다.저는 주로 간단하게 만든 웹서비스를 잠깐 외부에서 테스트하거나 시연할 때 사용하곤합니다.근데 ngrok은 자꾸 껐다 켰다 하기에 귀찮아서 백그라운드로 오래 돌릴 방법이 없나 찾아보게되었어요. 긴 글을 읽기 귀찮으신분들은 요약만 읽어주시면 알 수 있습니다. 😸 꺼지지 않는 백그라운드 ngrok 실행기 요약 ./ngrok http 80 -log=stdout &gt; ngrok.log &amp; 그냥 백그라운드 실행 옵션으로 실행할 수는 있습니다. 터미널이 닫히면 ngrok도 같이 꺼집니다. screen을 사용해서 ./ngrok http 80 -log=stdout &gt; ngrok.log &amp; 스크린을 사용하더라도 스크린을 사용하던 터미널이 닫히면 ngrok도 같이 꺼집니다. 그냥 터미널 끄지말고 ngrok 백그라운드 상태로 두고 사용하자.. 꺼지지 않는 백그라운드 ngrok 실행?우선 ngrok으로 터널링 하는 방법은 서비스 페이지에 잘 나와있으니 백그라운드로 실행하는 방법에 대해 고민해보았습니다.ngrok을 4000 포트로 http 터널링을 하기 위해서 아래와 같이 실행할 수 있습니다. 12345678910111213$ ngrok http 4000ngrok by @inconshreveable (Ctrl+C to quit)Session Status onlineAccount Allen Yunseok Lee (Plan: Basic)Version 2.3.35Region United States (us)Web Interface http://127.0.0.1:4040Forwarding http://4a3ed4201b8f.ngrok.io -&gt; http://localhost:4000Forwarding https://4a3ed4201b8f.ngrok.io -&gt; http://localhost:4000Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 무료 버전은 포워딩을 랜덤으로 받는 것이 기본 옵션이고 결제를 하게되면 서브 도메인에 이름을 정해서 포워딩할 수 있습니다. Take #1근데 이렇게 실행하고 나서 다른 작업을 위해 이 터미널을 닫으면 그대로 포워딩이 풀려버립니다.처음엔 이걸 유지하기 위해 간단히 백그라운드 실행을 해보았죠. 12$ ./ngrok http 80 -log=stdout &gt; ngrok.log &amp;[1] 76732 이렇게 하고 ngrok.log 파일을 보고 URL에 접속하면 포워딩이 잘되는 것을 확인했습니다.다만 이것도 터미널을 닫으면 포워딩이 풀리는 것은 마찬가지였습니다. 😂 Take #2사실 원했던 것은 ngrok을 백그라운드로 계속 돌려두고 싶었던 것인데 방법이 없을까 찾아보았습니다.(터미널에 종속되지 않고 백그라운드로 돌아가는 서비스 말이죠.) 그래서 screen 명령어를 사용해서 터미널을 백그라운드처럼 두고 하면 어떨까 싶어서 시도해보았습니다.(없다면 설치해야하는 명령어입니다.) 123$ screen a$ ./ngrok http 80 -log=stdout &gt; ngrok.log &amp;# Ctrl-a, d를 입력하면 터미널에서 나오게됩니다. 이렇게 하면 스크린이 백그라운드에 떠있고 그 뒤에 ngrok이 실행되겠지 했지만…터미널 끄면 마찬가지로 꺼지게됩니다. 😂 😂 😂 Take #3ngrok 서비스에 뭔가 없나하고 찾아보게 되었습니다.stack overflow: How to keep ngrok running even when signing off of a server 글도 보고 찾아보게 되었죠. Installing ngrok as a service에서 ngrok을 서비스 형태로 설치하는 방법에 대한 것인데 알고보니 ngrok link는 엔터프라이즈 서비스로 돈을 많이 내고 써야하는 물건이어서 이것도 실패했네요. 🔥 끝더 찾아보고 시도해봤지만 더 좋은 방법은 나오지 않아서 결론은… ngrok을 실행한 터미널을 끄지말고 백그라운드 정도로만 ngrok을 사용하자. 로 결론을 내고 포스트를 마무리해봅니다. 🤭시도는 다 보실 필요 없으니 위에 요약만 보셔도 되었겠네요. 여기까지 읽어주셔서 고맙습니다. 😸 혹시 다른 방법이 있다면 댓글로 알려주세요!","link":"/blog/2021/01/25/ngrok-background/"},{"title":"P4V(Perforce Client) 프로그램 분석기","text":"P4V, Perforce 클라이언트https://www.perforce.com/products/helix-core-apps/helix-visual-client-p4vhttps://www.perforce.com/downloads/helix-visual-client-p4v 앞선 포스트에서 기본 내용을 소개한 것과 연관해서 P4V는 어떻게 만들어졌는지 궁금해져서 확인해보았습니다. 사실 git 클라이언트 프로그램은 많은데 “왜 Perforce는 다양한 클라이언트가 없을까?”하는 궁금함이 있었고 프로그램에 뭔가 있지 않을까해서 확인해보게되었네요. 🙈 앱(프로그램) 파일 구조 확인 on Mac Mac에서 p4v를 설치하고 내부 패키지가 어떻게 구성되었는지 확인해보았습니다.Frameworks에 Qt관련 폴더가 가득한 것을 보니 Qt를 사용해서 개발한 것 같네요. 실제로 패치노트에서도 Qt를 언급하고 있긴합니다. Qt 5버전을 쓰고 있네요.https://www.perforce.com/perforce/doc.current/user/p4vnotes.txt 1234567--------------------------------------------------------------------------Supporting Libraries for 2020.3.1/2059355 Qt 5.15.1 OpenSSL1.1.1 ICU 65.1 Helix Core C/C++ API 2020.2-------------------------------------------------------------------------- Qt 프레임워크?https://www.qt.io/ Qt 프레임워크를 간단하게 설명하면, C++로 개발한 프로그램(GUI 포함)을 다양한 플랫폼에서 사용할 수 있도록 개발할 수 있는 프레임워크입니다. 크로스 플랫폼 프레임워크죠 (React Native나 Ionic, Flutter 같은 프레임워크)다시 P4V 분석으로 돌아가봅니다. Qt Webkit, WebEngine을 사용한 웹 렌더링P4V에는 p4vjs를 통해 웹페이지를 보여주거나 커스텀 HTML을 통해 p4v에서 기본적으로 보여주는 것 외의 것들을 제공할 수 있는데요. 참고 데모: https://www.perforce.com/manuals/p4vjs-ug/Content/P4VJS-UG/run-demo-mode.html Qt에서는 크로미움(Chromium)을 사용한 웹킷으로 HTML을 보여줄 수 있도록 지원하고 있습니다.이를 이용해서 P4V도 HTML을 보여줄 수 있는 방법을 열어준 것 같네요. 더 분석할만한 프로그램 내용딱 파일 구조랑 사용한 프레임워크 외에는 더 분석할 만한 내용은 보이지 않네요. CLI 정도까지만 간단하게 보겠습니다.(리버스 엔지니어링까지 할만한 프로그램은 아니라고 생각이 들기도하구요. 😸) P4V 외의 P4 CLI(Command Line Interface)https://www.perforce.com/manuals/cmdref/Content/CmdRef/Home-cmdref.html p4도 당연히 CLI가 존재하고 커맨드라인으로 p4v에서 할 수 있는 것들을 할 수 있습니다.(커맨드를 잘 다룰 수 있다면, 더 많은 것들을 할 수도 있겠죠) 커맨드 리스트 p4 환경 변수 짧은 분석, 공부 마무리사실 p4v를 사용하면서 뭘로 만들어졌길래 뭔가 안이쁘지? 하고 확인, 정리해보았는데요.개발툴이라고 생각하고 보면 git 관리툴들이 다 이쁘게 만들어진게 아닐까하는 생각도 들었습니다. 이번에 정리하면서 기본적인 UI 외에 p4vjs로도 뭔가 더 커스텀하게 만들어볼 수 있으니 그걸 쓰면 더 이쁘게 쓸 수 있지 않을까하는 생각도 들었어요. 🤔 p4v를 사용하면서 더 공유할만한 내용이 있다면 또 들고 오겠습니다.다음 포스트에서 보아요! 😎","link":"/blog/2021/01/26/p4v-program-analysis/"},{"title":"Perforce(P4V) bookmark(북마크)","text":"Bookmark(북마크)P4V Guide: Bookmarks P4V에는 폴더나 파일에 빠르게 접근할 수 있는 기능인 북마크 기능이 있습니다.Tools &gt; Bookmarks 메뉴에서 볼 수 있는데요.(웹 브라우저에서 사용하는 북마크라고 생각하시면 될 것 같네요. 😸) Name에는 북마크 이름, Location에는 파일이나 폴더의 경로를 입력하고 OK를 누르면 저장됩니다.shortcut도 저장할 수 있네요. (맥에서는 ^+shift+[1~9 숫자]) 최대 9개의 숏컷을 저장할 수 있습니다. 북마크는 Tools &gt; Bookmarks에서 리스트를 볼 수 있고 Manage Bookmarks 메뉴에서 관리할 수 있습니다. 짧은 소개 마무리자주 찾는 폴더 경로나 파일을 빠르게 접근할 수 있는 북마크 기능을 알아보았습니다.mainline과 특정 스트림을 이동하는 작업이 많을 경우 북마크를 등록하고 숏컷을 이용하여 편하게 이동할 수 있을 것 같아요.다만, 북마크에는 타입에 따라 이동에 약간의 제한이 있습니다. folder: Workspace folder / Depot folder file: Workspace file / Depot file Workspace folder, file의 경우 현재 workspace와 맞는 북마크만 보여지고 숏컷을 이용하더라도 workspace가 일치하지 않으면 이동하지 못합니다.이와 달리 Depot folder, file은 현재 workspace와는 상관없이 이동할 수 있구요. 북마크 기능이 workspace까지 변경되면서 이동하지는 않으나 숏컷만으로도 유용한 기능이긴 한 것 같습니다.이미 잘알고 사용하시는 분도 있겠지만 사용하고 있지 않다면 한번 사용해보시는 것도 좋겠네요. 😸","link":"/blog/2021/02/19/perforce-bookmark/"},{"title":"Perforce(P4V) 체크아웃, 체크아웃 해제","text":"체크아웃(Check Out), 체크아웃 해제(Check out file Revert)Perforce Client(P4V) basics 체크아웃 방법 체크아웃하려는 파일을 워크스페이스 파일 트리에서 파일을 선택, 오른쪽 버튼으로 체크아웃합니다. Check Out, Check Out and Open 메뉴를 통해서 체크아웃할 수 있습니다. 체크아웃 참고 이미지, 에셋 등 Exclusive file을 체크아웃할 때 다른 작업자가 체크아웃하고 있을 경우 체크아웃할 수 없습니다. 작업을 하고자할 경우 현재 진행중인 작업이 마무리되고 체크아웃하여 작업할 수 있습니다. 체크아웃 해제 체크아웃한 파일들을 더 이상 수정하지 않는다면 Revert를 이용하여 체크아웃을 해제할 수 있습니다. Changelist에서 마우스 오른쪽 버튼 -&gt; Revert Files 또는 Revert Unchanged Files로 리버트할 수 있습니다. Revert Files : Changelist에 있는 모든 파일의 수정을 취소합니다.(리버트합니다) Revert Unchanged Files : Changelist에 있는 수정되지 않은 파일을 pending list를 제외합니다. (이것도 리버트라고 볼 수 있겠네요) 파일 각각 선택하여 리버트할 수도 있습니다. 다른 옵션 설정 없이 그냥 리버트해도 상관 없습니다. 두번째 옵션(Get the latest revision and then check out all files that were reverted)의 경우 리버트 후 파일들을 최신 데이터로 업데이트한 뒤 체크아웃해줍니다. 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce Client(P4V) basics Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능","link":"/blog/2023/08/06/perforce-checkout-/"},{"title":"Perforce(P4V) Revision Graph(리비전 그래프) 기능","text":"P4V 리비전 그래프 기능P4V User Guide: Viewing codeline history in the revision graph P4V의 리비전 그래프 기능은 파일이 어떻게 변경되어왔는지 한눈에 볼 수 있는 기능입니다.리비전 그래프 기능은 파일이나 폴더를 선택하고 오른쪽 버튼으로 Revision graph를 선택하면 볼 수 있습니다.단축키는 Mac은 Cmd + Shift + r / Windows는 Ctrl + Shift + r 입니다. 리비전 그래프에서 그래프 선의 의미리비전 그래프에서 각 리비전 블록과 화살표를 보실 수 있을텐데요.각 화살표의 의미는 리비전 그래프 오른쪽 하단의 Legend에서 확인하실 수 있습니다. Legend에서 보실 수 있듯이 색과 선의 형태에 따라 의미하는 것이 다르네요. 저도 정리하면서 어렴풋이 알던 내용을 정리한 느낌이라 좋군요. 😸 Branch, Merge, Edit 등 내용은 이름만 봐도 알 수 있을 것 같으니 이런 것이 있다 정도로 보고 넘어가겠습니다. 리비전 그래프 기능 상세리비전 그래프에서는 리비전 상세 내용에서 어떤 Integration에 의해 생성된 리비전인지, Label이 있는지, 코드 수정 사항이라면 짧게 Preview도 볼 수 있습니다. Details - 리비전의 상세 내용을 알 수 있습니다. 서밋 날짜, changelist, 설명 등이 포함되어있습니다. Integrations - 리비전이 어떤 Integration에 의해 만들어졌는지 알 수 있습니다. (그냥 서밋이면 해당 항목은 보이지 않습니다.) Labels - 해당 리비전에 설정된 레이블을 보여줍니다. Preview - 파일의 프리뷰를 보여줍니다. 파일이 크거나 바이너리일 경우에는 볼 수 없습니다. 마무리리비전 그래프를 볼 수 있다는 점에서 소스트리 커밋 그래프와 비슷하지만 파일 단위의 히스토리 그래프를 볼 수 있다는 점에서 특장점이 있는 것 같습니다.파일이 어떻게 머지되고 브랜치에 포함되었는지 볼 수 있어서 편리한 기능이라고 생각합니다.리비전 그래프 기능 자체가 직관적이라 간단하게 소개해도 내용은 충분했을 것 같네요.다음에는 타임 랩스 기능을 포스트해보겠습니다.","link":"/blog/2021/04/18/perforce-revision-graph/"},{"title":"Perforce(P4V) Search(검색) 기능","text":"P4V 검색 기능이번 포스트에서는 P4V에서 검색 기능을 알아보려합니다.가이드 문서: P4V User Guide: Searching and filtering P4V 검색 기능 가이드 문서를 간단히 요약하면,파일, changelist, workspace, branch, stream, job, label을 필터를 통해 검색할 수 있습니다.Cmd+F(Ctrl+F)를 통해서 검색도 가능합니다. changelist description 검색 기능사실 저나 대부분의 사용자는 submit된 changelist에서 설명으로 입력된 내용을 검색을 원할 것 같은데P4V에는 Ctrl+F 기능을 통해서 간단하게 제공하고 있습니다. (너무 간단해요)Find File 기능도 사실 Changelist 조건이 있어서 설명 검색이 가능하지 않을까해서 보았는데 숫자로만 검색이 가능한 상태입니다.(탭 이름도 파일 찾는 탭이니 그럴 수 있다고는 생각합니다.) 검색할 때 필터를 사용하라고 하지만 필터에도 description으로 필터링해서 보여주는 것은 없어요. 🤯이참에 p4vjs로 커스텀 html tab을 만드는게 낫겠다 싶어서 검색 페이지를 만들어보았습니다. p4v custom html tab을 통한 검색 기능 설정https://github.com/pineoc/p4v-html-utils 가이드에 맞춰 설정해주시고 Run Queries 메뉴를 눌러보시면 아래와 같은 화면으로 검색해보실 수 있습니다. 한번 사용해보셔요 😈 마무리P4V 검색 기능을 소개하려했는데 사실 기본적으로 제공하는 검색 기능이 크게 도움이 되는지는 모르겠습니다. 😂제가 모르는 기능이 있을지는 모르겠지만.. PM으로 업무를 하면서 사용해본 P4V에는 검색 기능이 좋지는 않은 것 같아요.그래서 custom html tab까지 만들어서 사용해보고 있는데 나름 만족하고 있습니다. 제가 P4V를 완전히 깊게 사용하지 못해서 모르는 부분이 있을 수 있으니 정정이 필요한 부분이 있다면 댓글로 남겨주세요! 향후 업데이트에 검색 기능이 강화될 수 있지만.. 현재는 원하는 changelist를 검색하기가 어려운 상태이긴합니다.description으로 필터링하는 기능이 생기기를 기원하며 마치겠습니다.감사합니다 😸 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce Client(P4V) basics Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능","link":"/blog/2021/03/31/perforce-search/"},{"title":"Perforce Stream, task stream &#x2F; 태스크 스트림","text":"Perforce stream: Task stream예전 포스트에서 스트림을 살펴보았는데요. Perforce(P4V) Stream(스트림)각 스트림 타입별 내용을 한번 정리해보고자 합니다. 😃이번 포스트에서는 Task stream, 태스크 스트림을 공부해보겠습니다. 가이드 문서: Working with task streams 참고: 스트림 유형(Stream types) Mainline: 최상위 스트림으로 메인 브랜치로 볼 수 있습니다. Release: 안정적인 소스 상태로 관리하기 위한 스트림으로 주로 안정적인 릴리스를 준비하기 위해 사용하는 스트림입니다. Development: 개발이 이뤄지는 피쳐 스트림입니다. Task: 작은 단위의 작업을 할 때 사용할 수 있는 특수한 스트림입니다. 자세한 내용은 링크를 참고하세요. Virtual: 특정 인원에게 제한된 뷰를 제공하기 위한 스트림입니다. 자세한 내용은 링크를 참고하세요. Task stream overview(요약)먼저 가이드 문서에 있는 내용들을 요약해보겠습니다. 태스크 스트림은 버그 수정이나 작은 기능 개발과 같이 제한된 작업에 적합합니다. 태스크 스트림은 브랜치의 총 파일 수에 비해 적은 수의 파일에 영향을 주는 가벼운 브랜치입니다. 태스크 스트림은 대개 일시적인 경우가 많으며 변경 사항이 통합되면 삭제되거나 언로드됩니다. 태스크 스트림은 리포지토리 메타데이터의 양을 최소한으로 유지하여 Helix Core Server 성능에 도움이 될 수 있습니다. ⭐각 태스크 스트림에는 고유한 이름이 필요하며, 이 이름은 태스크 스트림이 삭제된 후에도 재사용할 수 없습니다. 따라서 사이트에 사용자-날짜-작업 번호와 같은 명명 규칙이 있는지 관리자에게 문의하세요. 여기서 작업 번호는 이슈 추적 애플리케이션에서 식별자 또는 ‘작업(job)’을 나타냅니다. 다른 스트림들과 다른 태스크 스트림의 예외 사항 태스크 스트림에는 상위(부모) 스트림이 필요하지 않습니다. 따라서 스트림 depot에서 작업하지 않는 사용자도 태스크 스트림을 만들 수 있습니다. 태스크 스트림은 스트림 저장소에 있어야 하지만, 해당 저장소는 태스크 스트림의 보류 장소일 뿐입니다. 사용할 스트림 보관소에 대한 정보는 관리자나 프로젝트 리드에게 문의하세요. 자세한 내용은 상위 스트림 없이 태스크 스트림 만들기를 참조하세요. 상위 스트림은 다른 depot에 있을 수 있습니다. 태스크 스트림은 삭제되거나 언로드될 때까지 디포에 빠르게 누적될 수 있습니다. 프로젝트 보관함을 태스크 스트림으로 어수선하게 만들지 않으려면 관리자나 프로젝트 리더가 특정 스트림 보관함을 태스크 스트림의 전용 보관 장소로 설정할 수 있습니다. 이 경우, 태스크 스트림 저장소에 스트림을 프로젝트 저장소에 있는 상위 스트림의 하위 스트림으로 만들면 됩니다. 태스크 스트림이 다른 디포에 있더라도 부모 디포의 스트림 그래프 보기에 스트림이 표시되는 것을 볼 수 있습니다. 자세한 내용은 다른 저장소에 태스크 스트림 만들기를 참조하세요. 태스크 스트림은 자식 스트림을 가질 수 없습니다. 태스크 스트림은 상위 스트림을 다시 지정할 수 없습니다. 하지만 태스크 스트림을 일반 스트림으로 변환하면 해당 일반 스트림에 상위 스트림을 다시 지정할 수 있습니다. 💡 태스크 스트림이 다른 스트림과 다른점 💡P4V나 가이드 문서를 확인해보니 태스크 스트림만 unload 할 수 있네요.mainline, development, release 스트림은 삭제만 가능하고 Virtual 스트림은 다른 유형의 스트림이니 제외하고 나면 태스크 스트림만 가능합니다.스트림이 많을수록 서버 성능에 영향이 있을 수 있으니 사용하지 않는 스트림의 정보를 unload하고 데이터를 로딩하지 않는 형태로 서버 성능을 관리할 수 있는 형태인 것 같네요.추가로 Unload할 수 있는 것은 워크스페이스인데 퍼포스 서버 쪽에서 관리하는 데이터를 unload해서 서버 성능 관리를 좀 해야하나 봅니다.(저희도 workspace, stream 전체 현황 검토해서 정리가 필요하겠네요 ㅎㅎ 😂) 정리정리해보면, 태스크 스트림은 작은 작업, 버그 수정 등을 위한 피쳐 브랜치로 사용할 수 있는 스트림이라고 할 수 있네요.다른 스트림들에 비해 스위칭 속도가 더 빠르거나 그런 것은 아닌 것 같지만 어떻게 스트림을 생성했냐에 따라 다를 수 있을 것 같습니다.(스트림 생성시 부모 스트림의 데이터를 그대로 사용하는 설정 등..?) 가이드 문서와 다른 메뉴얼들만 보았을때는 퍼포스 서버 성능 관리를 위한 기능 같아서 작업자들 입장에서 어떤 것들이 좋은지는 더 살펴봐야겠네요.실제로 스트림간 스위치 성능이 다른지 확인해보고 추가 내용으로 포스트해보겠습니다. 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce Client(P4V) basics Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능","link":"/blog/2023/05/02/perforce-streams-task/"},{"title":"Perforce(P4V) Stream(스트림)","text":"Perforce Stream(스트림)?지난 포스트에서 작업공간(workspace)를 살펴보았는데요. Perforce(P4V) Workspace(작업공간) 관리이번에는 작업공간과 연결되는 서버 쪽 작업공간, 스트림을 살펴보겠습니다.(작업공간보다는 브랜치가 더 익숙한 것 같긴합니다 😸) 가이드 문서: perforce - about streams Stream DepotGit에서 저장소(Repository)와 같은 역할을 하는 Depot입니다.Depot 내에는 많은 스트림들이 있고 여러 유형의 스트림이 있습니다. 스트림 유형(Stream types) Mainline: 최상위 스트림으로 메인 브랜치로 볼 수 있습니다. Release: 안정적인 소스 상태로 관리하기 위한 스트림으로 주로 안정적인 릴리스를 준비하기 위해 사용하는 스트림입니다. Development: 개발이 이뤄지는 피쳐 스트림입니다. Task: 작은 단위의 작업을 할 때 사용할 수 있는 특수한 스트림입니다. 자세한 내용은 링크를 참고하세요. Virtual: 특정 인원에게 제한된 뷰를 제공하기 위한 스트림입니다. 자세한 내용은 링크를 참고하세요. 스트림 그래프(Stream Graph) 스트림 그래프를 보면 스트림간의 부모-자식(Parent-child) 관계를 설정할 수 있다는 것을 알 수 있습니다.이 관계에 따라 코드의 변경 사항을 전파할 수 있습니다. (rebase, merge할 수 있다는 이야기입니다.) 그래프 방향에 맞춰서 머지 다운(merge down), 카피 업(copy up)이라는 액션을 통해 소스를 머지, 리베이스합니다.가이드 문서에서는 Propagation(전파)라고 표현하고 있습니다. 이 전파 방식의 목표는 안정적이지 않은 스트림을 보다 안정적인 부모 또는 자식으로 최신 상태를 유지하여변경 사항이 덜 안정적인 스트림에서 보다 안정적인 스트림으로 전파될 때 덮어쓰지 않도록 하는 것입니다. 가이드 문서에 있는 내용을 가져왔더니 좀 어렵게 설명이 되었네요. 😢“스트림을 안정적으로 만들고 유지하는 것을 계층으로 전파하는 방식을 통해 이뤄질 수 있도록 했다” 정도로 이해하면 될 것 같습니다. 그래프에 있는 이미지를 짧게 살펴보면, rel1 : 릴리스 타입의 스트림으로 main1을 통해 머지 다운, 카피업 (전파)합니다 main1 : 메인라인 타입의 스트림으로 rel1과 전파할 수 있으며 dev1, dev2과 통신(전파)할 수 있습니다. dev1, dev2 : 각각 개발 타입의 스트림으로 main1과 전파하며 각자 dev11, dev22와 전파할 수 있습니다. dev11, dev22 : 개발 스트림의 개발 스트림으로 main1에는 직접 전파하지 못하고 dev1, dev2를 통해 전파할 수 있습니다. 여기서 각 스트림 노드에 회색이냐, 파란띠가 둘러져있냐는 부모 스트림 상속(Inherit) 유무를 뜻합니다.파란띠는 noinherit 으로 상속하지 않았다는 표시, 회색 노드는 상속했다는 표시입니다. 상속한 경우 부모 파일을 공유하거나 다른 경로에 맵핑할 수 있습니다. 자세한 내용은 스트림 뷰 설정에서 확인할 수 있습니다.(스트림 뷰 설정도 내용이 많아서 따로 정리해서 공유하겠습니다.) 스트림 정리!짧게 살펴본 스트림 정리해보겠습니다. Perforce에는 Depot(저장소) 하위에 스트림들이 있습니다. 스트림은 git에서 브랜치 와 비슷한 친구로 이해할 수 있습니다. 스트림은 계층 구조를 가질 수 있고 여러가지 타입으로 설정할 수 있습니다. 스트림 간의 코드 전파는 git 브랜치와 다르게 머지 다운, 카피 업과 같은 액션으로 코드를 머지하고 싱크합니다. 스트림 정리는 이만 마치고 다음 포스트에서 스트림 뷰 설정과 상속에 대해 공부하고 정리해보겠습니다. 😸 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce Client(P4V) basics Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능","link":"/blog/2021/06/21/perforce-streams/"},{"title":"Perforce(P4V) 파일 수정부터 submit까지","text":"들어가며Perforce Client(P4V) basics 앞선 Perforce 베이직 포스트에서는 P4V 클라이언트에서 기본적인 뷰의 구성이나 기능들을 확인해보았습니다.이번 포스트에서는 워크스페이스를 구성하고 파일을 Submit하고 Depot에 잘 반영되었는지 확인하는 과정을 살펴보려해요. 준비 사항파일 수정 및 submit 전에 작업할 워크스페이스를 설정해주세요.우선 P4V를 실행합니다. Server는 사용하고자하는 Perforce 서버 주소를 입력합니다. User는 로그인하고자하는 사용자 ID를 입력합니다. 사용자 ID는 Open Connection 창에서도 새로 만들 수 있을 수 있지만, 사내 계정 서비스 또는 LDAP 등으로 계정 관리가 되고 있다는 가정하에 ID를 입력하겠습니다. Workspace는 New를 눌러서 새로운 워크스페이스를 만들어보겠습니다. Workspace 만들기 앞선 Open Connection 화면에서 Workspace New 버튼을 클릭합니다. Workspace 만드는 화면에서 아래의 값들을 입력, 선택합니다. Workspace name: 워크스페이스 이름을 입력해주세요. 입력한 값에 따라 Workspace root(경로) 값이 맞춰서 변경됩니다. Workspace root: 워크스페이스 경로입니다. 경로 변경이 필요할 경우 Browse를 통해 경로를 확인하고 변경할 수 있습니다. Stream: 워크스페이스와 연결할 Stream을 입력합니다. Browse를 통해 스트림을 찾을 수 있고 입력창에서도 자동완성으로 찾을 수 있습니다. 모두 입력한 뒤에 OK를 누르면 워크스페이스가 생성됩니다. 다른 워크스페이스를 사용하고자할 경우에는 Workspace Browse를 통해 워크스페이스 리스트를 확인할 수 있습니다. 워크스페이스가 생성이 완료되었습니다! 🎉 Workspace로 가서 작업을 시작해보죠!이제 워크스페이스도 만들었으니 작업하러 들어가보겠습니다.처음에 들어가면 아래와 같은 화면을 볼 수 있을거에요. (상세한 탭 구성은 저와 살짝 다를 수 있습니다 😈 ) 왼쪽에 있는 Depot, Workspace 뷰에 작업할 파일 목록이 보여야하는데 처음에는 보이지 않을겁니다.아직 워크스페이스와 연결된 depot 스트림에서 데이터를 동기화하지 않았기 때문이죠.Get Latest를 눌러서 최신화를 해보면 파일들이 최신 데이터 상태로 동기화될겁니다. Get Latest를 하면 오른쪽 이미지 처럼 폴더 내에 파일이 생긴 것을 확인하실 수 있습니다.(설마 Get Latest를 하고 있는데 Perforce 서버가 죽거나 다른 분이 파일을 다 삭제하지 않았다면요 🤡 ) 파일 작업을 하려면 Perforce에서는 Check Out하고 작업을 시작해야합니다.(Check Out을 하지 않고 작업을 시작할 경우 각 OS 파일 시스템에서는 파일 잠금을 해제하라고 경고창이 나올거에요.) Code 파일(Non Exclusive File) 작업 코드, 텍스트 파일 혹은 Non Exclusive 파일 작업의 경우, Check Out 후 바로 작업할 수 있습니다.Check Out and Open을 눌러주시고 중간에 Select Pending Changelist 창에서 Changelist를 생성합니다.(이미 작업중인 Changelist에도 추가할 수 있으나 처음 작업한다는 가정하에 Changelist 생성해보겠습니다.) default Changelist 생성 후 파일이 열립니다. 파일을 수정하고 저장해보았습니다.Pending 탭에 있는 빨간색 세모 아이콘이 있는 default Changelist에 파일이 있을거에요. 파일 항목에서 마우스 오른쪽 클릭 후 “Diff against have revision”을 해보면 현재 가지고 Revision과 아직 반영하지 않은 수정한 내역의 변경 사항을 확인할 수 있습니다.(P4V와 함께 사용되는 P4Merge가 실행될겁니다. P4Merge가 없다면 설치하거나 다른 IDE를 통해서 볼 수 있어요.) 수정한 파일 내용이 문제가 없는 것을 확인했다면 실제 스트림에 반영하기 위해 Changelist를 Submit 합니다. Pending Changelist 항목에서 마우스 오른쪽 클릭 후 Submit을 선택합니다. Submit Changelist 창에서 Changelist 설명(Description) 항목에 값을 입력합니다. 설명에는 작업에 대한 상세 내용과 ITS(jira, redmine 등)를 사용한다면 issue 키를 입력합니다. Perforce job을 사용한다면 job을 입력하기도합니다. 모든 값이 잘 입력되어있다면 Submit! 변경사항(Changelist)이 잘 제출되었는지는 History 또는 Submitted 탭에서 확인할 수 있습니다. Asset 파일(Exclusive File) 작업앞서 코드, 텍스트 파일은 Non Exclusive 파일이어서 체크아웃 후 바로 작업가능한 것으로 말씀드렸습니다.주로 이미지 파일이나 게임 개발시 사용하는 머터리얼 애셋 등은 대부분의 경우 Exclusive로 설정되어있습니다. Exclusive로 설정되어있을 경우 내가 작업하고자 A.png 파일을 체크아웃 할 경우,다른 사람은 내가 체크아웃을 해제할 때까지 A.png 파일을 사용할 수 없습니다. 이미지 파일 또는 애셋 파일들은 여러 사람이 동시 작업할 경우 변경 사항의 컨플릭트를 해결하기 어렵기에동시 작업을 할 수 없도록 약속을 만들었다고 이해하시면 좋을 것 같습니다.(SVN, Git lfs에도 있는 파일 Lock 기능입니다.) pineoc_main3(user1)에서 test1.png 파일을 수정하기 위해 test1.png를 체크아웃합니다. pineoc_main(user2)에서도 test1.png 파일을 수정하려고했더니 이미 Lock이 되어있어서 체크아웃할 수 없습니다. pineoc_main3(user1)에서 작업이 끝나고 Lock이 풀려야 pineoc_main(user2)에서 작업이 가능합니다. 위 경우는 동일한 사용자의 워크스페이스 뿐만 아니라 다른 사용자의 워크스페이스에서도 체크아웃이 이뤄지면 파일은 잠기게됩니다 (Lock). 이후 작업을 완료하고 Submit하는 과정은 텍스트 수정 작업과 동일합니다. 작업된 Changelist 확인하기워크스페이스에서 체크아웃, 파일 수정, 서밋까지 했으니 잘 반영되었는지 확인해보겠습니다.보통은 작업 후 잘 반영되었는지 History탭에서 Revision을 확인해봅니다. 왼쪽은 워크스페이스에서의 History, 오른쪽은 리모트 depot 스트림의 History입니다. 서밋한 내용이 정확히 반영되었는지 보고 싶다면 해당 리비전에 마우스 오른쪽 클릭 후 diff를 이용해 확인해볼 수 있습니다.(이미지도 어떤 변경이 있었는지 알 수 있지만 다른 바이너리 파일들은 안됩니다.) 마무리이렇게 워크스페이스 생성부터 파일 서밋까지 간단하게 정리해보았습니다.Perforce를 사용하는 곳이 많지 않다보니 하나하나 가이드 문서가 소중한 느낌이긴하네요. 조금조금 팁이 생길 때 마다 포스트 남겨보겠습니다.이 문서가 하시는 업무에 도움이 되기를 바랍니다. 🙇‍♂️ 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce Client(P4V) basics Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능","link":"/blog/2021/12/19/perforce-submit/"},{"title":"Perforce(P4V) Time lapse 기능","text":"Time-lapse(타입 랩스) 기능?P4V에는 파일의 변경 내역을 Slider를 이용해서 리비전, 체인지리스트 단위로 볼 수 있는 타입 랩스 기능이 있습니다. Perforce Video Guide: Time lapse view https://www.perforce.com/manuals/p4v/Content/P4V/advanced_files.timelapse.html 타임랩스 기능을 보는 방법은 간단합니다. 파일에서 오른쪽 버튼을 누르고 Time-lapse View를 누르면 확인하실 수 있습니다.위 화면은 Time-lapse view의 Single revision 모드의 화면입니다. 파일 리비전 단위로 슬라이드를 움직여 히스토리가 변경되는 것을 볼 수 있습니다. 아래에 있는 내용은 가이드 문서에 있는 Toolbar 설명 테이블 내용을 간단히 정리해보았습니다. 타임랩스 뷰 메뉴 설명 Functions Descriptions Mode 얼마나 많은 리비전을 보여줄지 결정하는 옵션입니다.- Single revision: 한번에 하나의 리비전을 보여줍니다. - Incremental diffs: 2개의 인접한 리비전의 변경된 것을 강조해서 보여줍니다. - Multiple revisions: 특정 범위 리비전의 변경된 것을 강조해서 보여줍니다. Content range 시작과 끝 리비전을 정의합니다. Scale 시점 단위를 체인지리스트로 볼 것인지, 날짜, 리비전으로 볼 것인지 정의합니다. User 수정한 유저를 보여줍니다. Aging 수정 사항이 얼마나 오래되었는지 색으로 보여줍니다. Line numbers 줄 번호를 보여줍니다. Lifetimes 파일에 인접한 텍스트 청크가 얼마나 오래 같이 있었는지 그래픽 너비(width)를 통해 수명을 보여줍니다. Direct history 브랜치 히스토리를 제외하고 파일 리비전 히스토리를 보여줍니다. Branch history 브랜치 히스토리(머지, 인테그레이션)를 보여줍니다. 브랜치 정보는 타임라인 밑에 나타납니다. Originating changelist 각 리비전의 원래 체인지리스트에 대한 정보를 보여줍니다. Find 파일에서 텍스트 기반으로 검색한 결과를 보여줍니다. Go to line number 지금 보이는 코드 라인을 지정해서 봅니다. Go to Next diff 다음 변경 사항 Go to Previous diff 이전 변경 사항 Line ending 줄바꿈 관련 설정 Incremental diffs mode Incremental diffs 모드는 인접해있는 2개의 리비전의 변화를 볼 수 있는 모드입니다.현재 리비전과 직전의 리비전의 차이와 어떤 것이 변경되었는지 빠르게 볼 수 있을 것 같네요.2개의 리비전 정보도 같이 볼 수 있어서 변경 사항을 파악하는데 유용해보입니다. Multiple revisions mode 이 모드는 설정한 범위 내의 리비전 변화를 볼 수 있습니다.특정 범위 내에서 변경 사항을 확인하고 어떤 사람이 어떤 변경을 했는지 집중해서 확인하기에 좋을 것 같네요. 이미지 타임랩스 뷰 이미지의 경우 타임랩스 뷰를 통해 변화되는 것을 볼 수 있습니다. https://www.perforce.com/manuals/p4v/Content/P4V/advanced_files.timelapse_image.html 가이드 문서나 비디오에서도 기능에 대한 스크린샷이 없네요. 😂실제 테스트 해보니 이미지 변화를 페이드인/아웃해서 보여줍니다. (이미지가 크면 메모리 많이 먹겠다는 생각이 드네요 ㅎㅎ)어지간한 이미지 파일 형식은 다 지원하는 것 같습니다. 타입랩스 뷰 소개 마무리타임랩스 뷰 기능에 대해 간단히 살펴보았습니다.코드 변경된 내용을 확인하는 데에는 좋은 것 같은데 언어에 따라 포맷팅해주지는 못하는 것 같아 아쉽긴하네요. (P4V 기능 대부분 그런 것 같긴하지만 말이죠 😂) 이만 포스트 마칩니다.","link":"/blog/2021/04/30/perforce-time-lapse/"},{"title":"Perforce Trigger로 jira key → jira url로 변경해보기","text":"이전 글 돌아보기P4 trigger 설정하기: https://pineoc.github.io/blog/2022/01/31/perforce-trigger/ 계기이슈 트래커 연결: https://pineoc.github.io/blog/2022/05/21/think-issuetracker/ 최근 이슈 트래커(Jira)랑 Perforce를 연결해보려는 고민을 했었습니다.내부 엔지니어 피드백으로 “P4V에서 History탭을 볼 때, Changelist에 Jira Key가 있다면 Jira 링크로 연결되었으면 좋겠다”고 말씀해주셨어요. 업무할 때 큰 도움이 될 것 같다는 생각에 간단하게 할 수 있는 방법이 있지 않을까 싶어서 방법을 찾아보기 시작했습니다. 제가 생각한 방법은 2가지 정도였습니다. Perforce에 Submit할 때 P4 Trigger를 이용해서 Changelist를 서밋할 때, Description을 받아서 Jira Key → Jira URL로 변경해주는 방법 P4 custom HTML Tool을 이용해서 P4 changelist을 볼 때 Description을 받아 Jira Key → Jira URL로 변경해서 보여주는 방법 P4에서 Job 기능을 이용해서 Jira - P4 Job을 연결, Perforce와 Jira 정보 체계를 엮는 방법 이번 글에서는 1번 방법을 고민한 흔적을 공유해보려 합니다. 실제로 설정해보시려면 스크립트 구성 ~ 트리거 설정까지 참고하여 따라 진행해보시면 될 것 같습니다. 👍 1. P4 submit, populate 할 때 URL 변경해보기https://www.perforce.com/manuals/p4sag/Content/P4SAG/scripting.triggers.submits.html 우리의 목적은 Changelist를 서밋할 때, Description을 변경하는 것이니 submit할 때 Perforce가 어떻게 동작하는지 알아야합니다. 내부 동작을 보니 이벤트는 change-submit → change-content → change-commit로 우리는 change-submit 쯤 Description 정보를 가져와서 변경하면되지 않을까 싶습니다. 각 이벤트 상세는 가이드 문서에 있네요. change-submit: 변경 목록 생성 후 파일 전송 전에 제출 트리거를 실행합니다. 트리거가 파일 내용에 액세스할 수 없습니다. change-content: 변경 목록 생성 및 파일 전송 후, 그러나 파일 커밋 전에 제출 트리거를 실행합니다. change-commit: 변경 목록 생성, 파일 전송 및 변경 목록 커밋 후에 제출 트리거를 실행합니다. 트리거 설정 작업해봅니다. 참고: change-submit시 볼 수 있는 changelist는 아직 commit된 CL이 아니기에 pending changelist를 받게됩니다.https://www.perforce.com/manuals/p4sag/Content/P4SAG/scripting.triggers.variables.htmlA change-submit trigger is passed the pending changelist number; a change-commit trigger receives the committed changelist number. 스크립트 구성스크립트의 실행 순서를 대충 정리해보면 아래와 같겠습니다. change-commit 이벤트를 받아 스크립트를 실행 이벤트와 함께 받은 Changelist에서 Description을 가져온다. Description에서 Jira key를 확인, Description 마지막에 JIRA 항목으로 링크들을 만들어 추가 p4 –field Description=”3 단계 Description” change -o changelistNum | p4 change -if 끝 스크립트 트리거 설정 전 환경 설정아래 트러블 슈팅 쪽을 보시면 상세내용을 아실 수 있겠지만 Perforce 서버(P4D)쪽 환경 이슈가 있어서 사전 설정이 필요합니다. P4D 환경 p4 client 설정 P4D 환경의 p4 user 권한 확인하여 admin 이상의 권한으로 설정 스크립트 트리거 설정 admin 권한을 가지고 있는 계정으로 p4 triggers 명령어 실행 12Triggers: submit_data_hook_Test change-commit //Test/... &quot;C:\\Program Files (x86)\\Python38-32\\python %//Test/mainline/Tool/P4Triggers/submit_data_hooks.py% %change%&quot; P4D 환경에 맞춰서 파이썬 경로 설정 참고 필요한 파라미터는 trigger variable 에서 각 이벤트별 사용할 수 있는 파라미터를 확인할 수 있습니다. Trouble shootingsencoding(P4CHARSET) 이슈python 스크립트에서 p4 description을 가져오는 라인에서 에러가 발생 'utf-8' codec can't decode byte 0xc0 에러가 발생했는데 왜 발생했나 봤더니 p4 client charset이 cp949(euc-kr)로 되었는 것으로 확인 → ✨ p4 set P4CHARSET=utf8 로 설정 후 해결! P4 trigger 설정 후 Submit해도 Description 바뀌지 않는 이슈Try 1: change-submit 트리거로 스크립트를 실행함 → Description이 바뀌지 않았음→ p4 –field Description … | p4 change -i -u 명령어와 -f 옵션 모두 해보았으나 안됨 Try 2: change-commit 트리거로 변경하고 스크립트 -f 옵션을 넣음 → Description이 바뀌지 않았음 Try 3: stackoverflow에 물어보자 → https://stackoverflow.com/questions/72506774/p4-triggers-edit-changelist-description-after-submit-on-client→ 방법은 대략 알았지만 에러가 있다! 스크립트 외에 다른 문제가 있을 것 같아 에러 메세지를 더 분석해보았습니다. dm-UpdateChangeSpecF 에러1CompletedProcess(args=['p4', 'change', '-if'], returncode=1, stdout=b'', stderr=b&quot;Operation 'dm-UpdateChangeSpecF' failed.\\r\\nRequired parameter 'data' not set!\\r\\n&quot;) 위와 같은 에러가 나는데 가만히 보니 영어만 있는 CL에서는 에러가 발생하지 않음.한국어, 중국어, 일본어와 같이 아시아권 언어에 또 문제가 있는가보다 😂 관련 이슈 리포트 링크: https://youtrack.jetbrains.com/issue/IDEA-102104 → ✨ 스크립트쪽 input 값에 .decode(‘cp949’).encode(‘utf-8’) 해서 강제로 utf8로 변환해주었음. 해결! Client ‘test’ unknown - use ‘client’ command to create it. 에러실제로 P4D(퍼포스 서버)가 동작하는 곳에 트리거 설정 후 테스트 해보았더니Client 'test' unknown - use 'client' command to create it. 라는 에러가 발생함 대충봐도 client가 설정되지 않았으니 client 즉 workspace를 설정해야 CL을 수정할 수 있다는 것으로 보입니다. → ✨ P4D 동작하는 환경에 client 설정 후 트리거 동작. 해결!→ 추가로 P4D 동작하는 환경에 유저 권한도 admin 또는 super 권한을 설정해줘야합니다. 마무리이번에 트리거 설정하면서 P4D 환경에 설정할 것들도 많고, 스크립트에서도 신경써야할 것이 많은 점을 배웠네요.사실 파일 검사나 Description 검사정도만 한다면 권한 문제는 없었을텐데 다른 사람이 작업한 설명을 수정하는 것이니 권한이 필요한 트리거 작업이었네요.실제로 설정해보시려면 스크립트 구성 ~ 트리거 설정까지 따라 진행해보시면 될 것 같습니다.어렵거나 모호한 부분이 있다면 편하게 질문해주세요! 💪","link":"/blog/2022/07/31/perforce-trigger-update-cl-description/"},{"title":"Perforce Trigger 설정","text":"Perforce Trigger?퍼포스 시스템에서 변경사항을 서밋하거나 changelist가 생성될 때 등이벤트에 따라 스크립트를 실행시켜 여러가지 커스터마이즈할 수 있는 기능입니다. https://www.perforce.com/manuals/p4sag/Content/P4SAG/chapter.scripting.triggers.html 가이드 문서는 서버 관리자 가이드 문서로 써있는데 개발환경 개선을 해볼 수 있는 여지가 많은 시스템입니다.한국어 문서가 많지 않아 이번에 포스트를 작성해보게 되었어요. 😎 준비물 / Pre-requisite 당연하지만 Perforce(P4V)가 설치되어있어야합니다. Perforce 관리자 계정(Admin)이 있어야합니다. 관리자 계정이 아니면 ‘You don’t have permission for this operation.’ 라는 오류를 만납니다. Perforce 서버(P4D)가 동작하고 있는 환경에 실행하고자하는 스크립트 프로그램이 설치되어있어야합니다. Python, Node, Perl, Ruby 등 트리거 설정하기Trigger 설정을 시작하는 방법은 간단합니다.p4 로그인이 된 상태에서 cmd(또는 터미널)에서 p4 triggers 커맨드로 트리거 관리 파일을 수정합니다.수정 후 저장하면 트리거 설정 완료! 자세한 것은 아래에서 더 다뤄볼게요. p4 triggers 실행p4 triggers를 실행하면 컴퓨터에 설정한 텍스트 수정 프로그램으로 트리거 설정 파일이 열립니다.아래와 같은 내용을 보실 수 있을거에요. 123456789101112131415161718192021222324252627282930# Perforce Submit and Form Validating Trigger Specifications.## Triggers: a list of triggers; one per line. Each trigger line must be# indented with spaces or tabs in the form. Each line has four# elements:## Name: The name of the trigger.## Type: 'archive' external archive access triggers# 'bgtask ' server-side user processes# 'auth-check' check authentication trigger# 'auth-check-sso' sso check authentication trigger# 'auth-set' set authentication trigger# 'change-submit' pre-submit triggers# 'change-content' modify content submit triggers# 'change-commit' post-submit triggers# ...## For example,## Triggers:# cscheck change-submit //depot/... &quot;cmd %changelist%&quot;# no-oblits command pre-user-obliterate fail# mkspec form-out client &quot;%quote%//trig/scr.pl%quote%&quot;# daily_verify bgtask unset &quot;verify.pl&quot;## See 'p4 help triggers' for more information about triggers.Triggers: submit_data_hook_Test change-commit //Test/... &quot;C:\\Program Files (x86)\\Python38-32\\python %//Test/mainline/Tool/P4Triggers/submit_data_hooks.py% %change%&quot; 파일에는 트리거에 대한 설명 주석과 이벤트 타입, 트리거 예시가 있습니다.제가 설정한 트리거는 아래 4개 정도를 사용하고 있고 모두 change-commit 이벤트를 트리거하고 있습니다. 설정할 트리거 이벤트 고르기앞서 파일에서 보실 수 있듯이 트리거할 수 있는 이벤트가 많습니다.하나하나 알아보기에는 많아서 저는 어떤 것들을 사용하는지 + 가이드 문서를 공유해드릴게요. 가이드 문서: https://www.perforce.com/manuals/p4sag/Content/P4SAG/chapter.scripting.triggers.html 포스트 시작할때에도 공유드렸던 가이드 문서인데 하위에 submit, populate, push, fetch 등의 이벤트에 대한 정의를 보실 수 있습니다. 예시도 같이 있으니 참고하면 좋을 것 같습니다. 제가 설정한 트리거를 설명드리면, 주로 change-commit 이벤트를 트리거에 사용하고 있습니다.change-commit은 changelist가 서버에 커밋되어 저장될 경우 트리거되는 이벤트입니다. 상세 설명: change-commit trigger guide Perforce guide docs change-commit 이벤트 외에도 changelist 만들때 description 템플릿 폼 적용을 위해 form-out 이벤트를 사용해서 만들 수도 있습니다. form-out trigger guide: Perforce guide docs가이드 문서에서는 기본 클라이언트 워크스페이스 뷰를 설정하는 스크립트를 다뤘네요. 스크립트 작성Submit event trigger 문서 가이드 문서 예시로는 쉘스크립트로 “체인지리스트가 서밋될 경우 파일을 수정했던 사용자들에게 이메일로 수정 사항을 공유”하는 스크립트를 보여주고 있네요. python, node, perl 등 그 외의 스크립트를 사용하고자할 경우, 프로그램 경로를 잘 맞춰서 설정할 수 있습니다.제가 사용하고 있는 스크립트는 요렇게 생겼습니다.스크립트 목적은 작업된 changelist 내역이 슬랙 채널 통해서 공유되도록 하는 것입니다. 자세한 내용은 위 스크립트를 참고해보세요 😁 이벤트에 맞는 스크립트 설정change-commit(서밋 완료) 이벤트에 맞춰 스크립트가 실행되도록 트리거를 설정해보았습니다.이벤트 트리거가 발생되어 스크립트를 실행할 수 있도록 프로그램 경로 + 스크립트 + 파라미터 를 아래와 같이 입력합니다. 프로그램 경로는 P4D 실행되고 있는 경로에서 프로그램이 설치된 경로를 입력 스크립트 경로는 보통 Perforce에서 스크립트를 관리하니 경로에 맞춰 입력 필요한 파라미터를 입력해줍니다. 필요한 파라미터는 trigger variable 에서 각 이벤트별 사용할 수 있는 파라미터를 확인할 수 있습니다. 123# p4 triggers comments ...Triggers: submit_data_hook_Test change-commit //Test/... &quot;C:\\Program Files (x86)\\Python38-32\\python %//Test/mainline/Tool/P4Triggers/submit_data_hooks.py% %change%&quot; 설정 완료!위와 같이 트리거 설정 파일을 수정, 저장하고나면 트리거 설정을 완료됩니다. 트리거 설정 소개 마무리설정과 관련해서 간단하게 소개해보았고 제가 설정해서 사용하고 있는 스크립트도 공유드려보았습니다. 간단하게 수정된 사항이 발생할 경우 슬랙으로 정보를 공유하는 방식은 응용할 것이 많아보이니 참고해서 설정해보시면 좋을 것 같네요. 💪","link":"/blog/2022/01/31/perforce-trigger/"},{"title":"Perforce를 사용하는 회사, 사용자는 얼마나 될까?","text":"시작하며: 회사에서 Perforce Helix core를 사용하면서 드는 생각들21년에 퍼포스 기능에 대한 포스트를 한 10개 안되게 만들어보면서 회사 내에도 그렇고 외부에도 그렇고 참 자료가 없다는 것을 느낍니다.다들 퍼포스를 알게 모르게 쓰고 있는 것일까? 아니면 내부 자료로만 정리되고 있는걸까 하기도 하구요. 이참에 퍼포스를 사용하는 곳과 검색 트렌드를 좀 확인해보고 자료가 없다면 정리해서 조금씩 만들어보고자 합니다.(이 글에서 말하는 퍼포스는 버전 관리 프로그램인 Perforce Helix Core를 의미합니다.) 퍼포스 사용하는 회사들저는 주로 퍼포스는 게임 개발 회사에서 사용한다고 알고 있었습니다. 에픽에서 사용하는 것으로 알고있긴해요.(엔진 코드가 github에는 올라가 있지만 Perforce를 사용하고 있다고 들었습니다.) 퍼포스를 사용하고 있는 회사는 여기서 확인할 수 있었습니다.https://www.perforce.com/customers Industry를 보니 당연히 게임 개발이 있고 다른 카테고리로는 이커머스, 자동차 회사, 우주항공 쪽도 있습니다.(NASA, 포르쉐도 있네요. 😈)각 회사에서 사용하는 프로그램은 조금씩 다르긴합니다. 각 회사에서 사용하는 프로그램을 보면,Helix Core / Hansoft / Helix QAC 요렇게 나눠서 보여주고 있습니다. Helix Core: 버전 관리 프로그램 https://www.perforce.com/products/helix-core Hansoft: 애자일 툴 https://www.perforce.com/products/hansoft Helix QAC: C, C++ 정적 코드 분석 프로그램 https://www.perforce.com/products/helix-qac 각 프로그램에 대한 자세한 내용은 따로 다루지 않고 넘어가겠습니다.저는 Helix Core를 어디서 얼마나 어떻게 쓰고 있는지가 궁금해서요. 😸 유비소프트(Ubisoft)Featured Customer로 되어있는 유비소프트 케이스 스터디를 좀 보겠습니다.https://www.perforce.com/case-studies/vcs/ubisoft 2000명 이상의 개발자가 소스코드와 작업 애셋들(그래픽, 애니메이션 등)을 저장하고 있음 API 용이성, 유연성 / 이상적인 브랜치 방식 / 프록시 서버 효율성 개발 환경 개발자: 2000명 파일 수: 5TB(24,070,195개 파일) 변경 수: 166,642,479 리비전 (337GB 메타데이터) 아티스트와 모델러는 P4V와 P4GT 그래픽 도구용 플러그인을 이용하여 작업하기도 했음 P4Report를 사용해서 애셋과 코드에 대한 리포트 생성을 단순화했음 따로 확인해보니 p4 report 명령어는 없고 p4 files, p4 changes 등의 명령어로 정보를 관리한 것으로 보입니다 개발 속도를 높이기 위해 자주 사용하는 파일 캐시를 제공하고자 Perforce Proxy(P4P) 활용 많은 사내 도구가 개발되면서 소스 제어와 상호작용할 수 있는 유연한 API가 필요했음 API가 유연해서 유비소프트 내부 도구와 통합할 수 있어서 생산성이 향상되었음 여기도 오래동안 게임을 개발한 곳이어서 개발자 수, 파일 수가 어마어마하네요.퍼포스를 사용한 이유는 브랜치 방식도 방식인데 내부 개발 도구와 API 연동도 몫을 했나봅니다.내부 생산성을 위해 툴 개발 및 시스템 구축했다는 것이 인상깊었습니다. CD Projekt Red다른 게임사인 CD Projekt Red 포스트도 한번 보겠습니다.https://www.perforce.com/case-studies/vcs/cd-projekt-red 위쳐 개발하면서 사용했던 이야기를 써두었네요. (사이버펑크 개발할때도 썼겠죠 😸) 개발환경 개발자: 450명 이상 데이터베이스 크기: 205GB 저장소 크기: 10TB 파일 수: 1500만개 매일 최대 50-60GB 대용량 데이터 작업 진행 큰 파일을 작업하고 동기화하는데에 적합하다고 보고 있음 빌드 자동화: Helix Core와 빌드 시스템을 통합하여 변경 사항을 모니터링하고 테스트, 컴파일함 수정된 내역이 포함된 빌드가 완료되면 버그를 자동으로 닫음 앞서 보았던 유비소프트보다는 개발자 수가 적지만 저장소 크기와 파일 수는 꽤나 큽니다.파일수에 비해 저장소 크기가 큰 것을 보니 글에 있는 내용대로 파일이 큰 작업들을 다 저장소에 올리는 것으로 보입니다.작업물에 대한 공유를 모두 퍼포스를 통해서 하는 것 같네요.(다른 클라우드 서비스보다 퍼포스를 사용하는게 아닐까 싶기도하구요.) 그외의 회사들Helix Core 외에 다른 게임 회사들은 어떤 것을 쓰고 있나 보았습니다. EA, Capcom은 Hansoft를 이용해서 작업을 관리하고 있는 것 같습니다 Epic Games는 Helix Core를 사용하고 있긴하지만 따로 포스트를 올리지는 않았네요 영상으로 사례를 올린 곳은 영상의 길이가 짧아서 딱히 알 수 있는 것이 별로 없었습니다 구글 검색 트렌드퍼포스에서 소개한 회사의 이야기는 들어보았으니 구글에서 사용자들이 얼마나 검색하는지를 알아보겠습니다.Perforce, SVN, Git으로 확인해보니.. trends.embed.renderExploreWidget(\"TIMESERIES\", {\"comparisonItem\":[{\"keyword\":\"perforce\",\"geo\":\"\",\"time\":\"today 12-m\"},{\"keyword\":\"SVN\",\"geo\":\"\",\"time\":\"today 12-m\"},{\"keyword\":\"git\",\"geo\":\"\",\"time\":\"today 12-m\"}],\"category\":0,\"property\":\"\"}, {\"exploreQuery\":\"q=perforce,SVN,git&date=today 12-m,today 12-m,today 12-m\",\"guestPath\":\"https://trends.google.com:443/trends/embed/\"}); trends.embed.renderExploreWidget(\"RELATED_QUERIES_0\", {\"comparisonItem\":[{\"keyword\":\"perforce\",\"geo\":\"\",\"time\":\"today 12-m\"},{\"keyword\":\"SVN\",\"geo\":\"\",\"time\":\"today 12-m\"},{\"keyword\":\"git\",\"geo\":\"\",\"time\":\"today 12-m\"}],\"category\":0,\"property\":\"\"}, {\"exploreQuery\":\"q=perforce,SVN,git&date=today 12-m,today 12-m,today 12-m\",\"guestPath\":\"https://trends.google.com:443/trends/embed/\"}); Git이 압도적이어서 Perforce가 아예 바닥에 있어서 보이지를 않네요. Perforce만 두고 기간을 늘려서 보겠습니다. trends.embed.renderExploreWidget(\"TIMESERIES\", {\"comparisonItem\":[{\"keyword\":\"perforce\",\"geo\":\"\",\"time\":\"2004-01-01 2021-12-28\"}],\"category\":0,\"property\":\"\"}, {\"exploreQuery\":\"date=all&q=perforce\",\"guestPath\":\"https://trends.google.com:443/trends/embed/\"}); 2000년 초반까지만해도 꽤 많은 검색량이 있었는데 2010년들어서는 많이 떨어졌네요.나라별로는 세인트헬레나, 대한민국, 이스라엘, 중국, 캐나다, 미국 순으로 많이 검색했네요. 검색량만 봤을때, 지금은 대부분의 회사에서는 소스관리 프로그램 Git을 주로 쓰는 것 같고Perforce는 게임 개발 회사에서는 몇몇 큰 회사에서 쓰고 있는 것 같습니다. 생각 마무리어디 퍼포스 쓰는 회사 얼마나 되는지 살짝 맛을 보았습니다. 아무래도 게임 개발에 있어서 큰 애셋 파일들의 동기화가 시간이 걸리는데 그것에 대한 강점이 있고 작업물의 통합에도 편리함이 있으니 사용하는 것 같습니다.슬쩍 확인해보니 국내 게임 회사들도 꽤나 쓰고 있는 것 같네요. (N사, S사, P사 등)https://www.perforce.com/support/self-service-resources/documentation 퍼포스 가이드 문서도 이것저것 있는데 아무래도 영어이기도하고 활용하기 어렵게 작성되어있기도해서 조금씩 공부하면서 포스트 해볼 것 같습니다.가이드 문서가 부족해도 회사에서 쓰고 있는 시스템이니 생산성을 올릴 수 있는 방법도 고민해야하고 가이드 문서들도 좀 챙겨보고 그래야겠죠. ㅎㅎ이만 생각 포스트 마치겠습니다.","link":"/blog/2021/12/28/perforce-user-company/"},{"title":"Perforce(P4V) Workspace(작업공간) 관리","text":"Workspace(작업 공간)?P4는 workspace을 만들고 그 공간에서 작업(checkout, submit 등)을 합니다.(말 그대로 작업 공간이니 당연한 말을 하고 있었네요. 🙈) Perforce 가이드 문서에는 workspace를 아래와 같이 설명하고 있습니다. Workspace: Helix Core server에서 관리하는 파일의 개정판을 작업하는 워크스테이션의 폴더 또는 디렉토리입니다. 단순하게 보면 작업 공간이긴하나 git과 다른 점은 p4 서버가 내 작업 공간 정보를 가지고 있다는 것 입니다. 위의 화면은 서버에 등록된 workspace를 선택하여 사용할 수 있는 화면입니다.Show only workspace available for use on this computer 옵션을 통해서 현재 컴퓨터에서 만든 workspace를 필터링해서 보고 선택하여 사용할 수 있습니다. Workspace 만들기시작 화면에서 Workspace 만들기작업을 시작하기 위해 workspace를 만들어보죠. p4v를 실행하면 제일 먼저 아래화면을 보실겁니다. 이 화면에서 Workspace에 있는 New 버튼을 눌러보면 아래와 같은 화면을 볼 수 있습니다. 이 글을 보는 모든 분들이 같은 화면을 보지는 않겠지만, Workspace name, Stream에 텍스트를 입력해줍니다.Workspace name은 workspace의 이름이고 Stream은 해당 workspace에 어떤 스트림을 매핑할지 고르는 거에요.Stream은 Browse해서 찾을 수도 있고, 입력칸에 검색해서 입력할 수 있습니다.(직접 입력하면 Stream이 정확하게 입력되지 않을 수 있으니 직접입력하고 자동완성되는 항목을 선택하는 것을 추천합니다.) 이렇게 workspace를 만들고 Open Connection 화면에서 접속을 진행합니다. 현재 Workspace에 접속한 상태에서 다른 Workspace 만들기시작 화면에서 Workspace 만들기 방법과 같지만 현재 접속한 화면에서 다른 workspace를 만드는 방법도 있습니다. 상단에 있는 메뉴에서 Connection &gt; New Workspace​를 선택합니다. Streams tab (오른쪽 탭)에서 workspace를 만들고자하는 스트림에 마우스 오른쪽 클릭 후 New Workspace를 선택합니다​. Workspaces tab (오른쪽 탭) 상단에 드롭박스 메뉴를 선택한 뒤에 New Workspace를 선택합니다. 위에서 각 New Workspace 메뉴 선택한 뒤에 workspace 만드는 방법은 동일합니다. Workspace에서 작업하기workspace를 만들었으니 작업을 위해 소스들을 가져와야겠죠?다만, 이 포스트에서는 Get Latest 내용만 간단히 보고 넘어가겠습니다.(workspace와 관련한 내용을 다루기 위한 포스트니까요 😸) 현재 workspace에 연결된 스트림에 있는 모든 파일을 싱크(Sync)하고자 한다면 현재 폴더에서 Get Latest를 선택해주시면 됩니다. 또는 특별히 필요한 폴더만 싱크하고자 한다면,오른쪽 탭에서 Depot에 스트림 하위에 필요한 폴더에서 마우스 오른쪽 클릭으로 Get Latest Revision을 선택하여 원하는 것만 싱크할 수 있습니다. 이후에 수정이 필요한 소스를 Checkout하고 작업한 뒤에 Changelist를 만들고 Submit하면 커밋이 완료됩니다. 👍 나중에 changelist, submit까지 흐름을 간단하게 정리해보면 좋겠네요. Workspace 이동(Switch)작업을 하다보면 브랜치를 이동해야하는 경우가 있습니다.퍼포스에서는 workspace가 곧 스트림에 연결되어있으니 workspace를 이동하여 작업합니다. 위 예시 스크린샷은 같은 스트림을 보고있는 workspace이지만, 다른 스트림을 바라보는 workspace로도 이동할 수 있습니다. Workspace 삭제(delete)P4 Guide: Workspace Delete &amp; Unload workspace를 삭제하는 방법은 간단합니다. 삭제하고자 하는 workspace에 작업중인 내용이 있다면 리버트합니다. (pending changelist, shelve가 있다면 revert해줍니다.) View &gt; Workspaces 메뉴에서 Workspaces 탭을 열어줍니다. (이미 열려있다면 해당 탭으로 갑니다) 마우스 오른쪽 클릭을 누른 뒤 삭제합니다. 삭제하고자하는 workspace에 작업중인 내용이 있다면 아래와 같은 오류가 발생할 수 있으니 작업중인 내용이 있는지 확인해보세요. Client 'pineoc-feature1' has files opened. To delete the client, revert any opened files and delete any pending changes first. An administrator may specify -f to force the delete of another user's client.예시로 삭제해보려했는데 파일 하나가 checkout 되어있어 위와 같은 오류를 볼 수 있었습니다. 가이드 문서에 있는 언로드는 제가 테스트하는 workspace에서는 나오지 않아 넘어가겠습니다. Workspace 관리 마무리이렇게 Perforce에서 workspace를 생성하고 이동, 삭제하는 것까지 살펴보았습니다.사실 더 자세하게 정리하면 이야기할 내용이 많지만 use case 별로 정리를 하고 포스팅을 해봐야겠네요. 😎 다른 Perforce 가이드 문서들 P4V 소개 - 기본 개념 및 Cheat Sheet Perforce Client(P4V) basics Perforce(P4V) bookmark(북마크) Perforce(P4V) Revision Graph(리비전 그래프) 기능 Perforce(P4V) Search(검색) 기능 Perforce(P4V) Workspace(작업공간) 관리 Perforce(P4V) Stream(스트림) Perforce Stream, task stream / 태스크 스트림 Perforce(P4V) Time lapse 기능","link":"/blog/2021/02/10/perforce-workspace/"},{"title":"Pineoc의 2019 Retrospective(회고)","text":"2019 Event Graph Personal Events블로그(Blog)https://pineoc.github.io/blog/ 원래는 Google 서비스 중에 blogger를 사용하고 있었는데, 사용성이 별로 좋지 않고 결정적으로 테마가 맘에 안들어서 Hexo를 이용해서 블로그를 만들게 되었다. (결국 안이뻐서 바꾼거였다.) 기존에 있던 Blogger 블로그는 닫지는 않은 상태로 Github 호스팅을 이용하여 블로그를 하나 더 만들어둔 상태다. 4월에 블로그를 만들고 가꾸기 시작했고 Jira, Confluence 등 내가 현재 업무에서 사용하는 서비스들에 대한 팁이나 공부한 내용들을 남기고 있다.최근에는 스크립트러너 플러그인에 대해 많이 남기고 있는데, 사용법이나 팁 들을 조금 더 잘 적어두고 영여권에서도 참고할 수 있도록 영문 버전도 같이 한번 챙겨보고 싶어졌다. (사실 외국에서도 검색 유입이 있어서..) 매일 방문자가 많지는 않지만, 꾸준히 늘어나고 있는 상태이긴하다. 4월부터 매달 꾸준히 글을 쓰려고 하는데 아직 글의 수가 많지 않다. (현재 26개. 30개도 안됨) 2020년에는 한달에 최소 3개씩 포스트를 남겨보도록 해야겠다. 좋은 컨텐츠를 만들려면 공부를 더 해야겠지만 어떤 공부를 더하고 정리해서 컨텐츠를 만들지 고민해봐야겠다. 공부, 스터디구글 클라우드 스터디잼 (쿠버네티스 스터디)https://sites.google.com/view/cloud-studyjam 1월 부터 진행되었던 구글 스터디잼을 했었다. 회사 동료분들과 티셔츠와 후드티를 얻기위해(?) 스터디 그룹을 꾸려서 진행했다. 스터디 참가 조건이 스터디 그룹원 4명 이상이어서 PM분들을 꼬셔서 진행했었다.(사실 내가 티셔츠가 탐나서 일단 인원을 모은 것이긴 했지만.. 😀) 스터디가 시작되고 나서는 https://www.qwiklabs.com/ 라는 곳에서 클라우드 관련 내용을 시작하게 되었고, 쿠버네티스 강좌를 진행했다. https://www.qwiklabs.com/quests/29?catalog_rank={“rank”%3A2%2C”num_filters”%3A0%2C”has_search”%3Atrue}&amp;locale=en&amp;search_id=1811510 PM분들과 진행했던 스터디이기도 해서 내가 먼저 진행해보고 어려울 것 같은 지점이나 헤맬 수 있는 곳을 찾아 같이 공부해나갔다. 그 후에, 스터디를 대부분 잘 끝내서 티셔츠와 후드를 받을 수 있었다. 아두이노(Arduino)아두이노 키트를 사서 몇개 끄적끄적하다가 안하고 있는 상태지만 기본적인 코드를 작성해보고 핀도 조금씩 해보았다. 사실 튜토리얼이나 Getting Started 수준으로 밖에 하지 않았다. 너무 귀찮아서 모터 달고 리모콘으로 껐다켰다 할 수 있게 했지만 스위치에 모터가 잘 안붙어서 망했다. 아두이노를 사서 불을 껐다켰다할 수 있는 것을 만들었고 나중에 센서를 이용해서 다른 것도 해보고자 생각만하고 있다. (불끄는 것은 지금 만들어 놓고 사용하지 못하는 상태다.) AUG(Atlassian User Group) 모임 참석6월 쯤 페이스북을 보다가 AUG라는 곳에서 “카카오에서는 어떻게 Jira를 사용하고 있을까”와 같은 주제로 세미나를 진행한다고 하여 참여신청을 했었다. http://confluence.augkorea.org/pages/viewpage.action?pageId=27754587 세미나에서 이호정님이 발표를 해주신 내용을 재미있게 들었고, 이후 행사도 참여하게 되었다.8월에는 발표 제안을 받아 스크립트 러너(ScriptRunner) 플러그인에 대해 소개하는 발표(스크립트러너 꼼지락꼼지락)를 하기도 했다. http://confluence.augkorea.org/pages/viewpage.action?pageId=27755143 9개의 세션 중, 1개의 세션으로 발표했었다. 지금도 세미나, 모임이 있을 때 시간내서 찾아가고 있다. AUG Seoul Facebook: https://www.facebook.com/groups/atlassiankorea/ Confluence: http://confluence.augkorea.org/dashboard.action 결혼 계획대학교 때 부터 만난 여자친구와 9월 부터 결혼 계획을 하고 이것저것 알아보고 예약하기 시작했다. 결혼할 때 스튜디오 사진이나 다른 이벤트들을 할 생각이 없었어서 일정 자체가 넉넉하다고 생각했었지만, 사실 시간이 많이 남은 것은 아니었다. (결혼식 자체가 준비할 것이 많아서 그런 듯하다.) 금전 문제부터 결혼식은 어디서 할지, 혼수, 상견례 등 생각할 것도 많고 같이 이야기하고 결정할 것도 많았다. 이 때에 부모님하고 많은 이야기를 했던 것 같은데, 의견이나 정보 전달을 제대로 하지 못해 어려움이 있었다.(현재 나의 클래스가 PM인데 정보 전달과 의견 조율이 어려웠다는게 함정..) 지금도 진행 중인 이벤트이고 계획을 세워서 어떤 것들을 알아보고 정리해야하는지 같이 이야기하면서 진행하고 있다. 운동결혼 계획을 하면서 시작하게된 것은 아니고 회사 동료 KH님이 PT하고나서 살이 많이 빠진 것을 보고 어디서 하냐고 물어봤었다. 그래서 어찌저찌하다가 상담을 받게되었고, 바로 등록하게되었다. (?) 사실 “운동은 혼자하면 되지 누가 가르쳐줘야 하나?”라는 생각을 가지고 있었다.그런데 지금은 PT를 가르쳐주고 계시는 피터(Peter) 트레이너님은 운동하는 방법에 대한 강의를 해주는 느낌이어서 재미있게 배우고 있다. 이렇게 운동을 하면 이런 근육을 쓸 수 있다는 것을 알 수 있어서 몰랐던 내 몸을 찾아가는 중이다. 사실 돈도 많이 들었어서 더 열심히해야겠다는 생각과 이정도면 충분하지 않나 하는 생각도 있지만,내 몸을 다알고 건강하게 살 수 있도록 운동, 체력관리를 열심히하려고 한다. 항목 8/29 12/26 diff 체중(kg) 87.6 79.6 -8 골격근량(kg) 38.7 38.3 -0.4 체지방량(kg) 19.9 12.9 -7 BMI 27.3 24.8 -2.5 체지방률(%) 22.8 16.3 -6.5 번아웃(Burnout)지금와서 생각해보면 9월에 운동을 시작한 계기가 번아웃일 수도 있겠다는 생각이 든다. 8월부터 회사에서 일도 손에 잘 잡히지 않고 개인적인 퍼포먼스도 나오지 않아 헤메고 있었다. 나중에 이야기하겠지만 6월 말부터 팀장님이 이직 의사를 이야기하고 8월 말에 퇴사하셔서 팀 업무에 대한 조율을 잠시나마 하게되었었다. 개인적으로는 우리 팀이 어떤 일을 해야할지, 우리 조직이 정확히 어떤 목표를 가지고 있는지 명확하지 않다고 생각했었고 이런 혼란한 상태에서 업무를 맡게되었고, 에너지도 없었던 시기라 퍼져버렸다. 팀, 조직의 목표를 같이 정의하고 팀원들과 협업해야하는 업무를 해야하는데 한창 지쳐있었을 때라 아무것도 못하고 8월부터 멈춰버렸다. 그래도 팀원들의 이야기도 듣고 해야하는 업무들은 해나갔지만, 처음으로 회사가기 싫다는 생각을 하게된 것을 보고 나도 번아웃이 왔구나 라는 생각을 하게되었다. 지금 이 글을 쓰고 있는 동안에도 생각해보면 괜찮아졌을까 하는 생각이 들지만..새해에 열심히 살아보자하고 에너지를 모으는 중이기도 하고, 팀장님이 다시 돌아와서 힘내서 해보려한다. 스페인(바르셀로나) 여행회사에서 매년 해외 게임쇼에 참가할 수 있도록 인센티브 트립을 보내주는데 11월 말에 바르셀로나에서 하는 나이스원 바르셀로나 게임쇼(Nice One Barcelona)를 다녀왔다. 같이 일했던 동료도 있었고 한번도 이야기해보지 못한 분들도 있었지만 서로 챙겨주고 이야기도 많이할 수 있었던 여행이었다. 게임쇼는 게임 행사장에 게임이 많지도 않았고, 체험부스도 흥미로운 내용이 없어서 아쉬웠다. 나중에 든 생각은 우리나라에서하는 지스타 게임쇼가 더 풍성하다는 생각이 들었다.(지스타가 조금 더 공간 효율적이고 컨텐츠가 많다는 생각이 들었다.) 바르셀로나 게임쇼 외에는 바르셀로나 지역 가이드 투어를 신청해서 가우디 투어나 시가지 투어를 했는데 모두 색다른 경험이어서 좋았다. 바르셀로나 음식은 매운 음식이 없어서 힘들었지만 다 맛있었다. 다만 한국에서 한창 운동한다고 닭가슴살만 먹다가 맛있는 돼지고기를 엄청 먹어서 살이 쪘을거라 걱정했는데 근육만 빠져서 더 빡세게 운동했어야했다. ㅠㅠ 번아웃된 상태에서 여행을 가는 것이 얼마나 에너지 충전이 되는 것인지 여행 중에 알게되었고 여행을 종종 가야겠다는 생각을 했다. 여행 중에 일 생각을 안했던 것이 가장 중요하지 않았을까 하는 생각이 들었다. Works52시간 근무2019년 초에 나에게 가장 큰 이슈는 52시간 근무였다. 2018년에 많은 야근을 했고 2018년 12월에는 우스갯소리로 “2019년에는 일주일에 2번만 야근하자”라고 이야기했었던 기억이 있다. 지금 생각해보면 생각보다 2019년에는 야근이 있긴했지만 그렇게 많지는 않았던 것 같다 사실 야근이 많지 않았던 것은 52시간 근무를 시작하게된 것 때문이 아닐까 한다. 다른 회사에서도 그렇고 300명 이상의 회사에서는 4월부터는 52시간을 도입해야한다고 했기에 여기도 4월에 바로 도입하긴 한 것 같다. 유연 근무제로 시간을 11시~16시까지 코어 타임으로 두고 자율적으로 일하도록 가이드되긴 했으나 처음에는 다들 적응 기간이었어서 야근한 것 같다. 일은 그대로 였으니.. 그래도 하반기에는 나름 야근이 줄어드는 분위기이긴 했으나 일이 많은 곳은 여전히… (이하 생략) Jira 프로젝트 관리회사에 입사하고 지금까지 Jira 프로젝트, 시스템 설정을 해왔다. 프로젝트에 필요한 기본적인 설정부터 각 팀, PM이 필요한 설정 등을 통해서 모두가 일을 효율적으로 할 수 있도록 도왔다. 사실 Jira 시스템을 관리하고 프로젝트도 관리도 내가 해보고 싶어서 하는 것이기도 했다. 실제 나의 핵심업무는 아니지만 모두가 일하는 공간을 가꾸는 역할을 하고 싶었다. 다만 Jira 프로젝트를 정원으로 비유했을 때, 정원을 가꾸는 마음으로 한다면 정원을 방문하는 모든 사람을 위해서 기여해야겠다는 생각을 했다. 방문한 사람들도 정원의 관리 방식을 존중하고 깨끗하게 사용해야겠지만 제일 중요한건 모두가 정원에서 행복하게 지낼 수 있어야 한다는 것. 사실 사람들이 편한대로 설정을 바꾸고, 정보도 업데이트 안하고 이슈를 삭제하고 하는 것에 대해 스트레스를 받곤 했지만 2020년에는 그렇게 생각하지 않고 잘 사용할 수 있도록 돕자고 마음먹어본다.(사실 어렵게 세팅해두었으니 입력하기 힘든 것도 있었을거고, 각자의 사정이 있었겠지..) 슬랙봇 개발나와 개발조직에서 Jira를 조금 더 가까이 편하게 사용할 수 있도록 봇을 개발하기 시작했다. 슬랙봇 프로젝트는 pino-bot이라는 프로젝트로 작년 8월부터 만들어온 프로젝트이다. 2019년 4월에 사내에서 많이 사용하게되어 AWS 인스턴스도 하나 할당받아 서비스하고 내부 Gitlab 저장소에 옮기면서 코드관리도 했다.(아직까지 혼자 개발하고 있는 중이다. 😅, 올해는 리팩토링도 하고 TS로 마이그레이션하고 Promise도 잘 이해해서 녹여내고, 구조도 좀 개선하고 … 하고 싶은게 아직 많은 프로젝트다.) Github pino-bot: https://github.com/pineoc/pino-bot 2019년에 추가한 기능은 아래와 같다. (위 사내 저장소에 작업 내용을 위 저장소에 적용하는 것은 올해 상반기에!)자세한 스펙을 너무 늘어놓다 보니 많아졌다. 펼치기하면 볼 수 있다. 접기/펼치기 SVN revision 가져오기 집(?)에서도 SVN 리비전 정보를 보고 싶어서 만들어보았다. 리비전 정보를 보여주고 해당 내용을 빌드마스터가 릴리스 브랜치에 머지할 수 있도록 돕고자 만들었다. 하반기에 SVN → Perforce로 넘어가면서 사용하지 않는 기능이 되었다. Jira 파밍! (Slack message action을 통해 메세지에서 Jira 티켓 정보 쓰레드에 출력하기) SVN revision 기능 처럼 빌드마스터를 돕기 위해 만든 기능 슬랙으로 요청받은 리비전의 커밋 메세지에 있는 Jira 이슈 키를 기반으로 Jira 이슈 정보를 바로 쓰레드로 보여준다. 브라우져으로 Jira에 접속해서 검색하지 않아도 되도록 개선하고 싶었다. Jira 그룹멘션 기능 Jira에 그룹멘션 플러그인이 있긴했지만 생각한대로 잘 동작하지는 않아서 만든 기능 이슈에 있는 그룹 데이터 기반으로 구성원 모두를 멘션하도록 텍스트 변환하는 방식 Jira 멘션 - Slack 알림 기능 jira 댓글에서 멘션될 경우 Slack으로 봇이 메세지를 보내주는 기능 Perforce CL 가져오기 SVN 리비전 정보 가져왔던 것과 같은 기능 커밋에 따라 Jira 상태 변경 커밋 메세지 컨벤션에 따라서 doing, wip / fix, fixed, done 와 같은 메세지가 있으면 Jira 이슈 상태를 변경하는 기능 2019년에는 개발하고 테스트 했음. 2020년 1분기에는 꼭 반영하자! 툴 개발 &amp; 개발 도구 기술 지원슬랙봇 개발과 비슷하게 사람 손으로 했던 일들을 자동화했다. 통번역사분들 도움: 번역 요청 메일 → 자동으로 트렐로 카드 만들기 (MS Flow 사용) L10N 파트 도움: L10N 수동 작업 몇가지 자동화 (리스트 필터링, 파일 정리 등) 빌드마스터 빌드 준비 도움: 빌드에 필요하지 않은 에셋 방지 리스트 제작(Jira 이슈 기반) 개발 도구 기술 지원은 버전관리 시스템과 Jira를 연결해주는 fisheye와 perforce swarm 지원 등 개발에 필요한 도구들을 리서치하고 적용했다. 2020년에는 서비스들도 많이 리서치하고 더 적극적으로 개선해보고 싶다. 팀장님 이직 &amp; 팀원 이직x2하반기 시작할 무렵에는 나에게 큰 이슈가 생겼는데 팀장님이 이직을 하신 것. (다른 동료 2분도 이직을 했지만..) 당시의 상황은 자세하게 설명할 수는 없지만 조직의 상황과 어른들의 사정으로 이직한 것 정도로 마무리를 해야겠다. 팀장님의 이직 후에 나의 업무도 변화가 있었는데 얼마 버티지못하고 뻗어버리긴 했다. 나의 업무는 팀 동료들과 함께 일하고 팀장님이 일하던 것을 그대로 진행하는 것이었는데, 내가 하던 일을 다른 동료분들에게 나눠주었지만 팀장님이 했던 업무에 대한 심적 부담도 있었고 지친 상태여서 잘 해내지 못했던 것 같다. 그 이후에는 팀의 성격도 변화하고 몇가지 변화들이 있어서 빠르게 적응하지 못했던 것도 한몫을 했던 듯 하다. 지금은 팀장님이 돌아와서 그동안 돌보지 못한 일들이나 다른 추가 업무들을 하고 있는 상태이다.(개인적으로 많이 하고 싶었던 개발 환경 개선 업무 등을 하고 있다) 2019 회고를 마치며2019년에는 많은 일들이 있었지만 2018년보다 더 다이나믹했었나? 생각해보면 그렇지는 않았던 것 같다. 물론 좋은일도 힘든일도 있었지만 잘 이겨내려고 노력했던 것 같아 내 자신에게 약간은 칭찬해주고 싶다.(지치지 않고 조금 더 공부하고 단련해서 나아갔으면 좋겠지만 어쩔 수 없었다 정도로 마무리) 이제 PM으로 전직한지 2년쯤 되었는데 PM으로 전직하고 난 뒤에 엔지니어와 PM은 어떤 일을 마땅히 해야했었는지, 각각의 시야에서 정리해보는 것도 좋을 것 같다. 2019년에도 나에게 힘이 되어주고 믿어주었던 모든 분들에게 감사드리며 마무리해본다. 2020년도 목표를 만들고 달려보자. 화이팅!","link":"/blog/2020/07/07/pineoc-2019-Retrospective/"},{"title":"ScriptRunner 소개 1","text":"ScriptRunner 소개 #1 ScriptRunner 소개 1 ScriptRunner 소개 2 ScriptRunner 소개 3 ScriptRunner 소개 4 업무에서 요즘 많이 사용하는 ‘ScriptRunner’ 라는 플러그인을 소개하려 합니다.이 포스트에서 다루는 내용은 JIRA 환경을 기준으로 작성되었습니다.(한국 문서로는 많이 볼 수 없어서 공부 및 소개 겸 포스트 작성합니다.) ScriptRunner란 메인 페이지: https://scriptrunner.adaptavist.com/latest/index.html Adaptavist 라는 회사에서 만든 스크립트 플러그인 Adaptavist inc: https://www.adaptavist.com/ ScriptRunner, Test Management, SmartDraw 등 Atlassian 소프트웨어 플러그인 개발사 JIRA, Confluence, Bitbucket에서 커스텀 스크립트를 사용할 수 있는 플러그인 플러그인 설치 시 기본적으로 스크립트 함수, 필드 지원 스크립트 언어는 Groovy를 사용 ScriptRunner 가이드가이드 문서는 모두 영어로 되어있으며, JIRA Server, JIRA Cloud로 나눠져있습니다.Server 설치 버전과 Cloud 버전이 달라 기능도 약간씩 다르니 그 부분은 참고하여 사용해야합니다. 메인 페이지: https://scriptrunner.adaptavist.com/latest/index.html Server 버전: https://scriptrunner.adaptavist.com/latest/jira/quickstart.html Cloud 버전: http://scriptrunner-docs.connect.adaptavist.com/jiracloud/quickstart.html ScriptRunner 플러그인을 처음 시작한다면 다음 자료들을 보면 좋습니다. 기본 컨셉: https://scriptrunner.adaptavist.com/latest/jira/ tutorialspoint/Groovy: https://www.tutorialspoint.com/groovy/index.htm webinar: https://www.youtube.com/watch?v=ufNACtDxyD8 ScriptRunner 소개 영상: https://www.youtube.com/watch?v=sJa_bFmPoLU Adaptavist에서는 따로 교육과정도 있으니 참고하세요. https://learn.adaptavist.com/course-library/getting-started-with-sr4js 4시간짜리 강좌로 JQL, Built-in Script, Behaviours 등을 배울 수 있습니다. ScriptRunner 강좌는 이 강좌 밖에 없습니다. 전체 강좌: https://learn.adaptavist.com/course-library 가격은 개인 결제시 350$ 이며 러닝 사이트 내에 있는 모든 강좌를 들을 수 있습니다. 결제를 위해 카드 정보까지 다 입력시 계정이 생성되는 것으로 보입니다.(포스팅 시 결제까지 진행하지 않아 모르겠습니다.) ScriptRunner 스크립트 작성ScriptRunner 플러그인으로 스크립트를 작성할 수 있는 곳은 JIRA 기준으로 다음과 같습니다. Administration &gt; Add-ons &gt; Behaviours Administration &gt; Add-ons &gt; ScriptRunner Script Console Built-in Scripts Script Listeners Script Fields REST Endpoints Script Fragments Escalation Services Script JQL Functions 각 메뉴에서 할 수 있는 일을 정리해보겠습니다. Behaviours https://scriptrunner.adaptavist.com/5.5.0/jira/behaviours-overview.html 위의 링크를 참고하면 예제를 따라하면서 어떻게 사용해야할지 알 수 있습니다. 설명은 다음과 같이 나와있습니다. behaviours 기능을 통해 관리자는 하나 이상의 behaviours를 만들 수 있습니다. behaviours는 주어진 프로젝트 또는 이슈에서 이슈에 대한 필드가 동작하는 방식을 정의합니다. 아래는 예시입니다. 예시 이슈 화면에 입력된 다른 데이터(즉, 이슈 생성 또는 이슈 전환 중)에 따라 필드를 필수 항목으로 지정. 사용자 역할 또는 그룹에 따라 필드를 읽기 전용으로 설정 이슈 화면(스크린)이 제출되기 전에 필드 데이터를 서버 측이 검증 수행 다른 이슈 화면(스크린) 데이터에 따라 필드 값 설정 https://scriptrunner.adaptavist.com/5.5.0/jira/behaviours-overview.html#_examples링크에서는 예시로 좋은 설명이 1, 2 항목에 있습니다. 이슈 생성 시 기본 Description(설명) 포맷 값 설정 Resolved 처리 시 Resolution이 Fixed 일 경우, Fix Version 입력을 꼭 할 수 있도록 스크린 설정 Live Editing (실시간 코드 작성) 작성하다보니 내용이 많아졌네요.ScriptRunner 소개 #2 포스트에서 다음 내용들을 다루겠습니다.","link":"/blog/2019/04/21/scriptrunner1/"},{"title":"ScriptRunner 소개 2","text":"ScriptRunner 소개 #2 ScriptRunner 소개 1 ScriptRunner 소개 2 ScriptRunner 소개 3 ScriptRunner 소개 4 지난 글에서는 Behaviours를 보았고 다음 내용인 콘솔, 리스너 등을 보겠습니다. Administration &gt; Add-ons &gt; ScriptRunner Script Console Built-in Scripts Script Listeners Script Fields REST Endpoints Script Fragments Escalation Services Script JQL Functions Script ConsoleScript Console은 실시간으로 스크립트를 작성하고 결과를 볼 수 있는 곳 입니다. 실제로 스크립트를 작성해보고 실행해본 모습입니다. 스크립트를 작성하는 곳 입니다. 자동 완성 기능은 없지만 없는 변수나 없는 함수 등은 오류를 보여줍니다. 스크립트를 작성한 뒤에 Run 버튼으로 실행할 수 있습니다. Result / Logs / Timing 값을 각각 볼 수 있습니다. Result: 스크립트에서 나온 결과물을 볼 수 있습니다. Logs: 스크립트에서 출력한 log들을 볼 수 있습니다. Timing: Elapsed: 208 ms / CPU time: 78 ms 와 같은 내용을 볼 수 있습니다. 아래는 의도적으로 함수명을 다르게 입력하면 볼 수 있는 에러 화면 입니다. 정적 타입 체크 밖에 해주지 못하지만 최소한의 체크는 할 수 있기에스크립트 작성은 할 수 있습니다. Built-in ScriptsScriptRunner 에 이미 설정(구현)되어 있는 스크립트들을 사용할 수 있는 메뉴입니다.아래 참고 문서에서 사용할 수 있는 스크립트 리스트를 볼 수 있습니다.참고 문서: https://scriptrunner.adaptavist.com/latest/jira/builtin-scripts.html 위 화면의 스크립트 중 “Bulk Fix Resolutions” 스크립트를 확인해보겠습니다.이 스크립트는 Filter에 있는 티켓들의 Resolution을 변경할 수 있습니다.참고 링크: Bulk Fix Resolutions JQL을 바로 작성하는 것은 아니며 기존에 만들어둔 Filter를 사용하여 동작하는 스크립트 입니다.그 외에 다른 스크립트의 목록은 아래와 같습니다. Escalation Service Switch User Change dashboard or filter ownership Copy Project Copy Custom Field Values Bulk Import Custom Field Values Split Custom Field Context Script Registry Condition Tester Clear JIRA or Groovy Caches Bulk Copy SLAs List scheduled jobs View server log files ListenersListeners는 JIRA에서 일어나는 이벤트에 따라 스크립트를 동작하게 합니다.프로젝트, 특정 이슈, 특정 이벤트에 따라 동작할 수 있도록 설정할 수 있습니다.참고 문서: https://scriptrunner.adaptavist.com/latest/jira/listeners.html 이미 있는 리스너 타입을 사용해도 되고아예 이벤트를 받는 처음부터 스크립트 마무리까지 관리하는 Custom listener를 사용할 수도 있습니다. 이미 있는 리스너 타입 하나를 한번 보겠습니다.https://scriptrunner.adaptavist.com/5.4.39/jira/builtin-scripts.htmlCreate a sub-task: Create a sub-task, Will Optionally reopen a matching sub-task Create a sub-task Listener를 등록하는 화면의 각각 입력 필드에 대해 알아보겠습니다. Note: Listener 등록시 해당 설명으로 Listener 리스트에서 설명을 볼 수 있습니다. Project(s): 해당 이벤트가 발생하는 프로젝트를 설정합니다. 프로젝트는 자동 완성되어 입력할 수 있습니다. Events: 어떤 이벤트를 받아서 처리할 것인지 이벤트를 설정합니다. All Issue Events, Issue Created, Issue Updated 등의 이벤트를 추가할 수 있습니다. Condition: 해당 이벤트가 발생했을 경우, True / False를 판단할 스크립트를 설정합니다. Show examples를 누르면 예시 코드를 볼 수 있습니다. Priority changed to Major (Listeners only) - Listeners 에서만 동작하는 코드로 priority가 Major로 변경되었을 경우 True를 반환하는 스크립트 입니다. 그 외에 많은 예제 스크립트가 있으니 참고하여 작성하면 됩니다. Target Issue Type: Sub-task 카테고리의 이슈 타입을 설정합니다. Subtask Summary: 생성할 Sub-task 제목(Summary)를 설정합니다. Fields to copy: All / None / Custom 으로 상위 태스크의 필드 값을 복사할 것인지 설정합니다. As User: 어떤 유저로 티켓 생성을 할 것인지 설정합니다. 값이 없을 경우 현재 유저로 설정합니다. Additional issue action: Sub-task 생성 이후 타겟 이슈(부모 이슈)에 대해 추가적인 작업을 하도록 설정합니다. Condition과는 달리 추가적인 작업을 할 수 있도록 하는 스크립트 입력 필드입니다. 제목을 바꾸거나 팝업 메세지를 따로 띄우거나 할 수 있습니다. Show examples를 누르면 예시 코드를 볼 수 있습니다. Subtask Action: 이미 생성된 Subtask가 있을 경우 transition을 진행할 것인지 설정합니다. 주의할 점은 적용하고자하는 프로젝트의 서브 태스크가 어떤 워크플로우를 쓰는가를 확인하여 적용해야 합니다. Create a sub-task 외에 다른 listener 타입이 있으며 아예 커스텀한 listener도 만들 수 있습니다.Custom listener의 경우 다음과 같이 만들 수 있습니다. 이 listener는 앞서 설명드린 create a sub-task 와 프로젝트, 이벤트 필드 설정하는 것은 같지만이벤트를 받고 처리하는 방식이 다릅니다. 발생한 이벤트에서 각종 데이터를 받아 처리해야하는 listener 타입 입니다.listener에 필요한 listener 타입이 없다면 커스텀하게 만들어서 사용하면 됩니다. // Listener 중 Remote Custom listener는 JIRA에 등록되어있는 application에도 scriptRunner를 설치해야 사용할 수 있습니다. Script FieldsScript fields는 아래와 같이 설명이 나와있습니다. A script field is a custom field that allows you to automatically display a value according to the results of a ScriptRunner script. 요약하자면, “스크립트러너의 스크립트 결과를 보여주는 Custom field“ 입니다.참고 문서: https://scriptrunner.adaptavist.com/latest/jira/scripted-fields.html 다음 글에서는 남은 기능을 소개해보겠습니다. REST Endpoints Script Fragments Escalation Services Script JQL Functions","link":"/blog/2019/04/21/scriptrunner2/"},{"title":"ScriptRunner 소개 3","text":"ScriptRunner 소개 #3 ScriptRunner 소개 1 ScriptRunner 소개 2 ScriptRunner 소개 3 ScriptRunner 소개 4 지난 #2 소개 글에서는 Script Fields 기능까지 보았고그 다음에 있는 아래 리스트의 기능들을 보겠습니다. REST Endpoints Script Fragments Escalation Services Script JQL Functions 소개 글을 쓰는 도중에 JIRA 시스템 버전이 7에서 8로 올라가는 과정에서 UI, 기능이 약간 변경되었습니다.버전 변경에 따라 큰 차이는 없겠지만 참고해주세요. :) JIRA version: 7.13 -&gt; 8.0 ScriptRunner: 5.5.2 -&gt; 5.5.3 REST Endpointshttps://scriptrunner.adaptavist.com/latest/jira/rest-endpoints.htmlScriptRunner 공식 문서를 보면 아래와 같은 용도로 사용할 수 있다고 합니다. use in dashboard gadgets 대시보드 가젯으로 사용 receive notifications from external systems 외부 시스템으로부터 알림 받기 plug gaps in the official REST API 공식 REST API 갭을 보완(매꾸기) allow all your XHRs to proxy through to other systems 모든 XHR이 다른 시스템으로 프록시되도록 허용 Create Rest Endpoint 버튼을 통해 만들 수 있습니다. 위 화면처럼 inline script 입력 창에 코드를 입력하여 REST API를 구현합니다.공식 문서와 Show examples에서는 Simple 'get' 코드를 보여줍니다. 1234567891011121314import com.onresolve.scriptrunner.runner.rest.common.CustomEndpointDelegateimport groovy.json.JsonBuilderimport groovy.transform.BaseScriptimport javax.ws.rs.core.MultivaluedMapimport javax.ws.rs.core.Response@BaseScript CustomEndpointDelegate delegate // 1doSomething( // 2 httpMethod: &quot;GET&quot;, groups: [&quot;jira-administrators&quot;]) { // 3 MultivaluedMap queryParams, String body -&gt; // 4 return Response.ok(new JsonBuilder([abc: 42]).toString()).build(); // 5} 코드의 설명 내용은 공식 문서에 나와있으나 짧게 설명해보겠습니다. (영어로 되어있어 한국어로 설명할 겸..!) 이 줄이 코드는 스크립트가 엔드포인트로 사용할 수 있도록 하는 코드입니다. 엔드포인트를 사용하고자 한다면 꼭 필요한 코드입니다. REST 엔드포인트의 이름입니다. URL에서 사용할 이름으로 이 코드에서는 doSomething으로 사용될 것입니다. 엔드포인트의 설정으로 HTTP GET, 권한 그룹은 jira-administrators 그룹이 사용할 수 있는 엔드포인트가 됩니다. 메서드 바디에 제공될 파라미터 입니다. 작성된 값은 메서드 바디에 포함되어 javax.ws.rs.core.Response 객체를 반환할 것 입니다. 이렇게 추가하게되면 아래의 링크에 접근하여 데이터를 받을 수 있습니다.&lt;jira_base_url&gt;/rest/scriptrunner/latest/custom/doSomethingcurl로 테스트해보면 아래와 같이 결과 값이 나올 수 있겠습니다.(admin:admin는 username:password 값을 입력하면 됩니다.) 12&gt; curl -u admin:admin http://localhost:8080/jira/rest/scriptrunner/latest/custom/doSomething&gt; {&quot;abc&quot;:42} 예시예시: ScriptRunner REST Endpoints Examples Create Priority Object Get the user making the request 문서에 코드도 같이 포함되어 있으니 링크 참고하셔서 설정하면 되겠습니다.특정 URL로 요청해서 시스템 설정을 하거나 데이터를 가져오거나 할 수 있는 기능으로REST Endpoints 소래를 마무리할 수 있겠습니다. Script Fragmentshttps://scriptrunner.adaptavist.com/latest/jira/CustomisingUI.html설정화면에 있는 설명을 그대로 가져와보겠습니다. Use script fragments to customise the user interface and add new functionality to a Jira instance. Use customisable built-in script fragments to display web items, web panels and web sections or to include JavaScript and CSS resources using web resources. All script fragments can be customised, or use the raw XML module to create a fully custom web fragment. 간단히 설명하자면 필요한 Web items, panels, section을 만들 수 있다는 것입니다.XML 설정이나 다른 리소스가 필요할 수는 있으나 팝업, 패널 등을 사용자가 원하는대로 만들 수 있는 기능입니다. 설정을 할 수 있는 메뉴를 하나하나 알아보겠습니다. Raw xml moduleXmlModuleItem Docsxml 코드를 입력하여 원하는 위치에 메뉴를 보여주거나, 버튼들을 보여줄 수 있습니다.아래 코드로 JIRA 상단 메뉴의 Projects &gt; View all projects &gt; My Projects를 볼 수 있습니다. 12345678&lt;web-item key='link-to-myprojects' name='ScriptRunner generated web item - link-to-myprojects' section='browse_link/project_view_all' weight='50'&gt; &lt;label&gt;My Projects&lt;/label&gt; &lt;link linkId='link-to-myprojects'&gt;&lt;/link&gt; &lt;tooltip&gt;Show only my projects&lt;/tooltip&gt; &lt;icon height=&quot;16&quot; width=&quot;16&quot;&gt; &lt;link&gt;/images/icons/print.gif&lt;/link&gt; &lt;/icon&gt;&lt;/web-item&gt; XML 입력창에 입력만 하면 되긴 하지만 JIRA UI 아이템들이 어떻게 배치되어있는지알고 작성해야하는 것이 어렵긴합니다. section에 system.top.navigation.bar이 있는지, &lt;web-item&gt; 태그가 있는지 알기 쉽지 않지만일단 예제로 따라해보고 다른 web-item, web-section 등의 태그를 알아가야할 것 같습니다. 참고 외부 링크 Jira Server Developer (Web Item): https://developer.atlassian.com/server/jira/platform/web-item/ Jira Server Developer (Web Section): https://developer.atlassian.com/server/jira/platform/web-section/ Install web resourceWeb Resource Docs이 기능은 Javascript, CSS 리소스를 사용할 수 있도록 하는 기능입니다.우선 설정을 하려면 아래와 같이 환경 설정을 해야합니다. (경로는 다를 수 있습니다.) 1JVM_REQUIRED_ARGS='-Dplugin.resource.directories=/app/home/scripts -Dother.properties...' 설정 후, 해당 폴더에 JS, CSS를 넣고 Resouces 입력창에 경로를 넣어줍니다. 커스텀한 리소스를 사용할 수 있다는 점에서는 좋은 것 같지만잘못하면 많이 망가질 수 있다는 생각이 들긴하는 기능입니다. Create a custom web sectionWeb Section Docs웹 섹션(Web section)은 새로운 로케이션 또는 섹션, web-item을 추가할 때 사용할 수 있습니다. web-item에서 web-section을 사용하고자 한다면,web-section 만들 때 사용했던 key 값을 사용해야합니다. Constrained create issue dialogCreate Constrained Issue문서 설명 그대로 가져오자면, Create Constrained Issue -&gt; 제한된 문제 만들기!제한된 설정 안에서 이슈를 만들 수 있도록 설정할 수 있습니다. 문서에 나온 설명에 따르면, This can be useful to workflow designers. Imagine a workflow where at one transition the user is required to create a new linked issue. Typically this is done by having a self or any to any transition which will created the linked issue with a post-function. Then the user is required to edit the linked issue further. Workflow를 디자인, 만들때 유용한 기능입니다.예를 들면 특정 트랜지션에서 이슈를 링크해야한다던지, 특정 값을 입력해야하는 옵션을 추가할 수 있습니다. 문서에서는 Behaviours와 함께 사용해서 구성한 메뉴를 눌렀을 경우,새로운 이슈를 만들때 특정 필드를 읽기전용으로 설정하고 필드 값도 미리 설정할 수 있는 것을 보여줍니다. TODO이 기능은 설정할 내용이 좀 있어서 나중에 포스트로 깊게 다루는게 좋을 것 같습니다. Custom web itemWeb ItemA web-item is a button or link that will appear at your chosen location.웹 아이템은 버튼 또는 링크로 설정한 위치에서 메뉴로 사용할 수 있습니다. 간단한 예시로 JIRA 상단에 네비게이션 바에 Search the Web 링크를 만들어봅니다. issue에서 More Actions 메뉴에도 링크를 만들어봅니다. 결과화면은 아래와 같이 나옵니다. Condition 조건에 따라 웹 아이템이 나오기에 Condition 설정도 필요합니다.프로젝트로 한정하거나 이슈의 특정 값인지 조건을 사용할 수 있습니다. 차근차근 테스트 삼아 저도 웹 아이템 하나 만들어보겠습니다. 1. web-item을 하나 만들어봅니다. Menu text는 버튼에 들어갈 텍스트니 적당히 적어줍니다. Weight 값은 숫자가 작을수록 우선순위가 높습니다. Condition 값은 어떤 조건에 버튼이 나올지 설정할 수 있습니다. Do what에는 저는 dialog를 띄우는 테스트를 할 것이라 Run code and display dialog를 선택했습니다. Link는 REST Endpoint 기능에서 만든 URL을 입력해줍니다. 다음 과정에서 만드는 방법을 보겠습니다. 2. REST Endpoint 추가 1234567891011121314151617181920212223242526272829303132import com.onresolve.scriptrunner.runner.rest.common.CustomEndpointDelegateimport groovy.transform.BaseScriptimport javax.ws.rs.core.MediaTypeimport javax.ws.rs.core.MultivaluedMapimport javax.ws.rs.core.Response@BaseScript CustomEndpointDelegate delegateshowDialog { MultivaluedMap queryParams -&gt; def dialog = &quot;&quot;&quot;&lt;section role=&quot;dialog&quot; id=&quot;sr-dialog&quot; class=&quot;aui-layer aui-dialog2 aui-dialog2-medium&quot; aria-hidden=&quot;true&quot; data-aui-remove-on-hide=&quot;true&quot;&gt; &lt;header class=&quot;aui-dialog2-header&quot;&gt; &lt;h2 class=&quot;aui-dialog2-header-main&quot;&gt;Some dialog&lt;/h2&gt; &lt;a class=&quot;aui-dialog2-header-close&quot;&gt; &lt;span class=&quot;aui-icon aui-icon-small aui-iconfont-close-dialog&quot;&gt;Close&lt;/span&gt; &lt;/a&gt; &lt;/header&gt; &lt;div class=&quot;aui-dialog2-content&quot;&gt; &lt;p&gt;This is a dialog...&lt;/p&gt; &lt;/div&gt; &lt;footer class=&quot;aui-dialog2-footer&quot;&gt; &lt;div class=&quot;aui-dialog2-footer-actions&quot;&gt; &lt;button id=&quot;dialog-close-button&quot; class=&quot;aui-button aui-button-link&quot;&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;aui-dialog2-footer-hint&quot;&gt;Some hint here if you like&lt;/div&gt; &lt;/footer&gt; &lt;/section&gt; &quot;&quot;&quot; Response.ok().type(MediaType.TEXT_HTML).entity(dialog.toString()).build()} 위 코드를 inline script 항목에 넣어줍니다. 함수 이름으로 REST endpoint가 만들어질 것인데 showDialog로 만들어질 예정입니다. 생성! 다시 Web-item 만든 곳으로 돌아가서 아래 주소를 입력해줍니다. /rest/scriptrunner/latest/custom/showDialog 1번 단계에서 이미 이미지를 보고 입력하셨다면 함수 이름에 맞게 입력했는지 확인하면 끝! 3. 결과 Web 버튼을 누르면 2번째 이미지 처럼 다이얼로그가 나옵니다! 다이얼로그에 필요한 정보는 차차 넣을 수 있도록하면 되겠습니다. 문서에서는 web resource 까지 가서 close 버튼에 뭔가 더 해보라고 하지만 여기까지 하겠습니다. :) Custom web item providerWeb Item Provider Built-In Script문서 상에 예로 사용할 수 있는 것으로 설명을 시작하는게 좋을 것 같습니다.Examples of a web item provider might be: 현재 사용자가 가지고 있는 이슈 중, 액티브 스프린트에 있는 상위 5개의 이슈를 보여줍니다. Show the top 5 issues for the current user in active sprints in the Issues top-level menu 현재 이슈의 서브태스크 각각에 대한 web item을 More Actions 메뉴에서 보여줍니다. Show a web item in the More Actions menu for each of the current issue’s subtasks 예시: My Top Issueshttps://scriptrunner.adaptavist.com/5.5.3.1-jira8/jira/fragments/WebItemProvider.html#_example_my_top_issues JIRA 상단의 네비게이션 바 메뉴에서 issues를 눌렀을 때,MY TOP ISSUES 섹션에 스프린트에 있는 자신에게 할당된 이슈 상위 5개가 보입니다.예시 링크에 있는대로 진행하시면 원하는 결과를 보실 수 있을 겁니다. (스프린트를 사용한다는 가정하에 말이죠) Show a web panelWeb Panel커스텀 웹 패널을 만들고 그 영역에 정보를 담을 수 있도록 설정할 수 있습니다. Location : 설정 코멘트 Key: UI상 ID가 필요하여 사용하는 것으로 보입니다. Menu text: 보이는 메뉴의 타이틀 문구로 사용됩니다. Weight: UI 우선순의 값으로, 양수로 설정할 수 있으며 입력하지 않아도 됩니다. Condition: 해당 패널이 보이는 조건을 설정할 수 있습니다. Provider class/script: 패널에 들어갈 데이터를 넣어주는 코드를 작성할 수 있습니다. 123writer.write(&quot;&lt;div style='background-color: yellow; text-align: center'&gt;&quot; + &quot;This project is going to be deprecrated. Please create&quot; + &quot; all issues in the WIDGET project&lt;/div&gt;&quot;); 위 이미지 상에서 설정한대로 설정할 경우 이슈 오른쪽 패널에는 아래처럼 보여집니다. 부모 이슈의 설명(Description) 값을 가져와서 서브태스크에 보여주는 방법도 있습니다.WebPanel.html#_parent_issue_example 잘 사용하면 필요한 정보를 적재적소에 보여줄 수 있을 것 같지만,잘못 사용하면 난잡해질 수 있겠다는 생각이 드네요. 위의 예시를 살펴보고 세팅해보면 좋을 것 같습니다.패널 뿐만 아니라 JIRA 이곳 저곳에 정보를 넣을 수 있으니 잘 사용하면 좋을 것 같습니다. :) Hide system or plugin UI elementHide UI Element Build-In ScriptJIRA에서 특정 프로젝트나 특정 이슈에서 UI 요소를 숨길 수 있는 기능입니다.예시로는 아래와 같은 것을 할 수 있습니다. Move, Clone 기능을 특정 프로젝트에서 이슈 Operation 목록에서 보이지 않게 함 source control이 필요없는 프로젝트에서 Development panel을 보이지 않게 함 설정을 위해 입력해야하는 값은 많지 않습니다. Note: script note, 이 설정의 설명을 적는 곳입니다. Hide what: 어떤 요소를 숨길지 설정합니다. 설정할 수 있는 요소는 web items 들로 리스트는 굉장히 많습니다. com.atlassian.jira.plugin.system.issueoperations:* - 이슈 관련 UI 요소 com.pyxis.greenhopper.jira:board-* - board 관련 UI 요소 Condition: 어떤 조건에서 UI를 숨길 것인지 조건을 설정합니다. 프로젝트, 이슈 등을 조건으로 설정할 수 있습니다. 이 설정을 사용하기전에 다른 프로젝트에 영향이 있을지 주의가 필요할 것 같습니다.잘못하면 다른 구성원에게 필요한 기능이 보이지 않게될 수 있을테니까요. Planning board context menu itemBoard Context Menu ItemWeb Item 기능 중에 하나라고 볼 수 있습니다.스크럼, 칸반 보드에서 오른쪽 버튼을 눌렀을 때 나오는 드롭다운에 메뉴를 추가할 수 있는 기능입니다. `Ready for release` 메뉴를 추가한 모습 가이드 문서에는 메뉴를 누르면 간단한 동작을 하는 것을 보여줍니다. 스크럼 보드에서 액티브 스프린트에 있는 이슈를 Ready for release 메뉴를 누르면, REST endpoint로 등록한 /rest/scriptrunner/latest/custom/ghAddLabel 로 이슈 정보를 보낸다. REST endpoint 등록된 함수에서 이슈의 label 필드에 “red” 입력한다. flag으로 오른쪽 위에 노티를 보여준다. 12345678// ...def flag = [ type: 'success', title: &quot;Label Added&quot;, close: 'auto', body : &quot;This issue has been approved for release&quot;]Response.ok(JsonOutput.toJson(flag)).build() Condition은 복수의 이슈를 받을 수 있기에 List 객체를 받을 수 있게 되어있습니다.예시 코드는 아래와 같이 볼 수 있습니다. 123456// All selected issues are resolvedissues.every { it.resolution }// Selected issues in same projectissues*.projectObject.unique().size() == 1// Only a single issue is selectedissues.size() == 1 Do what에는 사용할 수 있는 동작이 많습니다.link로 데이터를 보내서 추가 동작을 설정하거나, 수정, 할당 등을 할 수 있습니다. 마무리REST Endpoints, Script Fragment 내용이 많다보니 또 포스트 내용이 넘쳤네요.다음 #4 소개 포스트에서 남은 Escalation Services, Script JQL Functions 에 대해 소개해보겠습니다.","link":"/blog/2019/04/27/scriptrunner3/"},{"title":"ScriptRunner 소개 4","text":"ScriptRunner 소개 #4 ScriptRunner 소개 1 ScriptRunner 소개 2 ScriptRunner 소개 3 ScriptRunner 소개 4 지난 #3 소개 글에서는 Script Fragments 기능까지 보았습니다.얼마 남지 않았지만 너무 길어져서 #4로 나눴습니다. Escalation Services Script JQL Functions 길고 길었던 ScriptRunner 소개를 마무리하러 가보겠습니다! :) Escalation Serviceshttps://scriptrunner.adaptavist.com/latest/jira/escalation-service.html설명은 아래와 같이 나와있는데 요약해보겠습니다. Automate issue escalation with escalation services. Use a JQL query to define processes for modifying issues based on elapsed time. Specify actions (such as transitions) to occur at defined intervals after a specified time has passed. 에스컬레이션 서비스를 통해 문제 에스컬레이션 자동화 JQL 쿼리를 사용하여 경과된 시간을 기준으로 문제를 수정하는 프로세스를 정의하십시오. 지정된 시간이 경과한 후 정의된 간격으로 발생할 작업(예: 전환)을 지정하십시오. - with Papago JQL로 검색한 쿼리들을 일정 시간마다 특정 값을 설정하거나 transition(전환) 할 수 있는 기능입니다.예를 들면, 2주 동안 변경이 없는 이슈들의 상태를 변경할 수 있겠죠. (혹은 특정 필드를 수정하거나) 입력해야하는 항목은 아래와 같이 많지 않습니다. Description: 설정에 대한 설명을 적습니다. JQL Query: 변경하고자하는 이슈를 가져오기 위해 JQL을 작성합니다. AS User: 어떤 유저로 변경할 것인지 설정합니다. Interval/CRON Expression: 얼마나 자주 실행할 것인지 설정합니다. 기본적으로 분 단위로 설정할 수 있습니다. CRON Expression에 대한 것은 링크에서 참고하여 작성해볼 수 있습니다. Action: Transition을 설정할 수 있습니다. 반드시 설정해야하는 항목은 아닙니다. Additional issue actions: 댓글을 달거나 Resolution을 설정할 수 있습니다. groovy 코드로 작성해야합니다. Show examples를 보고 작성해보는 것을 추천합니다. Transition Options: Permissions, Validators, Conditions 확인하는 것을 건너뛸 것인지 설정합니다. 수시로 확인해서 상태를 업데이트하거나 이슈의 항목을 수정해야하는 일이 있다면 사용하기 좋을 것 같습니다.다만 As User로 설정한 유저의 권한을 잘 확인하여 transition할 수 있는 권한이 있는지 확인해주세요.(방금 테스트해보았는데 권한없는 동작을 하려할 경우 아예 변경이 진행되지 않습니다.) Script JQL Functionshttps://scriptrunner.adaptavist.com/latest/jira/jql-functions.html이 항목은 커스텀한 JQL 함수를 추가할 수 있다기 보다 현재 사용할 수 있는 JQL Function들을 보여줍니다. 커스텀한 함수를 추가할 수는 있지만 JIRA 페이지에서 바로 추가할 수 있지는 않습니다.https://scriptrunner.adaptavist.com/latest/jira/custom-jql-functions.html 쭉 내려보면 많은 함수들을 볼 수 있습니다.함수에 대한 더 자세한 내용을 보려면 위에 있는 jql-functions 링크를 참고하세요. ScriptRunner 소개 마무리4개의 포스트로 소개 문서를 마무리하고자 합니다.많은 내용들을 찾아보고 테스트 삼아 만들어보느라 시간이 오래걸리기도 했네요.설정하면서 많이 배웠고 실제 프로젝트에서도 적용해볼만한 내용들이 많았습니다.다른 JIRA를 사용하는 분들께도 필요한 내용이 있으면 다른 포스트에서 짧게 사용할만한 것들남겨두겠습니다. :) 긴 글 읽어주셔서 감사합니다. (_ _)","link":"/blog/2019/05/11/scriptrunner4/"},{"title":"Unreal Lighting 공부 - Coloso &#39;언리얼로 구현하는 게임 라이팅 입문&#39;","text":"Coloso “언리얼로 구현하는 게임 라이팅 입문” 공부21년 마지막날에 갑자기 22년에는 뭔가 공부해야겠다 싶어서 이것저것 보다가그동안 관심이 있던 아트 쪽을 공부해볼까 싶어 Coloso 강의를 질러보았습니다사실 환급 과정이라고 해서 더 강의를 도전해봐야겠다 싶기도했네요 Coloso: 언리얼로 구현하는 게임 라이팅 입문 Coloso와 Class101의 차이는 보니까 강의를 구매하고나면 평생 시청할 수 있다는 점이었는데지금은 다 수강하고 보니 다시 볼 일이 있을까 싶기도합니다 강의 내용이 부족해서라기보다 입문 강의다보니 숙련되면 따로 더 챙겨볼 일이 없겠다는 생각이 들었어요 Coloso 환급 과정 진행환급 과정은 블로그 포스트를 1달동안 매일 작성하는 방식으로 진행했습니다(지금 글쓰고 있는 시점에도 21일차를 완료했네요.) 현재 쓰고 있는 블로그 포스트들: https://blog.naver.com/pineoc이번에 이 글을 쓰면서 알게된 것은 네이버 블로그는 태그 내용으로 정리된 리스트 링크를 볼 수 없네요 재미로 저랑 같이 공부하는 사람들은 얼마나 있는지 한번 알아보았습니다블로그 검색: 언리얼로 구현하는 게임 라이팅 입문이렇게 검색하면 저랑 같이 하시는 분은 한 4분 정도 있네요. 😁 강의 수가 얼마되지 않아서 다들 강의 듣고 원하는 씬을 작업하면서 인증하고 계신 것 같았어요저는 개인 프로젝트를 진행하면서 인증하고 있습니다 💪💪💪 강의 내용강의 내용은 처음 언리얼 엔진을 처음 다뤄보는 사람들, 라이팅 입문하는 사람들을 위한 내용입니다내용 자체는 기본적인 내용으로 강의가 진행되었고 게임 개발과 관련한 내용을 아트 관점에서 정리할 수 있어서 좋았습니다 다만 라이팅과 관련한 내용에 대해 입문으로 시작해볼 수 있지만숙련 과정까지 끌어올려주는 강의로는 부족하다는 생각이 들었습니다 강의 내용 퀄리티가 부족하기보다 강의 횟수, 강의 내용의 절대적인 양이 부족하다고 느꼈고입문 후에 라이팅에 더 관심을 가지고 달려갈 사람들에게는 적당한 수준의 내용이지 않을까 싶었습니다 개인 프로젝트 진행 환급 과정 인증을 위한 개인 프로젝트는 “우리집 꾸미기”해보고 있습니다다이나믹 라이팅, 스태틱 라이팅 등을 공부하면서 느낀 것은아트 작업에 대한 공부는 역시 모델링이나 실제 어떤 것을 만들고 싶은지 고민이 있어야한다는 것이었네요사실 엔지니어링 관점에서도 뭘 개발하고 싶은지 고민하긴해야하니까요 😊 첫 프로젝트는 집 모델링 프로젝트이고 다음 프로젝트는 회사 사무실 모델링이 목표입니다집보다 회사 평수가 20배 이상 크니까… 더 오래걸리겠죠일단 집 프로젝트를 마무리하고 올해 상반기에 회사 사무실 프로젝트를 진행해보려합니다 이러면 사실 라이팅 프로젝트가 아니라 모델링 프로젝트가 아닐까 싶은… 마무리환급 과정을 하게되어서 환급 과정에 더 많이 집중된 것 같지만 😅강의 + 환급 과정은 마무리 단계(데일리미션 마지막주 + 최종미션)라서 프로젝트 마무리에 집중하고 있습니다.강의를 보고 배운 것들을 정리해보면.. 게임 개발, 영상 작업의 아트 영역에서 라이팅은 무엇을 고민하는지 아트 영역에서는 라이팅 효과로 어떤 것들을 주로 작업하는지 라이팅 작업에서 필요한 기본 개념들 개인 프로젝트 결과는 완성되면 여기에도 올려보겠습니다. 😁","link":"/blog/2022/01/23/study-unreal-lighting/"},{"title":"이슈 트래커(Issue Tracker Jira)에 잘 접근하는 방법 고민 #1","text":"방법 연구 목적Jira에 접근해서 자신이 해야하는 일이 무엇인지 확인하기 어려워하는 분들이나 더 편하게 접근할 수 있는 방법이 있을까 하는 생각이 들었습니다. (갑자기?)궁극적인 목적은 작업자들이 자신이 해야하는 일을 잘, 빠르고 편리하게 확인하고 일할 수 있는 것이죠.나에게 할당된 일을 바로 알 수 있는 방법이 있다면 제일 좋을 것 같아 각 작업자의 작업 흐름, 작업 프로그램 등을 확인해봅니다. (TMI) 이 글을 정리하게된 계기https://youtu.be/xlV82Q-ZmAA 2021년에 OKKYCON에서 김영재님이 발표해주셨던 프로덕트 조직의 생산성 높이기 내용에 감명을 받아서 정리하게되었습니다.(작년에 본 영상인데 왜 이제야? 라는 생각도 들지만 최근에 동료분들이 내가 어떤 일을 해야하는지에 대해 편하게 접근할 수 있다면 Jira와 친해지고 더 잘 쓸 수 있게되지 않을까했습니다. 😁) 영상에서는 “개발자가 이슈 트래커를 잘 쓴다는 기준”에 대해 다뤄주셨는데요. 이슈 트래커 웹에서 적게 열어볼 수록 잘쓰는 것 절대 상태를 손으로 바꾸지 않는 것 → (핵심) 커밋 메세지로 상태 변화가 가능한 것 작업게임 개발(PUBG 기준)에 있어서 작업자 카테고리 및 작업 프로그램을 분류해보겠습니다.일단 PUBG 개발은 Unreal Engine Editor, Perforce/Git 으로 작업하고 소스를 관리하고 있습니다. 엔지니어 Engineer(코딩 + 블루프린트 작업) Visual Studio (Visual Studio Code), Unreal Engine Editor 코딩 후 Git 히스토리 정리를 위해 SourceTree, Fork, GitKraken 등 Git GUI를 사용하는 경우도 있음 PUBG는 소스 컨트롤 시스템을 Perforce와 Gitlab(Git)을 쓰고 있음 아티스트 Artist(애셋 작업) Maya, 3D Max …, Unreal Engine Editor 컨셉 아티스트…의 경우 어도비 포토샵 또는 일러스트레이터? 어쨌든 실제 게임에 적용되는 애셋들은 언리얼 에디터 통해서 반영되어야하니 커밋 내용을 작성하고 푸시하는 곳은 언리얼 에디터? Perforce? (어디가 편할지는 인터뷰와 고민이 필요합니다.) 기획자 Designer(데이터 작업 + 블루프린트 작업 등) Excel, Unreal Engine Editor 데이터 작업을 엑셀로만 하지는 않고 언리얼 에디터에서 그래프를 수정하는 등 여러 작업이 있음 블루프린트에 입력해야하는 데이터, 코드에서 가져다 쓰는 데이터 등 에디터와 에디터 밖에서 작업 가능함 작업 프로그램과 Jira 연결각 작업자분들이 작업을 하는 프로그램에서 Jira 이슈를 볼 수 있는 방법이 있는지부터 확인을 해봐야겠죠?작업 프로그램 하나하나 관련 플러그인이 있는지 확인해보겠습니다. 작업 프로그램 Jira 연결 프로그램 특징/코멘트 Visual Studio VSJira ⚠️ VSJira- VS 2019에서 동작하지 않는다는 평가가 많네요. (동작하는지 확인 필요) Visual Studio CodeStream-vs ✅ CodeStream-vs- New Relic에서 만든 플러그인으로 VS 2019 버전에서 동작 가능하고 지금도 유지보수가 이뤄지고 있는 플러그인- 내 이슈를 확인하고 이슈를 바로 만들 수도 있습니다.- Jira 외에도 다른 서비스 연결이 강력하네요. (슬랙, 팀즈, 트렐로 등) Visual Studio Code Jira and Bitbucket ✅ Jira and Bitbucket- 아틀라시안에서 만든 플러그인으로 유지보수 및 여러가지 Jira 기능이 보장되어있습니다.- 플러그인의 형태로 VS Code에 설치 후 서버 설정 및 계정 설정- VS Code에서 바로 이슈 내용을 바로 볼 수 있습니다- VS Code 내에서 필터를 구성해서 내가 보려는 이슈만 골라서 볼 수도 있고요 Unreal Engine Editor ❌ Bug-reporter❌ Bug tracker ❓ 언리얼 엔진 플러그인으로 있는 것을 찾기 어렵네요- ❌ Bug-reporter 플러그인은 있는데 $30로 비용이… - ❌ Bug Tracker 플러그인은 ₩73590… 꽤 비싸네요. 다만 Trello만 지원해서 패스.없어서 플러그인 만들어서 써야하는 것 같습니다. (다른 회사들도 그냥 만들어쓰는걸까요..?) Perforce(P4V) ❌ / ⚠️ jira-perforce 연결 ❌ - P4V에서 바로 Jira 연결하는 플러그인은 따로 없고 커스텀 툴을 개발해서 넣어야합니다.- HTML Tool 또는 Custom Tool을 따로 만들어서 적용해야합니다.- 다른 서비스들에 연결은 할 수 있는데 추가로 구매하고 설정해야하는게 큰일이네요. 고민 1차 정리일단 각 작업 프로그램별로 Jira 연결 프로그램을 확인해보았는데요.Visual Studio쪽은 있는데 언리얼 에디터, 퍼포스 쪽은 제대로된 플러그인을 확인할 수 없었네요. 공교롭게도 게임 개발 관련 프로그램에는 Jira 연결 플러그인을 찾기 어려웠… (게임 개발과 이슈 트래커 툴은 친하지 않은 관계일까 싶기도했지만 아니겠죠..?)물론 언리얼 에디터 쪽에 관련 플러그인이 있지만 Jira를 딱 잘 쓸 수 있게 만들어진 것은 아니어서 애매하다고 생각했습니다. 내부 동료 개발자분들은 어떻게 Jira를 사용하고 있는지, 어떤 방법으로 커밋(submit)할때 jira 이슈를 찾아서 보고 있는지 인터뷰해보고 개선 각을 봐야겠습니다.개선 방식은 #2 포스트로 찾아올게요 😃","link":"/blog/2022/05/21/think-issuetracker/"},{"title":"게임 개발에 대한 고찰 1","text":"게임 개발이란 뭘까?게임 개발 PM으로 일을 하면서 게임 개발은 뭘까하는 고민을 종종합니다.다른 IT 서비스 종류와 다른 업과도 비교해서 생각하기도 하는데요. 제가 생각하는 다른 서비스들의 개발할 때의 예상되는 고민은… 보통 앱 개발이나 웹 서비스 개발은 어떤 특징을 가지고 있지? 문제를 정의하고 문제에 대해 서비스로 어떻게 해결할 것인지 접근하지 않을까? 문제를 해결하지만 최종적으로는 사용자에 집중하여 해결에 접근하지 않을까? 이커머스(e-commerce)는 어떤 특징을 가지고 있지? 구매자, 판매자를 잘 연결해줘야겠지 구매자 경험, 판매자 경험도 중요하다. 두 종류의 사용자가 겪는 문제도 해결해야겠지 요즘은 물류, 배송에 대한 고민도 더 많아지지 않았을까 잠깐잠깐 생각했던 내용을 정리해본 내용이어서 정확하지 않거나 막연한 내용일 수 있습니다. :) 이런 서비스들과 비교했을 때 게임의 핵심 고민은 어떤 재미를 줄 수 있을까인 것 같습니다. 내가(우리가) 좋아하는 게임 장르를 개발한다! MMORPG를 만든다! 협동 콘텐츠! 스토리! 나는 정통 FPS! 많은 사람들이 좋아하는 게임 콘텐츠를 개발한다! 요즘 뜨는 게임 장르는 배틀로얄이니 이거랑 성장 요소를 끼워볼까? 게임 개발은 어떤 문제를 해결한다, 페인 포인트(Pain Point)를 해결한다 보다재미있는 콘텐츠를 만드는 것이 중요하다고 생각합니다.다만 그런 재미는 콘텐츠의 완성도 뿐만 아니라 사용자들의 게임플레이 성향, 취향 등에 따라 달라질 수 있다고 생각해요. 이런 고민을 하다가 얼핏 생각해보니 게임에서의 **”재미”**는 요식업이랑 **”맛”**이랑 비슷한 느낌이 있었습니다.그러다가 한번 비슷한 요소들을 묶어서 그려보자는 생각이 들어서 아래와 같은 그래프를 그려보게되었어요.(영화는 게임과 콘텐츠 산업 구조가 비슷하지 않을까해서 같이 넣어보았습니다.) 생각1: 게임, 음식점(요식업)과 영화랑 비교해볼까? 게임, 음식점, 영화 각각 비슷한 특징은 각 열(row)에 배치해보았습니다.게임에서 버그가 발생하는 거랑 음식점에서 벌레(위생)가 나오는 것은 둘 다 치명적인 문제로 같은 층에 배치해보았습니다. 😸(나름 재미있다고 생각한 포인트인데 쓰고 보니 별로 재미없네요 🐛 재미없으면 버그야…) 제가 생각하는 각 카테고리의 핵심은 음식점은 맛, 게임&amp;영화는 재미로 정리해볼 수 있었습니다.음식점을 맛이 아닌 다른 이유(사장님과의 친분, 가게 인테리어)로 갈 수 있지만사람들이 자주 찾아오고, 단골이 생기고 다른 사람들에게도 추천할 수 있으려면 음식점은 음식의 맛이 중요하다고 보았습니다. 게임도 마찬가지로 다른 요소가 뛰어나더라도 재미가 없다면 지속될 수 없다고 생각합니다.다른 요소들이 뒷받침해서 게임의 재미가 돋보일 수 있도록 도울 수는 있겠지만 핵심은 재미가 있어야죠. 여기서 영화는 게임, 음식점과 조금 다른 카테고리인 것 같아 점선으로 분리해두었습니다.영화는 게임에서의 알파 테스트나 음식점에서의 신메뉴 테스트 등을 못하지 않을까? 하는 생각과실제 사용자에게 가기 전까지의 비용이 많이 든다는 점이 다른 것 같았습니다. 지금 추가로 찾아보니까 영화 시사회 중 기술 시사회가 어느정도 알파 테스트까지는 아니더라도 베타 테스트까지는 역할을 하는 이벤트가 아닐까 싶네요.다만 기술 시사회도 이미 어느정도 완성된 영상을 보여주는 것이라 얼리엑세스 같은 느낌에 더 가깝겠네요.영화 프로덕션에 대한 내용은 아래 링크에서 더 보실 수 있습니다. https://www.kmdb.or.kr/story/152/3301 https://m.blog.naver.com/yangbsun/222073262933 물론 게임도 실 사용자에게 가기 전까지 많은 비용이 들긴 합니다만..게임은 영화에 비해 사용자 피드백을 받고 지속적으로 개선할 수 있는 형태이지 않을까 싶었습니다.(예전에는 패키지 게임/CD 게임은 판매 후 패치하기 어려운 시기가 있었지만 지금은 아니니까요. 😸) 음식점도 임대하고 가게를 임대하는 데에 있어서 비용이 적지 않게 들어가지만음식점을 오픈하고 메뉴를 바꿀 수도 있는 것이고 손님 피드백을 받아서 개선해나갈 수 있다고 보았습니다.요즘은 공유 오피스처럼 주방도 공유 주방이 생기고 있는 시대라 초기 비용에 대한 부담도 줄일 수 있는 시대이기도 하니까요. 생각2: 게임은 흥행 산업일까?사실 게임이 흥행 산업이라는 이야기를 많이 들어서 영화와 슬쩍 비교해본 것이긴 합니다.(흥행이라는 말 자체가 “대중을 상대로 하여 연극·영화·서커스·쇼 등의 볼거리를 영리 목적의 사업으로서 공연하거나 상영하는 일.”이라 어원은 영화에서 비롯되었다고 볼 수 있겠네요.) 재미라는 것 자체가 “이거 재미있다더라”, “같이 보자(하자)” 등이 연결되어서 흥행이 될 수도 있고유명한 크리에이터, 스트리머들이 좋은 리뷰를 하더라도 흥행이 부스트 될 수 있는 것 같습니다.(장기적인 흥행 부스트가 될지는 스트리머의 인지도 및 관계, 협력에 따라 달라질 수 있겠죠) 계속 흥행을 유지하려면, 게임을 즐기는 다양한 유저들이 지속적으로 재미를 느낄 수 있도록 핵심 재미와 다양한 맛을 골고루 줘야 한다고 생각합니다.마블(Marvel) 처럼 마블 시네마틱 유니버스를 통해 다양한 캐릭터에 대한 서사와 세계관을 보여주는 것처럼 팬들이 꾸준히 찾고 즐길 수 있는 콘텐츠를 만들어가야 하지 않을까 싶습니다. 음식점의 경우에는 다양한 손님을 만족시키기 위해 신메뉴를 개발해야겠지만 기존의 맛을 찾는 손님들도 더 맛있게 먹을 수 있는 방법을 고민해야하는 측면에서 약간 결이 다른 것 같기도하네요. 결국 어떤 곳이든 흥행을 하더라도 지속하려면 팬(Fan)이 남아서 또는 팬을 남겨서 핵심 요쇼를 계속 즐길 수 있도록 해야겠죠. 생각 마무리엔지니어로 소프트웨어(앱, 웹서비스)를 개발하다가 처음 게임 개발에 개발 PM으로 와서 처음으로 게임 개발과 관련한 글을 써보는 것 같네요. 사실 게임 개발을 하고 계신 분들 중 은둔 고수 시니어분들이 많아서 이런 생각을 정리해서 글을 써본다는 것 자체가 뭐랄까 코끼리의 코만 만져보고 “코끼리는 뱀 같은 동물이다”는 사람이 될까 싶기도 합니다. 😇 그래도 나름 이런 생각을 하면서 우린 어떤 업계에서 살고 있을까 하는 고민도 해볼 수 있어서 재미있었습니다.다음 고민, 공부로는 “게임 개발 알파, 베타 테스트는 뭘까”를 정리해볼까 합니다. 😏 제 생각에 정정이 필요한 내용이나 첨언이 필요한 내용이 있다면 편하게 댓글로 남겨주세요!읽어주셔서 감사합니다. 😸","link":"/blog/2021/08/30/think-game-dev1/"},{"title":"Unreal Engine 크래시 분석 서비스 조사","text":"조사 목적 언리얼 엔진으로 게임을 만들 때에 사용하는 크래시 분석 서비스는 무엇이 있는지 알아봅니다. 단순히 크래시 덤프를 수집하는 것에 그치지 않고 어떤 크래시가 많이 발생하고 있는지 트렌드나 특이점을 확인할 수 있는 서비스들이 있는지 찾아봅니다. 언리얼 크래시 리포터(Unreal Crash Reporter) 언리얼 엔진 크래시 분석 서비스알아본 크래시 분석 서비스 Sentry: https://sentry.io/welcome/ BugSplat: https://www.bugsplat.com/ Backtrace: https://backtrace.io/ Raygun: https://raygun.com/ Countly: https://countly.com/ Sentry 👍 https://sentry.io/welcome/https://docs.sentry.io/platforms/unreal/ 센트리(Sentry)는 웹 서비스, 앱 서비스에서도 많이 쓰는 이슈 관리 솔루션으로 알고 있습니다.언리얼에서 사용하고자 할 경우에는 minidump를 직접 올리거나 크래시 리포터에 연결, 크래시 덤프를 올리는 방식인 것 같습니다.가이드 문서를 보면 제한 사항이 있네요. 20MB for a compressed request → 크래시 덤프 업로드시 압축된 데이터가 20MB 이하여야 하고 100MB for the full crash report after decompression → 크래시 덤프 압축을 해제하면 100MB 이하여야 함 이런 제한을 참고해서 센트리를 도입해서 유의미하게 쓸 수 있는지 검토해야겠네요.(덤프에 많은 정보를 남길 경우 센트리를 쓰지 못한다는 이야기… 😂) 플러그인이 있어서 설정은 쉬웠네요.센트리 설정 경험기: Sentry - Uneal Engine 4.27 integration BugSplat 👍 https://www.bugsplat.com/https://docs.bugsplat.com/introduction/getting-started/integrations/game-development/unreal-engine 요 서비스는 언리얼 플러그인까지 있는 서비스여서 설정은 편할 것 같습니다. 센트리는 제한이 있었는데 BugSplat에도 제한 사항이… 있군요.센트리랑 비슷하게 압축된 덤프의 사이즈가 20MB 여야합니다. 😂 (참고 링크) 에디터에서 프로젝트 설정에 “크래시 리포터 포함” &amp; “디버그 파일 포함” 설정해주기 DefaultEngine.ini 에 크래시를 보낼 주소를 입력해주기 DataRouterUrl=”https://{database}.bugsplat.com/post/ue4/{appName}/{appVersion}” 4.26 이후 버전에는 DefaultEngine.ini 파일을 아래 경로에 복사해줘야 함(폴더가 없으면 다 만들어서 넣어줘야 함) 패키지 빌드 폴더\\Engine\\Restricted\\NoRedist\\Programs\\CrashReportClient\\Config 패키지 빌드에서 크래시 발생시키면 대시보드에서 바로 볼 수 있음 BugSplat도 Trial로 설정해보고 테스트해보았는데 가이드 문서대로 설정해볼 수 있었습니다.BugSplat 설정 경험기: BugSplat - Uneal Engine 4.27 integration Backtrace 👍 https://backtrace.io/https://support.backtrace.io/hc/en-us/articles/360040106172-Unreal-Integration-Guide 백트레이스 서비스는 언리얼 엔진 설정이 가능한 솔루션이네요.가이드 문서상 크래시 덤프 사이즈 제한은 보이지 않습니다. 요 친구도 플러그인이 있지는 않고 따로 크래시 리포터 설정에 DataRouterUrl 설정만 해주면되네요.BugSplat과 동일하게 패키지 빌드 폴더\\Engine\\Restricted\\NoRedist\\Programs\\CrashReportClient\\Config 경로에 DefaultEngine.ini 가 있어야 크래시 덤프가 업로드되는 것 같습니다. 따로 플러그인은 있지 않고 단순 크래시 리포터 설정으로 가능하며 다른 크래시 분석 서비스와 비슷한 기능들을 가지고 있습니다. Overview: 대시보드로 크래시 전체적인 현황을 볼 수 있는 뷰 Release: 업데이트된 버전 별로 크래시 지표를 볼 수 있는 뷰 Triage: 발생한 크래시를 테이블로 볼 수 있는 뷰. 필터를 적용해서 볼 수도 있음 Debug: 각 크래시별 정보를 상세히 볼 수 있는 뷰 크래시 정보를 상세히 볼 수 있도록 심볼 업로드는 프로젝트 세팅 &gt; 심볼 설정에서 할 수 있습니다. 백트레이스도 크래시 분석 서비스들과 무난히 비슷한 서비스인 것 같네요.실제 다른 서비스와 장단점을 상세 분석해보려면 다양한 케이스로 사용해봐야할 것 같습니다. Raygun 🤔(⚠ 언리얼 엔진에 설정하기 쉽지 않은 서비스) https://raygun.com/ 레이건 서비스는 따로 언리얼 엔진 플러그인이 있지는 않네요.이 서비스를 사용한다면 C++ 항목으로 구성하고 minidump(breakpad)를 업로드하는 방식으로 시도해보았는데 잘 되지 않았습니다. 가이드 문서 확인 → sender.SendCrashReport(L&quot;https://api.raygun.com/entries/breakpad?apikey=...&quot;, userCustomData, files, 0); 코드 확인 → URL로 덤프를 보낼 수 있도록 설정 DefaultEngine.ini 에서 [CrashReportClient], DataRouterUrl 항목에 위 URL 입력 크래시 발생 후 크래시가 남는지 확인 → 확인할 수 없었음 다른 서비스에서 했던 것 처럼 크래시 업로드 URL에만 덤프를 올리면 가능할 것으로 기대했지만 잘되지 않네요.Raygun은 웹서비스 설정이 더 편한 서비스라고 보여서 설정을 더 시도해보지는 않았습니다. Countly ❓(⚠ 언리얼 엔진에 설정하기 쉽지 않은 서비스) https://countly.com/https://countly.com/feature/crashes-errors 카운틀리는 자체 서버 구축과 클라우드 서비스를 사용할 수 있는 서비스 시스템으로 볼 수 있습니다.자체 서버 구축: https://support.count.ly/hc/en-us/articles/360036862332-Installing-Countly-server언리얼 엔진 크래시 분석 서비스로 사용하려면 자체 서버 구축과 클라이언트에 minidump로 업로드 설정하는 방법으로 가능하네요. 마무리위와 같이 언리얼 엔진 게임으로 크래시 현황, 분석을 할 수 있는 5가지 정도의 서비스를 알아보았습니다. 핵심 기능은 비슷한 것 같았고 2가지 정도는 C++ 빌드로 만들어진 프로그램을 minidump를 업로드하고 그 것을 분석하는 방식을 가지고 있었네요.대부분 앱과 웹 서비스에서 발생하는 비정상 종료, 크래시를 분석하는 데에 맞춰져있었습니다. 언리얼 엔진으로 접근성이 좋았던 것은 Sentry 정도였고 나머지는 프로젝트 설정에 따라 커스텀 설정을 해줘야하는 것들이 좀 있었습니다. Countly의 경우에는 서버를 자체 구축할 수 있다는 점에서 크래시 덤프 파일 사이즈가 크더라도 사용할 수 있겠다 싶었습니다.(덤프에 많은 정보를 담고자할 경우 덤프 파일이 100MB가 넘어가는 경우도 있긴하더라구요.) Countly 설정은 클라, 크래시 분석 서비스 서버 설정까지 해야해서 나중에 한번 해보고 포스트 남겨보겠습니다. 👋","link":"/blog/2023/07/16/unreal-crash-analytics-services/"},{"title":"언리얼 엔진 5 얼리 액세스 출시","text":"언리얼 엔진 5 소식https://www.unrealengine.com/ko/blog/unreal-engine-5-is-now-available-in-early-access 지난 5월 26일에 언리얼 엔진 5가 얼리 액세스로 출시되었다는 소식이 있었습니다.얼리 액세스 전에 나왔던 영상에서도 많은 기대를 모았는데 어떤 기능들이 공개된 대로 동작할지 기대가됩니다. 지난 5월 13일에 공유된 영상 얼리 액세스 릴리스와 함께 공유된 영상 ⭐️ 영상에서 리스트 버튼을 눌러보시면 언리얼 엔진 5의 기능 리스트를 볼 수 있습니다. 언리얼 엔진 5 신기능 소개나나이트(Nanite) 가상화된 마이크로폴리곤 지오메트리 시스템 (Virtualized MicroPolygon Geometry System) 노멀 맵에 디테일을 베이크하거나 LOD를 직접 제작하는 것처럼 오래 걸리고 반복적인 작업을 생략함 루멘(Lumen) 완전한 다이나믹 글로벌 일루미네이션 솔루션 (Fully dynamic global illumination solution) 이를 통해 직사광, 지오메트리의 변화에 간접광이 실시간으로 반응하는 사실적인 다이나믹 씬을 제작할 수 있음 라이트 맵 UV를 제작하거나 라이트 맵 굽기를 기다리거나 리플렉션 캡쳐를 배치하지 않아도 됨 월드 파티션 시스템(World Partition System) 자동으로 월드를 그리드로 나누고, 필요에 따라 필수적인 셀을 스트리밍하는 기능 액터당 한개의 파일 시스템 - 협업을 원활히 할 수 있게 액터를 파일 단위로 하는 기능 데이터 레이어 레이어로 특정 조건, 상태에 따라 월드에 다른 베리에이션을 동일한 공간에 존재하는 레이어로 제작할 수 있음 애니메이션 컨트롤 릭(Control Rig) - Rig을 제작하고 다수 캐릭터에 공유, 포즈 취할 수 있도록 함 포즈 브라우저(Pose browser) - 포즈를 애셋화하거나 적용함 풀 바디 IK 솔버(Full body IK Solver) - 쉽게 동작 구현 도움 모션 워핑(Motion Warping) - 캐릭터 루트 모션을 다수의 타깃에 정렬되도록 동적으로 조정 가능 메타사운드(MetaSounds) 사운드 소스의 오디오 DSP 그래프 생성에 대한 완전한 제어를 제공 향상된 에디터 UI 및 워크플로우 콘텐츠 브라우저 고정 기능, 에디터 탭을 축소할 수 있는 기능 디테일 패널에서 자주 사용하는 프로퍼티를 빠르게 액세스할 수 있는 새로운 즐겨찾기 시스템 월드에 액터를 손쉽게 배치하게 해주는 메인 툴바의 새로운 생성 버튼, 새로운 프로젝트 생성을 위해 보다 쉽고 간소화된 워크플로도 제공 언리얼 엔진 5 보러가기언리얼 엔진 5는 에픽게임즈 런처를 통해 실행해볼 수 있습니다. com.epicgames.launcher://ue/ue5ea Github에도 코드를 볼 수 있으나 에픽 계정과 연동하고 볼 수 있습니다. https://github.com/EpicGames/UnrealEngine/releases/tag/5.0.0-early-access-1 튜토리얼도 있으니 한번 보고 해봐야겠어요. 😸 https://www.unrealengine.com/ko/onlinelearning-courses/ue5-early-access-quickstart 소개는 여기까지 하겠습니다. 자세한 내용은 원문을 참고해주세요!","link":"/blog/2021/06/05/unreal-engine5-early-access/"},{"title":"NDC 발표 리뷰: NDC2019 5년차 모바일 게임 생존기","text":"NDC 영상NDC: 〈크루세이더 퀘스트〉 5년차 모바일 게임 생존기Video: https://www.youtube.com/watch?v=Pi3LBWu-4Es 세션 설명:게임이 생존하려면 무엇이 필요할까요? 게임의 생존에 도움이 되는 방법은 없을까요?본 세션에선 이 질문에 대해 답을 시도합니다. 그리고, 이러한 답이 모바일게임 〈크루세이더 퀘스트〉의 개발 및 서비스 과정에 적용된 사례를 공유합니다.오래된 개발 환경의 개선, 유저분들의 실망을 만회해야하는 상황, 개발 프로세스의 문제 등 다양한 이슈와 마주한 분들께 조금이라도 도움이 되는 내용이길 희망합니다. 리뷰23년에 19년 발표 자료를 보고 리뷰하는게 뭔가 싶을 수 있지만.. 😁라이브 서비스하는 조직의 이야기는 굉장히 귀하기에 지난번에 보고 리뷰를 남겨보고 싶었습니다 강연에서 이야기한 내용의 요약무려 40분짜리 발표여서 요약을 한번 쓱 해보겠습니다.아래 참고기사에서 잘 요약해준 내용도 있으니 참고해보면 좋을 것 같네요. zdnet: https://zdnet.co.kr/view/?no=20190426154637 게임 조선: https://m.post.naver.com/viewer/postView.naver?volumeNo=19491452&memberNo=12478036 강연 노트강연 목표: “더 다양한 게임이 오래도록 생존하여 서로 의사결정의 길잡이가 되어주면 좋겠다!” 게임의 생존 조건, 생존 사례, 생존 전략을 다뤄봅니다 넓은 범위의 생존 = 유저가 게임을 플레이할 수 있음 좁은 범위의 생존 = 지속 가능성을 기준으로 손익분기점(break-even point, BEP)을 넘겨야 생존한 게임 생존 조건 = 이용자, 개발팀, 수익 이용자: 유입은 어렵고, 이탈은 쉽게 이뤄짐 / 개발팀: 프로젝트 매력도 등등.. / 수익: BM 설계 등등.. 게임 특징: 2019년 당시 5년차 모바일 게임. 글로벌 서비스 (23년 기준 9년차..) 이용자 이탈 🔥 1개월 없데이트, 업데이트한 내용 불만족, 부족한 이벤트, 반복되는 연장점검과 긴급점검, 앱 용량, 게임 정보 취득 어려움, 버그 Action: 장기 서비스 유지를 위해 이용자 이탈 개선을 우선순위로 개발 목표 설정 Result: 이탈 위험이 높은 유저 지표가 개선되었음 대규모 업데이트 후 이용자 수 지속적으로 하락 게임 피로도 상승, 콘텐츠에 대한 피로도가 높은 상태였음 Action: 이용자 수 하락 원인 개선 - 편의성 업데이트, 보상 개선 Result: DAU 하락세 방어 개발팀 HP 경고(피로도 누적) 🔥 개발팀 추가 근무량이 많아 피로 스트레스가 많았음. 실제 업무 시간 파악도 어려웠음 개발 계획 변동, 일정 부족, 계약으로 인해 고정된 출시 목표, 밤샘 테스트, 서버 불안정 Action: 개발환경 개선 → Unity 4 → 5 업그레이드 서버 최적화를 최우선 순위로 개발 일정 조정 근본적인 버그 대응을 위해 엔진 버전 업데이트 Action: 추가근무 시간 기록, 개발 프로세스 개선 - 병목 지점 파악 후 우선순위로 개선 개발 진행상황을 누구나 쉽게 알 수 있도록 시각화 Result: 추가 근무 시간 62% 감소. 콘텐츠 업데이트도 안정적으로 진행 수익화 - 구매자 수(PU, Pay User) 감소세 🔥 게임에 대한 애정 감소, 구매 동기 저하, 상품 매력 감소 등 Action: 좋은 보상(애정을 회복할 수 있도록 이벤트), 콜라보, 상점 UX 개선 등 생존 전략 = 포지셔닝, 병목 현상 제거, 끝맺기 포지셔닝 - 어떤 게임으로 인식되고 싶은지 명확하게 정의. 우선순위를 설정하기 위해서 병목 제거 - 리소스를 효과적으로 사용하기 위해서. 포스트잇 활용해서 시각화하고 개선해봄 끝맺기 - 체크리스트를 정리하고 마지막까지 확인해야함. 회의 마지막에 리캡하고 공유함 실무에 도입할때는 팀이 받아들일 준비가 되었을 때 실무에 적용하자 모바일 게임의 생존률(좁은 범위 생존)은 40% 정도 의사결정이 큰 영향을 주고 있으니 생존 조건의 적신호에서 잘 대응해나가야 한다 리뷰 소감현재 라이브 중인 게임의 프로덕션 과정, 이슈 관리 등을 이야기하는 것이 쉽지 않았을텐데 이런 이야기를 들을 수 있게되어서 좋았던 것 같습니다.생각해보면 다른 소프트웨어 개발도 다 마찬가지이지만 게임 개발에 있어서 많은 난관이 있는데 어떤 기준으로 해결해나갔는지 알 수 있어서 좋았습니다. 역시 서비스에서는 이탈 개선이 반드시 이뤄져야하고 개발팀의 리텐션도 중요하고 돈도 잘 벌어야하고 쉽지 않네요 😇","link":"/blog/2023/07/23/think-ndc19-review/"},{"title":"우리에게 1ms의 의미란 (FPS vs Frame time)","text":"Intro이 글은 최적화 관점에서 FPS(Frame Per Second) 대신 Frame time(1ms)을 어떤 의미로 어떻게 볼 수 있는지에 대해 간단히 이야기해봅니다. FPS? Frame time?FPS는 다들 많이 들어보았을 것 같습니다. 말 그대로 Frame Per Second, 프레임 당 초(시간)을 의미하며 Frame rate(프레임률)이라고도 말합니다. 위키 참고: https://ko.wikipedia.org/wiki/프레임_레이트 1초 동안 보여주는 화면(프레임)의 수 예를 들면, FPS 60 == 1초당 60 프레임을 그린다고 볼 수 있겠습니다. **Frame time(프레임 시간)**은 FPS에 비해서 생소할 수 있지만 간단히 말하면 화면(프레임)이 그려지는데 걸리는 시간입니다. (한 프레임을 그리는데 사용할 수 있는 버퍼 시간으로도 볼 수 있습니다.) FPS와 동일하게 예를 들면, frame time 16ms == 화면 1개 그리는데 16ms 소요된다고 볼 수 있습니다.FPS와 Frame time을 엮어서 보면 아래와 같겠죠 FPS Frame time Frame time(ms) 20 1/20 50ms 30 1/30 33.33ms 60 1/60 16.67ms 100 1/100 10ms 144 1/144 6.9ms 이렇게 보니 FPS와 Frame time이 연관이 있는 것은 알았습니다. 최적화 관점에서 이 두 값을 어떤 의미로 볼 수 있을까요? 최적화 후 1ms 차이게임을 개발하면서 FPS가 안정적일 수 있도록, 더 높은 FPS로 플레이할 수 있도록 최적화를 하는데요. 이 때 최적화 결과 Frame time이 1ms 줄었을 때 FPS 변화는 어떻게될까요? FPS와 Frame time 관계를 보았을 때 60 FPS 기준으로 Frame time은 16.67ms 였는데요. Frame time이 16.67ms → 15.57ms가 될 경우, 60 FPS → 63.8 FPS. 약 3.8 FPS 상승합니다. 더 높은 FPS에서는 어떨까요? 10ms → 9ms가 되면 100 FPS → 111.11 FPS. 약 11.11 FPS 상승합니다. 최적화 후에는 FPS를 보는 것 보다 Frame time을 보는게 더 명확하다60 FPS 고정인 상태 또는 게임에서의 부하(stress), 여러가지 하드웨어 환경에 따라 측정 결과가 다를 수 있긴합니다. 다만 최적화 후 개선된 항목(function 또는 Operation)이 얼마나 게임 환경(성능)에 영향을 주었는지를 Frame time 변화를 통해서 조금 더 명확하게 볼 수 있습니다. 물론 FPS 보다는 바로 이해가 가지 않을 수는 있지만 다른 요소에 영향을 받지 않는 수치로 볼 수 있는 것이죠. Fin일반인(?)의 시선으로 Frame time을 최적화 관점에서 정리를 해보았습니다. 항상 최적화 이후에 1ms, 0.5ms 개선했다는 내용이 큰 개선인가? 하는 의문이 있었고 그런 참에 계산해보고 정리해보면서 개선의 크기와 영향도를 알게되어서 즐거운 공부였네요. 틀린 내용이 있다면 편하게 댓글 남겨주세요.고맙습니다. :) 참고 영상https://www.youtube.com/watch?v=GpYyjb5mz48","link":"/blog/2020/11/03/what-is-meaning-1ms/"}],"tags":[{"name":"Retrospective","slug":"Retrospective","link":"/blog/tags/Retrospective/"},{"name":"Jira","slug":"Jira","link":"/blog/tags/Jira/"},{"name":"Atlassian","slug":"Atlassian","link":"/blog/tags/Atlassian/"},{"name":"Framework","slug":"Framework","link":"/blog/tags/Framework/"},{"name":"Playbook","slug":"Playbook","link":"/blog/tags/Playbook/"},{"name":"PM","slug":"PM","link":"/blog/tags/PM/"},{"name":"Book","slug":"Book","link":"/blog/tags/Book/"},{"name":"ScriptRunner","slug":"ScriptRunner","link":"/blog/tags/ScriptRunner/"},{"name":"Confluence","slug":"Confluence","link":"/blog/tags/Confluence/"},{"name":"ReleaseNotes","slug":"ReleaseNotes","link":"/blog/tags/ReleaseNotes/"},{"name":"Graphics","slug":"Graphics","link":"/blog/tags/Graphics/"},{"name":"DirectX","slug":"DirectX","link":"/blog/tags/DirectX/"},{"name":"RenderDoc","slug":"RenderDoc","link":"/blog/tags/RenderDoc/"},{"name":"Profiling","slug":"Profiling","link":"/blog/tags/Profiling/"},{"name":"Javascript Weekly","slug":"Javascript-Weekly","link":"/blog/tags/Javascript-Weekly/"},{"name":"Jira Cloud","slug":"Jira-Cloud","link":"/blog/tags/Jira-Cloud/"},{"name":"OpenGL-ES","slug":"OpenGL-ES","link":"/blog/tags/OpenGL-ES/"},{"name":"Study","slug":"Study","link":"/blog/tags/Study/"},{"name":"Perforce","slug":"Perforce","link":"/blog/tags/Perforce/"},{"name":"Helix Swarm","slug":"Helix-Swarm","link":"/blog/tags/Helix-Swarm/"},{"name":"Article","slug":"Article","link":"/blog/tags/Article/"},{"name":"IoT","slug":"IoT","link":"/blog/tags/IoT/"},{"name":"Unreal Engine","slug":"Unreal-Engine","link":"/blog/tags/Unreal-Engine/"},{"name":"Sentry","slug":"Sentry","link":"/blog/tags/Sentry/"},{"name":"Computer Graphics","slug":"Computer-Graphics","link":"/blog/tags/Computer-Graphics/"},{"name":"Tool","slug":"Tool","link":"/blog/tags/Tool/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/blog/tags/CI-CD/"},{"name":"FileOpenLog","slug":"FileOpenLog","link":"/blog/tags/FileOpenLog/"},{"name":"article","slug":"article","link":"/blog/tags/article/"},{"name":"Game","slug":"Game","link":"/blog/tags/Game/"},{"name":"Blender","slug":"Blender","link":"/blog/tags/Blender/"},{"name":"BugSplat","slug":"BugSplat","link":"/blog/tags/BugSplat/"},{"name":"Fisheye","slug":"Fisheye","link":"/blog/tags/Fisheye/"},{"name":"Windows","slug":"Windows","link":"/blog/tags/Windows/"},{"name":"GitLab","slug":"GitLab","link":"/blog/tags/GitLab/"},{"name":"CI","slug":"CI","link":"/blog/tags/CI/"},{"name":"Flutter","slug":"Flutter","link":"/blog/tags/Flutter/"},{"name":"Life log","slug":"Life-log","link":"/blog/tags/Life-log/"},{"name":"blog","slug":"blog","link":"/blog/tags/blog/"},{"name":"Project management","slug":"Project-management","link":"/blog/tags/Project-management/"},{"name":"NDC","slug":"NDC","link":"/blog/tags/NDC/"},{"name":"ngrok","slug":"ngrok","link":"/blog/tags/ngrok/"},{"name":"Tips","slug":"Tips","link":"/blog/tags/Tips/"},{"name":"Think","slug":"Think","link":"/blog/tags/Think/"},{"name":"Issue Tracker","slug":"Issue-Tracker","link":"/blog/tags/Issue-Tracker/"},{"name":"Crash reporter","slug":"Crash-reporter","link":"/blog/tags/Crash-reporter/"},{"name":"Crash","slug":"Crash","link":"/blog/tags/Crash/"},{"name":"UnrealEngine","slug":"UnrealEngine","link":"/blog/tags/UnrealEngine/"},{"name":"Updates","slug":"Updates","link":"/blog/tags/Updates/"},{"name":"General Engineering","slug":"General-Engineering","link":"/blog/tags/General-Engineering/"}],"categories":[{"name":"Life","slug":"Life","link":"/blog/categories/Life/"},{"name":"PM","slug":"PM","link":"/blog/categories/PM/"},{"name":"Framework","slug":"PM/Framework","link":"/blog/categories/PM/Framework/"},{"name":"System","slug":"PM/System","link":"/blog/categories/PM/System/"},{"name":"Book","slug":"Life/Book","link":"/blog/categories/Life/Book/"},{"name":"Tech","slug":"Tech","link":"/blog/categories/Tech/"},{"name":"Program&amp;Service","slug":"Tech/Program-Service","link":"/blog/categories/Tech/Program-Service/"},{"name":"Game","slug":"Tech/Game","link":"/blog/categories/Tech/Game/"},{"name":"Work","slug":"PM/Work","link":"/blog/categories/PM/Work/"},{"name":"Javascript","slug":"Tech/Javascript","link":"/blog/categories/Tech/Javascript/"},{"name":"IoT","slug":"Life/IoT","link":"/blog/categories/Life/IoT/"},{"name":"Study","slug":"Life/Study","link":"/blog/categories/Life/Study/"},{"name":"Blog","slug":"Blog","link":"/blog/categories/Blog/"},{"name":"Think","slug":"Life/Think","link":"/blog/categories/Life/Think/"}]}